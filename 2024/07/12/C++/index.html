<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>c++ | FY的博客</title><meta name="author" content="二马山石"><meta name="copyright" content="二马山石"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. C++ 异">
<meta property="og:type" content="article">
<meta property="og:title" content="c++">
<meta property="og:url" content="https://fylhg.github.io/github.fy/2024/07/12/C++/index.html">
<meta property="og:site_name" content="FY的博客">
<meta property="og:description" content="Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. C++ 异">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img2.baidu.com/it/u=1339810107,1799612389&fm=253&fmt=auto&app=138&f=JPEG?w=512&h=328">
<meta property="article:published_time" content="2024-07-12T07:18:51.931Z">
<meta property="article:modified_time" content="2024-08-30T02:36:59.126Z">
<meta property="article:author" content="二马山石">
<meta property="article:tag" content="c++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img2.baidu.com/it/u=1339810107,1799612389&fm=253&fmt=auto&app=138&f=JPEG?w=512&h=328"><link rel="shortcut icon" href="/github.fy/img/favicon.png"><link rel="canonical" href="https://fylhg.github.io/github.fy/2024/07/12/C++/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/github.fy/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/github.fy/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'c++',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-30 10:36:59'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/github.fy/img/1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/github.fy/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/github.fy/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/github.fy/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/github.fy/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/github.fy/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/github.fy/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/github.fy/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/github.fy/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/github.fy/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/github.fy/link/"><i class="fa-fw fas fa-link"></i><span> 连接</span></a></div><div class="menus_item"><a class="site-page" href="/github.fy/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img2.baidu.com/it/u=1339810107,1799612389&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=512&amp;h=328')"><nav id="nav"><span id="blog-info"><a href="/github.fy/" title="FY的博客"><img class="site-icon" src="/github.fy/img/1.jpg"/><span class="site-name">FY的博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/github.fy/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/github.fy/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/github.fy/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/github.fy/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/github.fy/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/github.fy/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/github.fy/link/"><i class="fa-fw fas fa-link"></i><span> 连接</span></a></div><div class="menus_item"><a class="site-page" href="/github.fy/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">c++</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-12T07:18:51.931Z" title="发表于 2024-07-12 15:18:51">2024-07-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-30T02:36:59.126Z" title="更新于 2024-08-30 10:36:59">2024-08-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/github.fy/categories/c/">c++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="c++"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h1 id="C-异常处理"><a href="#C-异常处理" class="headerlink" title="C++ 异常处理"></a>C++ 异常处理</h1><p>异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。</p>
<p>异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：<strong>try、catch、throw</strong>。</p>
<ul>
<li><strong>throw:</strong> 当问题出现时，程序会抛出一个异常。这是通过使用 <strong>throw</strong> 关键字来完成的。</li>
<li><strong>catch:</strong> 在您想要处理问题的地方，通过异常处理程序捕获异常。<strong>catch</strong> 关键字用于捕获异常。</li>
<li><strong>try:</strong> <strong>try</strong> 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。</li>
</ul>
<p>如果有一个块抛出一个异常，捕获异常的方法会使用 <strong>try</strong> 和 <strong>catch</strong> 关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。使用 try&#x2F;catch 语句的语法如下所示：</p>
<p>try { &#x2F;&#x2F; 保护代码 }catch( ExceptionName e1 ) { &#x2F;&#x2F; catch 块 }catch( ExceptionName e2 ) { &#x2F;&#x2F; catch 块 }catch( ExceptionName eN ) { &#x2F;&#x2F; catch 块 }</p>
<p>如果 <strong>try</strong> 块在不同的情境下会抛出不同的异常，这个时候可以尝试罗列多个 <strong>catch</strong> 语句，用于捕获不同类型的异常。</p>
<h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>您可以使用 <strong>throw</strong> 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。</p>
<p>以下是尝试除以零时抛出异常的实例：</p>
<p>double division(int a, int b) { if( b &#x3D;&#x3D; 0 ) { throw “Division by zero condition!”; } return (a&#x2F;b); }</p>
<h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><p><strong>catch</strong> 块跟在 <strong>try</strong> 块后面，用于捕获异常。您可以指定想要捕捉的异常类型，这是由 catch 关键字后的括号内的异常声明决定的。</p>
<p>try { &#x2F;&#x2F; 保护代码 }catch( ExceptionName e ) { &#x2F;&#x2F; 处理 ExceptionName 异常的代码 }</p>
<p>上面的代码会捕获一个类型为 <strong>ExceptionName</strong> 的异常。如果您想让 catch 块能够处理 try 块抛出的任何类型的异常，则必须在异常声明的括号内使用省略号 …，如下所示：</p>
<p>try { &#x2F;&#x2F; 保护代码 }catch(…) { &#x2F;&#x2F; 能处理任何异常的代码 }</p>
<p>下面是一个实例，抛出一个除以零的异常，并在 catch 块中捕获该异常。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>#include &lt;iostream&gt; using namespace std; double division(int a, int b) { if( b &#x3D;&#x3D; 0 ) { throw “Division by zero condition!”; } return (a&#x2F;b); } int main () { int x &#x3D; 50; int y &#x3D; 0; double z &#x3D; 0; try { z &#x3D; division(x, y); cout &lt;&lt; z &lt;&lt; endl; }catch (const char* msg) { cerr &lt;&lt; msg &lt;&lt; endl; } return 0; }</p>
<p>由于我们抛出了一个类型为 <strong>const char*</strong> 的异常，因此，当捕获该异常时，我们必须在 catch 块中使用 const char*。当上面的代码被编译和执行时，它会产生下列结果：</p>
<p>Division by zero condition!</p>
<h2 id="C-标准的异常"><a href="#C-标准的异常" class="headerlink" title="C++ 标准的异常"></a>C++ 标准的异常</h2><p>C++ 提供了一系列标准的异常，定义在 <strong><exception></strong> 中，我们可以在程序中使用这些标准的异常。它们是以父子类层次结构组织起来的，如下所示：</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2015/05/exceptions_in_cpp.png" alt="C++ 异常的层次结构"></p>
<p>下表是对上面层次结构中出现的每个异常的说明：</p>
<table>
<thead>
<tr>
<th>异常</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>std::exception</strong></td>
<td>该异常是所有标准 C++ 异常的父类。</td>
</tr>
<tr>
<td>std::bad_alloc</td>
<td>该异常可以通过 <strong>new</strong> 抛出。</td>
</tr>
<tr>
<td>std::bad_cast</td>
<td>该异常可以通过 <strong>dynamic_cast</strong> 抛出。</td>
</tr>
<tr>
<td>std::bad_typeid</td>
<td>该异常可以通过 <strong>typeid</strong> 抛出。</td>
</tr>
<tr>
<td>std::bad_exception</td>
<td>这在处理 C++ 程序中无法预期的异常时非常有用。</td>
</tr>
<tr>
<td><strong>std::logic_error</strong></td>
<td>理论上可以通过读取代码来检测到的异常。</td>
</tr>
<tr>
<td>std::domain_error</td>
<td>当使用了一个无效的数学域时，会抛出该异常。</td>
</tr>
<tr>
<td>std::invalid_argument</td>
<td>当使用了无效的参数时，会抛出该异常。</td>
</tr>
<tr>
<td>std::length_error</td>
<td>当创建了太长的 std::string 时，会抛出该异常。</td>
</tr>
<tr>
<td>std::out_of_range</td>
<td>该异常可以通过方法抛出，例如 std::vector 和 std::bitset&lt;&gt;::operator[]()。</td>
</tr>
<tr>
<td><strong>std::runtime_error</strong></td>
<td>理论上不可以通过读取代码来检测到的异常。</td>
</tr>
<tr>
<td>std::overflow_error</td>
<td>当发生数学上溢时，会抛出该异常。</td>
</tr>
<tr>
<td>std::range_error</td>
<td>当尝试存储超出范围的值时，会抛出该异常。</td>
</tr>
<tr>
<td>std::underflow_error</td>
<td>当发生数学下溢时，会抛出该异常。</td>
</tr>
</tbody></table>
<h2 id="定义新的异常"><a href="#定义新的异常" class="headerlink" title="定义新的异常"></a>定义新的异常</h2><p>您可以通过继承和重载 <strong>exception</strong> 类来定义新的异常。下面的实例演示了如何使用 std::exception 类来实现自己的异常：</p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>#include &lt;iostream&gt; #include &lt;exception&gt; using namespace std; struct MyException : public exception { const char * what () const throw () { return “C++ Exception”; } }; int main() { try { throw MyException(); } catch(MyException&amp; e) { std::cout &lt;&lt; “MyException caught” &lt;&lt; std::endl; std::cout &lt;&lt; e.what() &lt;&lt; std::endl; } catch(std::exception&amp; e) { &#x2F;&#x2F;其他的错误 } }</p>
<p>这将产生以下结果：</p>
<p>MyException caught<br>C++ Exception</p>
<p>在这里，<strong>what()</strong> 是异常类提供的一个公共方法，它已被所有子异常类重载。这将返回异常产生的原因。</p>
<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id="类的封装"><a href="#类的封装" class="headerlink" title="类的封装"></a>类的封装</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	string Private=<span class="string">&quot;私有属性类外无法访问&quot;</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string Protected=<span class="string">&quot;保护属性类外无法访问&quot;</span>;<span class="comment">//但是子类可以访问父类中的保护属性</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">double</span> C;</span><br><span class="line">	<span class="type">double</span> S;</span><br><span class="line">	<span class="built_in">circle</span>(<span class="type">double</span> r)</span><br><span class="line">	&#123;</span><br><span class="line">		C = <span class="number">2</span> * r * pi;</span><br><span class="line">		S = pi * r * r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//通过设置的共有方法来实现对于私有属性和保护属性的设置修改等操作</span></span><br><span class="line">	<span class="function">string <span class="title">get_private</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Protected;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">circle <span class="title">fy</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;创建圆的周长为：&quot;</span> &lt;&lt; fy.C &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;创建圆的面积为：&quot;</span> &lt;&lt; fy.S &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对象的初始化和处理"><a href="#对象的初始化和处理" class="headerlink" title="对象的初始化和处理"></a>对象的初始化和处理</h2><h3 id="构造函数的分类"><a href="#构造函数的分类" class="headerlink" title="构造函数的分类"></a>构造函数的分类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="comment">//构造函数的分类：</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.无参构造函数，有参构造函数</span></span><br><span class="line">	<span class="built_in">Student</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;这是无参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Student</span>(<span class="type">int</span> a)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//当有参数的时候，赋值给类中的属性</span></span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;这是有参的普通构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//2.普通构造函数，拷贝构造函数</span></span><br><span class="line">	<span class="built_in">Student</span>(<span class="type">const</span> Student&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		age = p.age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Student</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数，内存销毁&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_student</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//对于不同类型的构造函数，有不同的创建方式</span></span><br><span class="line">	<span class="comment">//1.括号法：</span></span><br><span class="line">	Student stu1;<span class="comment">//无参构造</span></span><br><span class="line">	<span class="function">Student <span class="title">stu2</span><span class="params">(<span class="number">18</span>)</span></span>;<span class="comment">//有参构造的快速创建</span></span><br><span class="line">	<span class="comment">//Student stu1();错误 会被认为是函数声明</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.显式法：</span></span><br><span class="line">	Student stu3 = <span class="built_in">Student</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="comment">//Student(10)是一个匿名对象，如果单写的话，这个语句结束后就会调用析构函数	</span></span><br><span class="line">	Student stu4 = <span class="built_in">Student</span>(stu3);<span class="comment">//拷贝构造，将stu3的数据拷贝到stu4</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Student(stu3);错误不要利用拷贝构造函数来初始化匿名对象，会被认为是对象的声明</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.隐式法：</span></span><br><span class="line">	Student stu5 = <span class="number">10</span>;</span><br><span class="line">	Student stu6 = stu5;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="built_in">test_student</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>对象的构造函数会默认自带：一个无参构造函数，和一个浅拷贝构造函数。如要深拷贝需要自定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">student</span>(string Name,<span class="type">int</span> Age)</span><br><span class="line">	&#123;</span><br><span class="line">		name = Name;</span><br><span class="line">		age = <span class="keyword">new</span> <span class="built_in">int</span>(Age);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数初始化&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">student</span>(<span class="type">const</span> student&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		name = p.name;</span><br><span class="line">		<span class="comment">//浅拷贝构造函数,会将属性单纯的赋值过去</span></span><br><span class="line">		<span class="comment">//age = p.age;会出问题，他俩指向的地址相同析构函数释放内存的时候，会出现重复操作</span></span><br><span class="line">		<span class="comment">//所以深拷贝为了解决这个问题，则需要再次用new开辟堆的空间，使得两个析构函数在释放内存的时候</span></span><br><span class="line">		<span class="comment">//不会产生冲突</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//深拷贝：</span></span><br><span class="line">		age = <span class="keyword">new</span> <span class="built_in">int</span>(*(p.age));</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;深拷贝已经完成&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span>* age;</span><br><span class="line">	~<span class="built_in">student</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数已经释放内存&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">student <span class="title">fy</span><span class="params">(<span class="string">&quot;冯岩&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="comment">//无参构造函数，对象创建的时候不允许带括号</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//student hg(fy);</span></span><br><span class="line">	<span class="comment">//student hg = student(fy);</span></span><br><span class="line">	<span class="comment">//student hg = fy;</span></span><br><span class="line">	<span class="comment">//三种写法参考一下</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造函数的初始化列表"><a href="#构造函数的初始化列表" class="headerlink" title="构造函数的初始化列表"></a>构造函数的初始化列表</h3><p>作用:<br>C++提供了初始化列表语法,用来初始化属性</p>
<p>语法:<br>构造函数():属性1(值1),属性2(值2) … {}</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">get_private</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;age:&quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;grade:&quot;</span> &lt;&lt; grade &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">student</span>(<span class="type">int</span> Age,<span class="type">int</span> Grade,string Name) :<span class="built_in">age</span>(Age),<span class="built_in">grade</span>(Grade),<span class="built_in">name</span>(Name)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;age:&quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;grade:&quot;</span> &lt;&lt; grade &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//在构造函数中可以发现，私有属性已经被初始化了</span></span><br><span class="line">	&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span> grade;</span><br><span class="line">	string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">student <span class="title">fy</span><span class="params">(<span class="number">20</span>, <span class="number">100</span>, <span class="string">&quot;冯岩&quot;</span>)</span></span>;</span><br><span class="line">	fy.<span class="built_in">get_private</span>();<span class="comment">//共有方法来访问私有属性</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类对象作为类成员：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="built_in">student</span>(string Name) : <span class="built_in">name</span>(Name) &#123;</span><br><span class="line">	</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;student的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">teacher</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string name;</span><br><span class="line">	student fy;</span><br><span class="line">	<span class="built_in">teacher</span>(string Name,string stu):<span class="built_in">name</span>(Name),<span class="built_in">fy</span>(stu)&#123;</span><br><span class="line">	</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;teacher的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//fy(stu)相当于student fy = &quot;名字&quot; = stu</span></span><br><span class="line">	<span class="comment">//属于的是构造函数的隐式赋值的方法，直接实现对于类中对象为类的初始化</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//注：如果一个类中有成员类，那么在初始化的时候，回先调用类内成员类的构造函数</span></span><br><span class="line">	<span class="comment">//注：析构函数调用的先后顺序则相反</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">teacher</span>(<span class="string">&quot;韩歌&quot;</span>, <span class="string">&quot;冯岩&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="静态成员-变量-函数"><a href="#静态成员-变量-函数" class="headerlink" title="静态成员(变量&amp;函数)"></a>静态成员(变量&amp;函数)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//类对象作为类成员：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//静态成员变量的特点：</span></span><br><span class="line">	<span class="comment">//1.编译阶段就会给静态成员分配内存</span></span><br><span class="line">	<span class="comment">//2.类内声明，类外初始化</span></span><br><span class="line">	<span class="comment">//3.所有对象共享同一份数据</span></span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> num_A;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员函数的特点：</span></span><br><span class="line">	<span class="comment">//1.所有对象共享静态成员函数</span></span><br><span class="line">	<span class="comment">//2.静态成员函数只能对静态成员变量做出操作</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;这是一个静态成员函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;静态成员函数操作static静态成员变量：num_A&quot;</span> &lt;&lt; num_A &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">student</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		num_A++;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//静态成员也是有访问权限的</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> num_B;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> student::num_A = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> student::num_B = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//静态变量初始话在类外，类型 类名::变量名 = 值</span></span><br><span class="line"><span class="comment">//其中student::num_A表示的是作用域在student中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//静态成员的两种访问方式：</span></span><br><span class="line">	<span class="comment">//1.通过创建的类来访问</span></span><br><span class="line">	student fy;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;创建了 &quot;</span>&lt;&lt;fy.num_A&lt;&lt;<span class="string">&quot; 个student对象&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//2.通过类名直接访问  类名::static数据</span></span><br><span class="line">	student hg;</span><br><span class="line">	cout &lt;&lt;<span class="string">&quot;创建了 &quot;</span> &lt;&lt; student::num_A &lt;&lt;<span class="string">&quot; 个student对象&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//cout&lt;&lt;student::num_B&lt;&lt;endl;私有属性是访问不到的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员函数的两种调用方式：</span></span><br><span class="line">	hg.<span class="built_in">print</span>();<span class="comment">//1.调用静态成员函数</span></span><br><span class="line">	<span class="comment">//2.也可以同过类名直接调用</span></span><br><span class="line">	student::<span class="built_in">print</span>();</span><br><span class="line">	<span class="comment">//注：静态成员函数如果是私有的话，同样不可以被访问</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="c-对象模型和this指针"><a href="#c-对象模型和this指针" class="headerlink" title="c++对象模型和this指针"></a>c++对象模型和this指针</h2><h3 id="成员变量和成员函数分开存储"><a href="#成员变量和成员函数分开存储" class="headerlink" title="成员变量和成员函数分开存储"></a>成员变量和成员函数分开存储</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//类对象作为类成员：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//静态成员变量 - 不属于类对象上</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> num_A;</span><br><span class="line">	<span class="comment">//静态成员方法 - 不属于类对象上</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="comment">//非静态成员变量 - 属于类对象上</span></span><br><span class="line">	<span class="type">int</span> num_B;</span><br><span class="line">	<span class="comment">//非静态成员函数 - 不属于类对象上</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">do_print</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> student::num_A=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	student fy;</span><br><span class="line">	<span class="comment">//c++会给空对象分配内存空间：1个字节</span></span><br><span class="line">	<span class="comment">//目的是为了区分空对象占用内存的位置</span></span><br><span class="line">	<span class="comment">//每个空对象也应该有一个独一无二的内存地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size of student类创建的fy:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(fy) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>类对象中只有非静态变量属于类对象上，<br>而每一个非静态函数实例只会诞生一份函数实例，也就是多个对象会共用一个相同的代码块。</p>
<p>this指针就是为了解决区分不同对象对于非静态函数的调用，<br>this指针会指向被调用成员函数所指向的对象</p>
<p>this用途：</p>
<ul>
<li>1.当形参和函数内部变量名字重名的时候，可用this指针来区分</li>
<li>2.在类的非静态成员函数中返回类的对象 return *this<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">student</span>(string name,<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//当形参与类内变量重名的时候，可以用this保证正确传递</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;	</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="function">student&amp; <span class="title">return_stu</span><span class="params">(<span class="type">const</span> student&amp;p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		age+=p.age;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">//可以这样去记 const int&amp;a 与 const int*p -&gt; a 等价于 *p</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//注意如果我们用的是 student不是student&amp;</span></span><br><span class="line">		<span class="comment">//return *this会传递一个和当前类相同的副本，成拷贝了</span></span><br><span class="line">		<span class="comment">//只有用引用才会返回我们当前调用这个函数对应的对象</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">student <span class="title">fy</span><span class="params">(<span class="string">&quot;冯岩&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">student <span class="title">hg</span><span class="params">(<span class="string">&quot;韩歌&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="comment">//***************重点：*****************</span></span><br><span class="line">	<span class="comment">//链式变成思想</span></span><br><span class="line">	fy.<span class="built_in">return_stu</span>(hg).<span class="built_in">return_stu</span>(hg);</span><br><span class="line">	cout &lt;&lt; fy.age &lt;&lt; endl;<span class="comment">//fy20+hg20+hg20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a>const修饰成员函数</h3><p><em><strong>重点：</strong></em></p>
<ul>
<li>1.指向常量的指针：这种指针指向的对象不能通过该指针修改。声明方式为const int* ptr;或者int const* ptr;，意味着ptr是一个指向int类型常量的指针。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* ptr; <span class="comment">// ptr 是指向常量整数的指针</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span>* ptr; <span class="comment">// 同上，ptr 是指向常量整数的指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">ptr = &amp;x; <span class="comment">// 合法，ptr 指向 x 的地址</span></span><br><span class="line">*ptr = <span class="number">20</span>; <span class="comment">// 非法，因为 ptr 指向的是一个常量，不能修改其值</span></span><br></pre></td></tr></table></figure></li>
<li>2.常量的指针：这种指针本身是常量，声明方式为int* const ptr;，表示ptr是一个指向整数的常量指针，指针本身的值（即地址）不能修改。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="type">const</span> ptr; <span class="comment">// ptr 是一个指向整数的常量指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line">ptr = &amp;x; <span class="comment">// 合法，ptr 现在指向 x 的地址</span></span><br><span class="line">*ptr = <span class="number">30</span>; <span class="comment">// 合法，通过 ptr 可以修改 x 的值</span></span><br><span class="line">ptr = &amp;y; <span class="comment">// 非法，因为 ptr 是一个常量指针，不能修改其指向的地址</span></span><br></pre></td></tr></table></figure>
<em><strong>this就是一个常量指针！！！</strong></em><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常函数</span></span><br><span class="line"><span class="comment">//1.在成员函数后面加const，就成为常函数</span></span><br><span class="line"><span class="comment">//2.常函数内不可以修改成员属性</span></span><br><span class="line"><span class="comment">//3.成员属性的声明前+关键字mutable,在常函数中依旧可以修改。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">get_name</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//无法访问成员属性</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//只能访问加了关键字mutable的属性</span></span><br><span class="line">		age = <span class="number">0</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;访问加了关键字mutable的属性：age&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//常对象</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> Person fy;</span><br><span class="line">	<span class="comment">//常对象只能调用常函数</span></span><br><span class="line">	fy.<span class="built_in">get_name</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>友元的目的是让一个函数或者类去访问另一个类中的私有成员</p>
<p>友元的关键字为：<em><strong>friend</strong></em></p>
<p>友元的三种实现：</p>
<ul>
<li>全局函数作为友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
<h3 id="全局函数作友元"><a href="#全局函数作友元" class="headerlink" title="全局函数作友元"></a>全局函数作友元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">get_Person_Private</span><span class="params">(Person&amp; person)</span></span>;</span><br><span class="line">	<span class="comment">//告诉编译器这是一个该来的友元函数，可以访问类中的私有成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//全局函数作为友元函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_Person_Private</span><span class="params">(Person&amp; person)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Person中的私有属性name:&quot;</span> &lt;&lt; person.name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">fy</span><span class="params">(<span class="string">&quot;冯岩&quot;</span>)</span></span>;</span><br><span class="line">	<span class="built_in">get_Person_Private</span>(fy);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="类作友元"><a href="#类作友元" class="headerlink" title="类作友元"></a>类作友元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//成员函数作友元</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">father</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit_Son_mPrivate</span><span class="params">()</span></span>;</span><br><span class="line">	son* Son;</span><br><span class="line">	<span class="built_in">father</span>(string Son_name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span></span><br><span class="line">&#123;<span class="comment">//类作为友元，它的内部的方法可以访问son中的私有属性</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">father</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">son</span>(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">	string name;</span><br><span class="line">&#125;;</span><br><span class="line">father::<span class="built_in">father</span>(string son_name)</span><br><span class="line">&#123;</span><br><span class="line">	Son = <span class="keyword">new</span> <span class="built_in">son</span>(son_name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">father::visit_Son_mPrivate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; Son-&gt;name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="成员函数作友元"><a href="#成员函数作友元" class="headerlink" title="成员函数作友元"></a>成员函数作友元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//成员函数作友元</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">father</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit_son_mPrivate</span><span class="params">()</span></span>;<span class="comment">//希望通过父类的成员函数访问成员类中的私有属性</span></span><br><span class="line">	son* Son;</span><br><span class="line">	<span class="built_in">father</span>(string Son_name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//friend void visit_son_mPrivate();这样声明是错误的，因为这样定义的不是father中的函数</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">father::visit_son_mPrivate</span><span class="params">()</span></span>;<span class="comment">//必须在函数名字前加上作用域</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">son</span>(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">	string name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//之所以采用这种方式来定义构造函数，因为它涉及了多个类，所以在类都定义完后</span></span><br><span class="line"><span class="comment">//采取 类名::构造函数来定义</span></span><br><span class="line">father::<span class="built_in">father</span>(string Son_name)</span><br><span class="line">&#123;</span><br><span class="line">	Son = <span class="keyword">new</span> <span class="built_in">son</span>(Son_name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">father::visit_son_mPrivate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; Son-&gt;name &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">father <span class="title">me</span><span class="params">(<span class="string">&quot;hg&quot;</span>)</span></span>;</span><br><span class="line">	me.<span class="built_in">visit_son_mPrivate</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><ul>
<li>加号运算符重载</li>
<li>左移运算符重载</li>
<li>递增运算符重载</li>
<li>赋值运算符重载</li>
<li>关系运算符重载</li>
<li>函数调用运算符重载</li>
</ul>
<h3 id="加号运算符重载"><a href="#加号运算符重载" class="headerlink" title="加号运算符重载"></a>加号运算符重载</h3><ul>
<li>全局函数重载</li>
<li>成员函数重载<br><strong>注：无论哪种方式都需要在函数中创建一个新的类，最后将其return。</strong><br>全局函数重载<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Complex</span>(<span class="type">int</span> m_a, string m_name, <span class="type">double</span> m_digital) : <span class="built_in">m_A</span>(m_a), <span class="built_in">m_Name</span>(m_name), <span class="built_in">m_Digital</span>(m_digital) &#123;&#125;;</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">double</span> m_Digital;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//全局函数重载“+”</span></span><br><span class="line"><span class="comment">//opereator+加号重载</span></span><br><span class="line">Complex <span class="keyword">operator</span>+ (<span class="type">const</span> Complex&amp; A, <span class="type">const</span> Complex&amp; B)</span><br><span class="line">&#123;</span><br><span class="line">	Complex C = <span class="built_in">Complex</span>(<span class="number">10</span>, <span class="string">&quot;abc&quot;</span>, <span class="number">3.14</span>);</span><br><span class="line">	C.m_A = A.m_A + B.m_A;</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">A</span><span class="params">(<span class="number">10</span>, <span class="string">&quot;a&quot;</span>, <span class="number">3.1415</span>)</span></span>;</span><br><span class="line">	<span class="function">Complex <span class="title">B</span><span class="params">(<span class="number">11</span>, <span class="string">&quot;b&quot;</span>, <span class="number">3.1415</span>)</span></span>;</span><br><span class="line">	Complex C = A + B;</span><br><span class="line">	cout &lt;&lt; C.m_A &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
成员函数重载<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Complex</span>(<span class="type">int</span> m_a=<span class="number">0</span>, string m_name=<span class="string">&quot;&quot;</span>, <span class="type">double</span> m_digital=<span class="number">0.0</span>) : <span class="built_in">m_A</span>(m_a), <span class="built_in">m_Name</span>(m_name), <span class="built_in">m_Digital</span>(m_digital) &#123;&#125;;</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">double</span> m_Digital;</span><br><span class="line">	<span class="comment">//成员函数重载：operator+</span></span><br><span class="line">	Complex <span class="keyword">operator</span>+ ( <span class="type">const</span> Complex&amp; B)</span><br><span class="line">	&#123;</span><br><span class="line">		Complex C ;</span><br><span class="line">		C.m_A = <span class="keyword">this</span>-&gt;m_A + B.m_A;</span><br><span class="line">		<span class="keyword">return</span> C;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">A</span><span class="params">(<span class="number">10</span>, <span class="string">&quot;a&quot;</span>, <span class="number">3.1415</span>)</span></span>;</span><br><span class="line">	<span class="function">Complex <span class="title">B</span><span class="params">(<span class="number">11</span>, <span class="string">&quot;b&quot;</span>, <span class="number">3.1415</span>)</span></span>;</span><br><span class="line">	Complex C = A + B;</span><br><span class="line">	cout &lt;&lt; C.m_A &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a>左移运算符重载</h3><ul>
<li>全局函数重载<br>注：左移对象运算符重载，传入的引用参数前面最好加上const<br>因为有时候传入的可能是一个临时对象，（后置递增的时候就是这样的）。<br>临时对象在表达式结束的时候就会被销毁，加上const保障安全性<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;cout,<span class="type">const</span> 类名&amp;变量名)</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Complex</span>(<span class="type">int</span> m_a=<span class="number">0</span>, string m_name=<span class="string">&quot;&quot;</span>, <span class="type">double</span> m_digital=<span class="number">0.0</span>) : <span class="built_in">m_A</span>(m_a), <span class="built_in">m_Name</span>(m_name), <span class="built_in">m_Digital</span>(m_digital) &#123;&#125;;</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">double</span> m_Digital;</span><br><span class="line">	<span class="comment">//成员函数重载：operator&lt;&lt;</span></span><br><span class="line">	<span class="comment">//void operator&lt;&lt; (ostream &amp;cout )&#123;&#125;</span></span><br><span class="line">	<span class="comment">//不能这么写，这么写会导致 对象.operator&lt;&lt;(cout)相当于 对象&lt;&lt;cout,这样和正常的输出是相反的</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//全局函数重载：</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, Complex&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; p.m_Name &lt;&lt; p.m_A &lt;&lt; p.m_Digital;</span><br><span class="line">	<span class="comment">//把cout的引用返回，就可以链式的用cout的正常的功能了</span></span><br><span class="line">	<span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">A</span><span class="params">(<span class="number">10</span>, <span class="string">&quot;a&quot;</span>, <span class="number">3.1415</span>)</span></span>;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; A ;</span><br><span class="line">	<span class="comment">//当全局函数没有返回cout对象的时候后面不能加任何内容</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; A &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//当给return后可以链式的输出</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hero</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">hero</span>(<span class="type">int</span> bravery=<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span>* bravery;</span><br><span class="line">	<span class="comment">//运算符号重载</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//这里必须返回的是引用，不然会返回一个新的对象副本</span></span><br><span class="line">	hero&amp; <span class="keyword">operator</span>=(hero &amp;p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//编译器提供浅拷贝函数</span></span><br><span class="line">		<span class="comment">//this-&gt;name = p.name;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//先判断对象中是否有属性在堆区，先将堆区的内存释放，然后再深拷贝</span></span><br><span class="line">		<span class="keyword">if</span> (bravery != <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">delete</span>(bravery);<span class="comment">//释放内存后，要把属性置为空指针</span></span><br><span class="line">			bravery = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>-&gt;bravery = <span class="keyword">new</span> <span class="built_in">int</span>(*p.bravery);<span class="comment">//深拷贝防止析构函数内存重复释放</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">hero</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">delete</span>(bravery);</span><br><span class="line">		bravery = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">hero::<span class="built_in">hero</span>(<span class="type">int</span> bravery)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;bravery = <span class="keyword">new</span> <span class="built_in">int</span>(bravery);</span><br><span class="line">&#125;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> hero&amp; name)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; *(name.bravery);</span><br><span class="line">	<span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">hero <span class="title">fy</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">hero <span class="title">hg</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">	hero me;</span><br><span class="line">	me = fy;</span><br><span class="line">	cout &lt;&lt; me &lt;&lt; endl;<span class="comment">//10</span></span><br><span class="line">	me = hg;</span><br><span class="line">	cout &lt;&lt; me &lt;&lt; endl;<span class="comment">//20</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//10</span></span><br><span class="line">	me = hg = fy;<span class="comment">//要求重载=时函数要返回对象本身的引用</span></span><br><span class="line">	cout &lt;&lt; me &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h3><h3 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载"></a>函数调用运算符重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Myclass</span>(string s)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;构造函数：&quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//函数调用运算符重载，可以使得对象能和函数一样被调用</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt;<span class="string">&quot;()重载：&quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Myclass <span class="title">my</span><span class="params">(<span class="string">&quot;fyyf&quot;</span>)</span></span>;<span class="comment">//构造函数的调用</span></span><br><span class="line">	<span class="built_in">my</span>(<span class="string">&quot;fylhg&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="继承基本语法"><a href="#继承基本语法" class="headerlink" title="继承基本语法"></a>继承基本语法</h3><p>总结:<br>继承的好处:可以减少重复的代码</p>
<p><strong>class A : public B;</strong><br>A类称为子类 或 派生类<br>B类称为父类 或 基类</p>
<p>派生类中的成员,包含两大部分:<br>一类是从基类继承过来的,一类是自己增加的成员。<br>从基类继承过过来的表现其共性,而新增的成员体现了其个性。</p>
<h3 id="继承的方式"><a href="#继承的方式" class="headerlink" title="继承的方式"></a>继承的方式</h3><ul>
<li>公有继承</li>
<li>保护继承</li>
<li>私有继承<br><img src="/github.fy/assets/1366313.png"></li>
</ul>
<h3 id="继承模型的查看"><a href="#继承模型的查看" class="headerlink" title="继承模型的查看"></a>继承模型的查看</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">father</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//查看继承后对象的模型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用Visual Studio 2022 Developer Command Prompt</span></span><br><span class="line"><span class="comment">//cd到对应的目录下面</span></span><br><span class="line"><span class="comment">//dir查看当前路径下内容</span></span><br><span class="line"><span class="comment">//输入 cl /d1 reportSingleClassLayout类名 源.cpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> father</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	son fy;</span><br><span class="line">	<span class="comment">//16</span></span><br><span class="line">	<span class="comment">//父类中的非静态成员属性都会被继承下去</span></span><br><span class="line">	<span class="comment">//父类的私有属性会被编译器隐藏了，但却是被继承下来了。</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(son) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/github.fy/assets/4444.png"></p>
<h3 id="继承中构造和析构的顺序"><a href="#继承中构造和析构的顺序" class="headerlink" title="继承中构造和析构的顺序"></a>继承中构造和析构的顺序</h3><p>先调用父类的构造函数再调用子类的构造函数，析构函数则相反。</p>
<h3 id="继承同名成员的处理方式"><a href="#继承同名成员的处理方式" class="headerlink" title="继承同名成员的处理方式"></a>继承同名成员的处理方式</h3><p>问题：当子类与父类中出现相同名字的成员时，如何通过子类的对象访问到子类或者父类中的数据。</p>
<ul>
<li>访问子类中的同名成员，直接访问即可。</li>
<li>访问父类中的同名成员，需要加上作用域。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">father</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">father</span>(<span class="type">int</span> a)</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = a;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">return_mA</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;father中的m_A&quot;</span> &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> father</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">son</span>(<span class="type">int</span> a):<span class="built_in">father</span>(a)<span class="comment">//利用son中的构造函数对父类中的构造函数初始化</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_A = a;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">return_mA</span><span class="params">()</span><span class="comment">//父类和子类中都用同名函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;son中的m_A&quot;</span> &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> m_A;<span class="comment">//此时父类和子类中拥有相同名字的数据</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">son <span class="title">fy</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	fy.<span class="built_in">return_mA</span>();</span><br><span class="line">	fy.father::<span class="built_in">return_mA</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
总结：</li>
</ul>
<ol>
<li>子类对象可以直接访问到子类中同名成员<br>2.子类对象加作用域可以访问到父类同名成员<br>3.当子类与父类拥有同名的成员函数,子类会隐藏父类中同名成员函数,加作用域可以访问到父类中同名函数</li>
</ol>
<h3 id="同名静态成员的处理"><a href="#同名静态成员的处理" class="headerlink" title="同名静态成员的处理"></a>同名静态成员的处理</h3><p>首先复习一下静态成员和静态成员函数<br>静态成员属性：</p>
<ul>
<li>类内声明，类外初始化</li>
<li>访问方式：1.类名::静态成员属性。2.类.静态成员属性<br>静态成员函数：<br>  只能对于类中的静态成员属性进行操作。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">father</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">father</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> father::m_A = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> father</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">	<span class="comment">//子类和父类的静态成员重名</span></span><br><span class="line">	<span class="built_in">son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> son::m_A = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	son fy;</span><br><span class="line">	<span class="comment">//1.通过对象访问：</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;father中的m_A:&quot;</span> &lt;&lt; fy.father::m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;son中的m_A:&quot;</span> &lt;&lt; fy.son::m_A &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//2.通过类名访问：</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//由于son继承了father所以可以用下面这种方式访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;father中的m_A:&quot;</span> &lt;&lt; son::father::m_A&lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;son中的m_A:&quot;</span> &lt;&lt; son::m_A &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="多继承语法"><a href="#多继承语法" class="headerlink" title="多继承语法"></a>多继承语法</h3><p>C++允许一个类继承多个类</p>
<p>语法:</p>
<p>class 子类:继承方式 父类1,继承方式 父类2 …</p>
<p><em>注：多继承可能会引发父类中有同名成员出现,需要加作用域区分</em></p>
<p>C++实际开发中不建议用多继承</p>
<h3 id="菱形继承问题"><a href="#菱形继承问题" class="headerlink" title="菱形继承问题"></a>菱形继承问题</h3><p>利用虚继承，解决菱形继承问题<br>继承前面加上 virtual 变为虚继承<br>person成为虚基类<br>此时继承虚基类的类中会有一个vbptr（虚基指针）指向virtualtable列表，列表中记录着偏移量<br>这样多个继承了虚基类中的数据是同一份的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		string name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//利用虚继承，解决菱形继承问题</span></span><br><span class="line"><span class="comment">//继承前面加上 virtual 变为虚继承</span></span><br><span class="line"><span class="comment">//person成为虚基类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此时继承虚基类的类中会有一个vbptr（虚基指针）指向virtualtable列表，列表中记录着偏移量</span></span><br><span class="line"><span class="comment">//这样多个继承了虚基类中的数据是同一份的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">f</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> person</span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">y</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> person</span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">fy</span> :<span class="keyword">public</span> f, <span class="keyword">public</span> y</span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="多态的基本语法"><a href="#多态的基本语法" class="headerlink" title="多态的基本语法"></a>多态的基本语法</h3><p>多态的适用条件：</p>
<ul>
<li>1.有继承现象</li>
<li>2.子类重写父类中的虚函数<br>注：重写必须满足 返回类型，名字，参数列表完全一致称为重写。<br>多态使用：<br>父类指针或引用指向子类对象<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print_name</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;tool&quot;</span>  &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">framework</span> :<span class="keyword">public</span> tool</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print_name</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;framework&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">virtual_use</span><span class="params">(tool &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p.<span class="built_in">print_name</span>();</span><br><span class="line">	<span class="comment">//虽然用的是tool的引用，但是用虚函数重写，传入子类时，则执行的是子类的函数。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	framework fy;</span><br><span class="line">	fy.<span class="built_in">print_name</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h3><p>在多态中,通常父类中虚函数的实现是毫无意义的,主要都是调用子类重写的内容</p>
<p>因此可以将虚函数改为纯虚函数</p>
<p>纯虚函数语法:</p>
<p><strong>virtual 返回值类型 函数名 (参数列表)&#x3D;0;</strong></p>
<p>当类中有了纯虚函数,这个类也称为抽象类</p>
<p>抽象类特点:</p>
<ul>
<li><p>无法实例化对象</p>
</li>
<li><p>子类必须重写抽象类中的纯虚函数,否则也属于抽象类Ⅰ</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//纯虚函数和抽象类</span></span><br><span class="line"><span class="comment">//一个类中有一个纯虚函数就称为抽象类</span></span><br><span class="line"><span class="comment">//抽象类不可以初始化</span></span><br><span class="line"><span class="comment">//子类如果不重写纯虚函数的话，不可以进行初始化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;(<span class="string">&quot;hello 多态&quot;</span>)&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">(Base&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p.<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son1 fy;</span><br><span class="line">	<span class="built_in">test1</span>(fy);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h3><p>1.虚析构和纯虚析构是用来解决父类指针释放子类对象<br>2.如果子类没有堆区数据可以不写虚析构或者纯虚析构<br>3.拥有纯虚析构函数的类也是抽象类，不可以进行实例化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;父类的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//虚析构</span></span><br><span class="line">	<span class="comment">//virtual~Base()</span></span><br><span class="line">	<span class="comment">//&#123;	cout &lt;&lt; &quot;父类的虚析构函数调用&quot; &lt;&lt; endl;&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//不管哪种析构方式都必须有代码的实现方式</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//纯虚析构</span></span><br><span class="line">	<span class="keyword">virtual</span>~<span class="built_in">Base</span>() = <span class="number">0</span>;<span class="comment">//这只是一个声明，还必须得写具体的实现方式</span></span><br><span class="line">&#125;;</span><br><span class="line">Base::~<span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;父类的纯虚析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son1</span>(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;子类中的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	string *name;</span><br><span class="line">	~<span class="built_in">Son1</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (name != <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;子类中的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">delete</span> name;</span><br><span class="line">			<span class="keyword">this</span>-&gt;name = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base* p = <span class="keyword">new</span> <span class="built_in">Son1</span>(<span class="string">&quot;fy&quot;</span>);<span class="comment">//new 这步骤是先调用父类的构造函数，再调用子类的构造函数</span></span><br><span class="line">	<span class="comment">//父类的指针，首先父类没有子类中的string *name，当delete父类的指针的时候</span></span><br><span class="line">	<span class="comment">//只会执行父类的析构函数，要想执行子类的虚构函数，那么必须将父类的虚构函数声明为</span></span><br><span class="line">	<span class="comment">//虚析构或纯虚析构，该变vfptr的指向的内容，子类的析构相当于重写了父类的析构函数。</span></span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">test1</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>程序运行时产生的数据都属于临时数据,程序一旦运行结束都会被释放</p>
<p>通过文件可以将数据持久化</p>
<p>C++中对文件操作需要包含头文件<code>&lt;fstream&gt;</code></p>
<p><strong>文件类型分为两种:</strong></p>
<p>1.文本文件 -文件以文本的ASCII码形式存储在计算机中<br>2.王进制文件-文件以文本的二进制形式存储在计算机中,用户一般不能直接读懂它们</p>
<p><strong>操作文件的三大类:</strong></p>
<ol>
<li><p>ofstream:写操作</p>
</li>
<li><p>ifstream:读操作</p>
</li>
<li><p>fstream:读写操作</p>
</li>
</ol>
<h2 id="文本文件"><a href="#文本文件" class="headerlink" title="文本文件"></a>文本文件</h2><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><p>步骤如下：</p>
<ul>
<li>1.包含头文件<code>&lt;fstream&gt;</code></li>
<li>2.创建流对象<br>  ofstream ofs;</li>
<li>3.打开文件<br>  ofs.open(“文件路径”,打开方式);</li>
<li>4.写数据<br>  ofs&lt;&lt;”写入的数据”;</li>
<li>5.关闭文件<br>  ofs.close();<br><img src="/github.fy/assets/1111.png"></li>
</ul>
<h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><p>步骤如下：</p>
<ul>
<li>1.包含头文件<code>&lt;fstream&gt;</code></li>
<li>2.创建流对象<br>  ifstream ifs;</li>
<li>3.打开文件<br>  ifs.open(“文件路径”,打开方式);</li>
<li>4.读数据<br>  四种方式读取</li>
<li>5.关闭文件<br>  ifs.close();<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> a[<span class="number">5</span>] = &#123; <span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//直接打印字符数组a,cout会将其进行转换，从指针开始输出字符串直到遇到&#x27;\0&#x27;为止</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">//1.创建流对象</span></span><br><span class="line">	ifstream ifo;</span><br><span class="line">	<span class="comment">//2.打开文件  并且判断打开是否成功</span></span><br><span class="line">	ifo.<span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>, ios::in);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ifo.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;打开文件失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;打开文件成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//3.进行读的操作</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//第一种</span></span><br><span class="line">		<span class="comment">//char a[1024] = &#123; 0 &#125;;</span></span><br><span class="line">		<span class="comment">//while (ifo &gt;&gt; a)</span></span><br><span class="line">		<span class="comment">//&#123;</span></span><br><span class="line">		<span class="comment">//	cout &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line">		<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//第二种</span></span><br><span class="line">		<span class="comment">//char b[1024] = &#123; 0 &#125;;</span></span><br><span class="line">		<span class="comment">//while(ifo.getline(b,1024))</span></span><br><span class="line">		<span class="comment">//&#123;</span></span><br><span class="line">		<span class="comment">//	cout &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line">		<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//第三种</span></span><br><span class="line">		<span class="comment">//string buf;</span></span><br><span class="line">		<span class="comment">//while (getline(ifo, buf))</span></span><br><span class="line">		<span class="comment">//&#123;</span></span><br><span class="line">		<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">		<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//第四种</span></span><br><span class="line">		<span class="type">char</span> c;</span><br><span class="line">		<span class="keyword">while</span> ((c = ifo.<span class="built_in">get</span>()) != EOF)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; c;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//4.关闭文件</span></span><br><span class="line">		ifo.<span class="built_in">close</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h2><h3 id="写文件-1"><a href="#写文件-1" class="headerlink" title="写文件"></a>写文件</h3><p>打开文件的方式：ofs.open(“文件地址”,ios::out | ios::binary);</p>
<p>二进制方式写文件主要利用流对象调用成员函数write<br>函数原型:ostream&amp; write(const char * buffer, int len);<br>*<em>不是char <em>类型的要强制转换</em></em><br>参数解释:字符指针buffer指向内存中一段存储空间。len是读写的字节数</p>
<h3 id="读文件-1"><a href="#读文件-1" class="headerlink" title="读文件"></a>读文件</h3><p>打开文件的方式：ifs.open(“文件地址”,ios::in | ios::binary);</p>
<p>二进制方式读文件主要利用流对象调用成员函数read<br>函数原型:istream&amp; read(char *buffer, int len);<br>*<em>不是char <em>类型的要强制转换</em></em><br>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p>
<h1 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h1><h2 id="函数模版"><a href="#函数模版" class="headerlink" title="函数模版"></a>函数模版</h2><ul>
<li>c++另一种编程思想称为泛型编程，主要利用的技术就是模版。</li>
<li>c++提供了两种模版机制：函数模版和类模版。</li>
</ul>
<h4 id="函数模版语法"><a href="#函数模版语法" class="headerlink" title="函数模版语法"></a>函数模版语法</h4><p>函数模板作用：<br>    建立一个通用函数，其函数返回类型和形参类型都可以不具体制定，用一个虚拟的类型来代表。<br>语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">函数声明或定义</span><br><span class="line"><span class="keyword">template</span> --- 声明创建模版</span><br><span class="line"><span class="keyword">typename</span> --- 表明后面的符号是一种数据类型，可以用<span class="keyword">class</span>代替</span><br><span class="line">T --- 通用的数据类型，名称可以替换，通常为大写字母。</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T temp = a;<span class="comment">//a,b,temp都是T类型。</span></span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line">	<span class="comment">//1.自动类型推导</span></span><br><span class="line">	<span class="built_in">Swap</span>(a, b);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.显示指定类型，指定T的类型</span></span><br><span class="line">	<span class="built_in">Swap</span>&lt;<span class="type">int</span>&gt;(a,b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="函数模版注意事项"><a href="#函数模版注意事项" class="headerlink" title="函数模版注意事项"></a>函数模版注意事项</h3><ul>
<li>函数模版声明的函数对象必须明确T的类型才可以使用</li>
<li>可以用显示指定类型的方式，才可以使用该模版<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;函数模版的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//显示指定类型，指定T的类型,才可以调用模版函数</span></span><br><span class="line">	<span class="built_in">Swap</span>&lt;<span class="type">double</span>&gt;();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="函数模版案例-选择排序"><a href="#函数模版案例-选择排序" class="headerlink" title="函数模版案例-选择排序"></a>函数模版案例-选择排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">choose_sort</span><span class="params">(T a[],<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len<span class="number">-1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		max = a[i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (max &lt; a[j])</span><br><span class="line">			&#123;</span><br><span class="line">				max = a[j];</span><br><span class="line">				a[j] = a[i];</span><br><span class="line">				a[i] = max;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line">	<span class="built_in">choose_sort</span>(a, <span class="number">6</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;(<span class="built_in">sizeof</span>(a)/<span class="built_in">sizeof</span>(<span class="type">int</span>)); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> b[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>&#125;;</span><br><span class="line">	<span class="built_in">choose_sort</span>(b, <span class="number">5</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="built_in">sizeof</span>(b) / <span class="built_in">sizeof</span>(<span class="type">char</span>)); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; b[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//显示指定类型，指定T的类型,才可以调用模版函数</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="普通函数与函数模版的区别"><a href="#普通函数与函数模版的区别" class="headerlink" title="普通函数与函数模版的区别"></a>普通函数与函数模版的区别</h3><p>普通函数与模版函数的区别：</p>
<ul>
<li>普通函数调用的时候可以发生自动类型转化（隐式类型转化）</li>
<li>函数模版调用时，如果利用自动类型推导，不会发生隐式类型转换</li>
<li>如果利用显示制定类型的方式，会发生隐式类型转换<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">myAdd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//模版函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">myTemplateAdd</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">myAdd</span>(<span class="number">1</span>, <span class="string">&#x27;c&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">myTemplateAdd</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>, <span class="string">&#x27;c&#x27;</span>) &lt;&lt; endl;<span class="comment">//必须用显示指向类型，才会发生隐式类型转换</span></span><br><span class="line">	<span class="comment">//如果去掉&lt;int&gt;直接报错</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="普通函数与模版函数的调用规则"><a href="#普通函数与模版函数的调用规则" class="headerlink" title="普通函数与模版函数的调用规则"></a>普通函数与模版函数的调用规则</h3><p>调用规则如下:<br>1.如果函数模板和普通函数都可以实现,优先调用普通函数<br>2.可以通过空模板参数列表来强制调用函数模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout&lt;&lt;name&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(T name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout&lt;&lt;name&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">output&lt;&gt;(<span class="string">&quot;123&quot;</span>);<span class="comment">//利用空模版参数列表强制调用</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>函数模板也可以发生重载<br>4.如果函数模板可以产生更好的匹配,优先调用函数模板</li>
</ol>
<h2 id="类模版"><a href="#类模版" class="headerlink" title="类模版"></a>类模版</h2><h3 id="类模板基本语法"><a href="#类模板基本语法" class="headerlink" title="类模板基本语法"></a>类模板基本语法</h3><p>类模板作用:<br>·建立一个通用类,类中的成员数据类型可以不具体制定,用一个虚拟的类型来代表。</p>
<p>语法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">类</span><br></pre></td></tr></table></figure>
<p>解释:<br>template — 声明创建模板<br>typename — 表面其后面的符号是一种数据类型,可以用class代替<br>T — 通用的数据类型,名称可以替换,通常为大写字母</p>
<h3 id="类模版与函数模版的区别"><a href="#类模版与函数模版的区别" class="headerlink" title="类模版与函数模版的区别"></a>类模版与函数模版的区别</h3><p>主要有两点：</p>
<ul>
<li>类模版没有自动类型推导的使用方式，创建类的时候必须显示指明参数类型用&lt;&gt;，这个符号必须得有<br>  哪怕参数列表已经默认参数类型也要把空的&lt;&gt;写上</li>
<li>类模版在模版参数列表中可以有默认参数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Name</span>=string,<span class="keyword">class</span> Age=<span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Myclass</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Myclass</span>(Name name, Age age)</span><br><span class="line">	&#123;</span><br><span class="line">		m_Name = name;</span><br><span class="line">		m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show_Info</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot;年龄：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Myclass&lt;&gt;<span class="built_in">fy</span>(<span class="string">&quot;冯岩&quot;</span>, <span class="number">20</span>);</span><br><span class="line">	<span class="comment">//即使参数列表已经给了默认值，初始化的时候还是必须得写上空的参数列表</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="类模版中成员函数的创建时机"><a href="#类模版中成员函数的创建时机" class="headerlink" title="类模版中成员函数的创建时机"></a>类模版中成员函数的创建时机</h3><p>类模版中的成员函数和普通类中的成员函数的创建时机是有区别的：</p>
<ul>
<li>累模版中的成员函数只有被调用的时候才创建</li>
<li>普通类的成员函数一开始就可以创建<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print_info</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;这是Person1&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print_info</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;这是Person2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T obj;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print_info</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		obj.<span class="built_in">print_info</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Myclass&lt;Person1&gt;fy;</span><br><span class="line">	fy.<span class="built_in">print_info</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="类模版对象做函数参数"><a href="#类模版对象做函数参数" class="headerlink" title="类模版对象做函数参数"></a>类模版对象做函数参数</h3><p>一共有三种传入方式：</p>
<ul>
<li>1.指定传入类型 — 直接显示对象的数据类型</li>
<li>2.参数模板化 — 将对象中的参数变为模版进行传递</li>
<li>3.整个类模板化 — 将对象模板化传递<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Name</span>, <span class="keyword">class</span> <span class="title class_">Age</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Myclass</span>(Name name,Age age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_age = age;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	Name m_name;</span><br><span class="line">	Age m_age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类模版当函数参数的时候的三种传递方式</span></span><br><span class="line"><span class="comment">//1.指定传入类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">(Myclass&lt;string,<span class="type">int</span>&gt;&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; p.m_name &lt;&lt; <span class="string">&quot;年龄：&quot;</span> &lt;&lt; p.m_age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.参数模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1,<span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">(Myclass&lt;T1, T2&gt;&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; p.m_name &lt;&lt; <span class="string">&quot;年龄：&quot;</span> &lt;&lt; p.m_age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.整个类模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">(T &amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; p.m_name &lt;&lt; <span class="string">&quot;年龄：&quot;</span> &lt;&lt; p.m_age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Myclass&lt;string,<span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;fy&quot;</span>, <span class="number">20</span>);</span><br><span class="line">	<span class="built_in">test3</span>(p);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="类模版与继承"><a href="#类模版与继承" class="headerlink" title="类模版与继承"></a>类模版与继承</h3><p>当类模版碰到继承时，要注意以下几点：</p>
<ul>
<li>子类继承的父类是一个类模版时，子类在声明的时候要指定出父类中的T类型</li>
<li>如果不指定，编译器无法给子类分配内存</li>
<li>如果想灵活指定出父类中的T类型，子类也许变成类模版<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	</span><br><span class="line">	T obj;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//如果父类是模版类，子类在继承的时候必须明确出参数列表的类型，这样不够灵活</span></span><br><span class="line"><span class="comment">//class Son :public Myclass&lt;int&gt;</span></span><br><span class="line"><span class="comment">//&#123;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将子类也设置为模版类，使得参数的传递更加灵活</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Myclass&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>(T name)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son&lt;string&gt;<span class="built_in">fy</span>(<span class="string">&quot;冯岩&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="类模版成员函数的类外实现"><a href="#类模版成员函数的类外实现" class="headerlink" title="类模版成员函数的类外实现"></a>类模版成员函数的类外实现</h3><p>需要加上模版参数列表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	</span><br><span class="line">	T obj;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//如果父类是模版类，子类在继承的时候必须明确出参数列表的类型，这样不够灵活</span></span><br><span class="line"><span class="comment">//class Son :public Myclass&lt;int&gt;</span></span><br><span class="line"><span class="comment">//&#123;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将子类也设置为模版类，使得参数的传递更加灵活</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Myclass&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>(T name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Son&lt;T&gt;::<span class="built_in">Son</span>(T name)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son&lt;string&gt;<span class="built_in">fy</span>(<span class="string">&quot;冯岩&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="类模版分文件编写"><a href="#类模版分文件编写" class="headerlink" title="类模版分文件编写"></a>类模版分文件编写</h3><p>学习目标:<br>· 掌握类模板成员函数分文件编写产生的问题以及解决方式<br>问题:<br>· 类模板中成员函数创建时机是在调用阶段,导致分文件编写时链接不到<br>解决:<br>● 解决方式1:直接包含.cpp源文件<br>● 解决方式2:将声明和实现写到同一个文件中,并更改后缀名为.hpp,hpp是约定的名称,并不是强制</p>
<h1 id="STL初识"><a href="#STL初识" class="headerlink" title="STL初识"></a>STL初识</h1><h2 id="STL的诞生"><a href="#STL的诞生" class="headerlink" title="STL的诞生"></a>STL的诞生</h2><p>· 长久以来,软件界一直希望建立一种可重复利用的东西</p>
<p>· C++的面向对象和泛型编程思想,目的就是复用性的提升</p>
<p>· 大多情况下,数据结构和算法都未能有一套标准,导致被迫从事大量重复工作<br>· 为了建立数据结构和算法的一套标准,诞生了STL</p>
<h2 id="STL基本概念"><a href="#STL基本概念" class="headerlink" title="STL基本概念"></a>STL基本概念</h2><p>· STL(Standard Template Library,标准模板库)<br>· STL从广义上分为:容器(container)算法(algorithm)迭代器(iterator)<br>· 容器和算法之间通过迭代器进行无缝连接。<br>· STL几乎所有的代码都采用了模板类或者模板函数</p>
<h2 id="STL六大组件"><a href="#STL六大组件" class="headerlink" title="STL六大组件"></a>STL六大组件</h2><p>STL大体分为六大组件,分别是:容器，算法，迭代器，方函数、违配器，(配接器)，空间配置器</p>
<p>1.容器:各种数据结构,如vector、list、deque、set、map等,用来存放数据。</p>
<p>2.算法:各种常用的算法,如sort、find、copy、for_each等</p>
<p>3.迭代器:扮演了容器与算法之间的胶合剂。</p>
<p>4.仿函数:行为类似函数,可作为算法的某种策略。</p>
<p>5.适配器:一种用来修饰容器或者仿函数或迭代器接口的东西。</p>
<p>6.空间配置器:负责空间的配置与管理。</p>
<h2 id="STL中容器，算法，迭代器"><a href="#STL中容器，算法，迭代器" class="headerlink" title="STL中容器，算法，迭代器"></a>STL中容器，算法，迭代器</h2><p><code>容器:置物之所也</code><br>STL容器就是将运用最广泛的一些数据结构实现出来</p>
<p>常用的数据结构:数组,链表,树,栈,队列,集合,映射表等</p>
<p>这些容器分为序列式容器和关联式容器两种:<br>序列式容器:强调值的排序,序列式容器中的每个元素均有固定的位置。<br>关联式容器:二叉树结构,各元素之间没有严格的物理上的顺序关系</p>
<p><code>算法:问题之解法也</code><br>有限的步骤,解决逻辑或数学上的问题,这一门学科我们叫做算法(Algorithms)</p>
<p>算法分为:质变算法和非质变算法。</p>
<p>质变算法:是指运算过程中会更改区间内的元素的内容。例如拷贝,替换,删除等等</p>
<p>非质变算法:是指运算过程中不会更改区间内的元素内容,例如查找、计数、遍历、寻找极值等等</p>
<p><code>迭代器:容器和算法之间粘合剂</code></p>
<p>提供一种方法,使之能够依序寻访某个容器所含的各个元素,而又无需暴露该容器的内部表示方式。</p>
<p>每个容器都有自己专属的迭代器</p>
<p>迭代器使用非常类似指针，刚开始我们可以把它当作指针</p>
<p><code>迭代器种类：</code><br>|种类|功能|支持运算|<br>|输入迭代器|对数据的只读访问|只读,支持++、 &#x3D;&#x3D; 、 !&#x3D;|<br>|输出迭代器|对数据的只写访问|只写,支持++|<br>|前向迭代器|读写操作,并能向前推进迭代器|读写,支持++、 &#x3D;&#x3D; 、 !&#x3D;|<br>|双向迭代器|读写操作,并能向前和向后操作|读写,支持++、 – ,|<br>|随机访问迭代器|读写操作,可以以跳跃的方式访问任意数据,功能最强的迭代器|读写,支持++、 – 、[n]、-n、&lt;、&lt;&#x3D; 、&gt;、&gt;&#x3D;|</p>
<h3 id="vector存放内置数据类型"><a href="#vector存放内置数据类型" class="headerlink" title="vector存放内置数据类型"></a>vector存放内置数据类型</h3><p>向vector中插入数据，并遍历</p>
<p>容器：vector<br>算法：for_each<br>迭代器：vector<int>::iterator</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_vector</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建容器对象</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">	<span class="comment">//给容器中添加元素</span></span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//每一个容器都有是属于它自己的迭代器，迭代器是用来遍历容器中的元素</span></span><br><span class="line">	<span class="comment">//v.begin()返回迭代器，这个迭代器指向容器第一个数据</span></span><br><span class="line">	<span class="comment">//v.end()  返回迭代器，这个迭代器指向容器最后一个数据的后一个位置</span></span><br><span class="line">	<span class="comment">//vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种类型的迭代器</span></span><br><span class="line">	 </span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator begin_Iterator= v.<span class="built_in">begin</span>();</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator end_Iterator = v.<span class="built_in">end</span>();<span class="comment">//目前阶段把创建的迭代器当作指针处理</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一种遍历方式</span></span><br><span class="line">	<span class="comment">//其实一个迭代器就够了</span></span><br><span class="line">	<span class="keyword">for</span> (; begin_Iterator &lt; end_Iterator; begin_Iterator++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *begin_Iterator &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//第二种遍历方式</span></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),print_vector);<span class="comment">//for_each()函数会将每次遍历的迭代器传入给函数的参数</span></span><br><span class="line">	<span class="comment">//回调的方式</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="存放自定义数据类型"><a href="#存放自定义数据类型" class="headerlink" title="存放自定义数据类型"></a>存放自定义数据类型</h3><p>vector中存放自定义数据类型，并打印输出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Myclass</span>(<span class="type">int</span> age,string name)</span><br><span class="line">	&#123;</span><br><span class="line">		m_age = age;</span><br><span class="line">		m_name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> m_age;</span><br><span class="line">	string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建容器对象</span></span><br><span class="line">	vector&lt;Myclass*&gt;v;<span class="comment">//变量类型为Myclass类型的指针</span></span><br><span class="line">	<span class="comment">//给容器中添加元素</span></span><br><span class="line">	<span class="function">Myclass <span class="title">class1</span><span class="params">(<span class="number">12</span>, <span class="string">&quot;第一个&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function">Myclass <span class="title">class2</span><span class="params">(<span class="number">13</span>, <span class="string">&quot;第二个&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function">Myclass <span class="title">class3</span><span class="params">(<span class="number">14</span>, <span class="string">&quot;第三个&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function">Myclass <span class="title">class4</span><span class="params">(<span class="number">17</span>, <span class="string">&quot;第四个&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;class1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;class2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;class3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;class4);</span><br><span class="line">	<span class="comment">//此时的迭代器，可以理解为指向Myclass*的指针，二级指针</span></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Myclass*&gt;::iterator begin_itor = v.<span class="built_in">begin</span>(); begin_itor != v.<span class="built_in">end</span>(); begin_itor++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;打印类的名字：&quot;</span> &lt;&lt; (*begin_itor)-&gt;m_name &lt;&lt; <span class="string">&quot;年龄：&quot;</span> &lt;&lt; (*begin_itor)-&gt;m_age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="string基本概念"><a href="#string基本概念" class="headerlink" title="string基本概念"></a>string基本概念</h2><p>本质:</p>
<ul>
<li>string是C++风格的字符串,而string本质上是一个类</li>
</ul>
<p>string和char*区别:</p>
<ul>
<li><p>char*是一个指针</p>
</li>
<li><p>string是一个类,类内部封装了char*,管理这个字符串,是一个char*型的容器。</p>
</li>
</ul>
<p>特点:</p>
<p>string类内部封装了很多成员方法</p>
<p>例如:查找find,拷贝copy,删除delete 替换replace,插入insert</p>
<p>string管理char*所分配的内存,不用担心复制越界和取值越界等,由类内部进行负责</p>
<h3 id="string构造函数"><a href="#string构造函数" class="headerlink" title="string构造函数"></a>string构造函数</h3><p>构造函数原型:</p>
<p>string();&#x2F;&#x2F;创建一个空的字符串 例如:string str;<br>string(const char* s);&#x2F;&#x2F;使用字符串s初始化</p>
<p>string(const string&amp; str);&#x2F;&#x2F;使用一个string对象初始化另一个string对象</p>
<p>string(int n, char c);&#x2F;&#x2F;使用n个字符c初始化</p>
<h3 id="string赋值操作"><a href="#string赋值操作" class="headerlink" title="string赋值操作"></a>string赋值操作</h3><p>功能描述:</p>
<p>● 给string字符串进行赋值</p>
<p>赋值的函数原型:</p>
<p>string&amp; operator&#x3D;(const char* s);&#x2F;&#x2F;char*类型字符串 赋值给当前的字符串</p>
<p>string&amp; operator&#x3D;(const string &amp;s);&#x2F;&#x2F;把字符串s赋给当前的字符串</p>
<p>string&amp; operator&#x3D;(char c);&#x2F;&#x2F;字符赋值给当前的字符串</p>
<p>string&amp; assign(const char *s);&#x2F;&#x2F;把字符串s赋给当前的字符串</p>
<p>string&amp; assign(const char *s, int n);&#x2F;&#x2F;把字符串s的前n个字符赋给当前的字符串</p>
<p>string&amp; assign(const string &amp;s);&#x2F;&#x2F;把字符串s赋给当前字符串</p>
<p>string&amp; assign(int n, char c);&#x2F;&#x2F;用n个字符c赋给当前字符串</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str1;</span><br><span class="line">	<span class="comment">//string&amp; operator=(const char* s)</span></span><br><span class="line">	str1 = <span class="string">&quot;字符串1&quot;</span>;</span><br><span class="line">	<span class="comment">//string&amp; operator=(const string&amp; s)</span></span><br><span class="line">	string str2 = str1;</span><br><span class="line"></span><br><span class="line">	string str3,str4,str5,str6;</span><br><span class="line">	<span class="comment">//string&amp; assign(const char*s)</span></span><br><span class="line">	str3.<span class="built_in">assign</span>(<span class="string">&quot;字符串3&quot;</span>);</span><br><span class="line">	<span class="comment">//string&amp; assign(const string&amp;s)</span></span><br><span class="line">	str4.<span class="built_in">assign</span>(str3);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//把字符串前n个赋值给当前的字符串</span></span><br><span class="line">	<span class="comment">//string&amp; assign(const char*s,int n);</span></span><br><span class="line">	str5.<span class="built_in">assign</span>(<span class="string">&quot;1234&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//用n个字符初始化字符串</span></span><br><span class="line">	<span class="comment">//string&amp; assign(int n,char s);</span></span><br><span class="line">	str6.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1：&quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str2：&quot;</span> &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str3：&quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str4：&quot;</span> &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str5：&quot;</span> &lt;&lt; str5 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str6：&quot;</span> &lt;&lt; str6 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="string字符串拼接"><a href="#string字符串拼接" class="headerlink" title="string字符串拼接"></a>string字符串拼接</h3><p>功能描述:</p>
<p>● 实现在字符串末尾拼接字符串</p>
<p>函数原型:</p>
<p>string&amp; operator+&#x3D;(const char* str);&#x2F;&#x2F;重载+&#x3D;操作符</p>
<p>string&amp; operator+&#x3D;(const char c);&#x2F;&#x2F;重载+&#x3D;操作符</p>
<p>string&amp; operator+&#x3D;(const string&amp; str);&#x2F;&#x2F;重载+&#x3D;操作符</p>
<p>string&amp; append(const char *s);&#x2F;&#x2F;把字符串s连接到当前字符串结尾</p>
<p>string&amp; append(const char *s, int n);&#x2F;&#x2F;把字符串s的前n个字符连接到当前字符串结尾</p>
<p>string&amp; append(const string &amp;s);&#x2F;&#x2F;同operator+&#x3D;(const string&amp; str)</p>
<p>string&amp; append(const string &amp;s, int pos, int n);&#x2F;&#x2F;字符串s中从pos开始的n个字符连接到字符串结尾</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str1;</span><br><span class="line">	<span class="comment">//重载运算符+=拼接字符串</span></span><br><span class="line">	str1 = <span class="string">&quot;字符串1&quot;</span>;</span><br><span class="line">	str1 += <span class="string">&quot;字符串2&quot;</span>;</span><br><span class="line">	cout &lt;&lt; str1 + <span class="string">&quot;拼接字符串&quot;</span> &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//利用append()方法</span></span><br><span class="line">	str1.<span class="built_in">append</span>(<span class="string">&quot;字符串3&quot;</span>);</span><br><span class="line"></span><br><span class="line">	str1.<span class="built_in">append</span>(<span class="string">&quot;abcde&quot;</span>, <span class="number">1</span>, <span class="number">4</span>);<span class="comment">//表示从索引1开始的4个拼接到str1</span></span><br><span class="line">	cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="string的查找和替换"><a href="#string的查找和替换" class="headerlink" title="string的查找和替换"></a>string的查找和替换</h3><p>功能描述:</p>
<p>● 查找:查找指定字符串是否存在</p>
<p>● 替换:在指定的位置替换字符串</p>
<p>函数原型:</p>
<p>int find(const string&amp; str, int pos &#x3D; 0) const;&#x2F;&#x2F;查找str第一次出现位置,从pos开始查找</p>
<p>int find(const char* s, int pos &#x3D; 0) const;&#x2F;&#x2F;查找s第一次出现位置,从pos开始查找</p>
<p>int find(const char* s, int pos, int n) const;&#x2F;&#x2F;从pos位置查找s的前n个字符第一次位置</p>
<p>int find(const char c, int pos &#x3D; 0) const;&#x2F;&#x2F;查找字符c第一次出现位置</p>
<p>int rfind(const string&amp; str, int pos &#x3D; npos) const;&#x2F;&#x2F;查找str最后一次位置,从pos开始查找</p>
<p>int rfind(const char* s, int pos &#x3D; npos) const;&#x2F;&#x2F;查找s最后一次出现位置,从pos开始查找</p>
<p>int rfind(const char* s, int pos, int n) const;&#x2F;&#x2F;从pos查找s的前n个字符最后一次位置</p>
<p>int rfind(const char c, int pos &#x3D; 0) const;&#x2F;&#x2F;查找字符c最后一次出现位置</p>
<p>string&amp; replace(int pos, int n, const string&amp; str);&#x2F;&#x2F;替换从pos开始n个字符为字符串str</p>
<p>string&amp; replace(int pos, int n,const char* s);&#x2F;&#x2F;替换从pos开始的n个字符为字符串s</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str1;</span><br><span class="line">	</span><br><span class="line">	str1 = <span class="string">&quot;字符串1&quot;</span>;</span><br><span class="line">	string str2 = <span class="string">&quot;abcdefde&quot;</span>;\</span><br><span class="line">	<span class="comment">//find</span></span><br><span class="line">	cout&lt;&lt;str1.<span class="built_in">find</span>(<span class="string">&quot;符&quot;</span>)&lt;&lt;endl;</span><br><span class="line">	cout &lt;&lt; str2.<span class="built_in">find</span>(<span class="string">&quot;d&quot;</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//rfind从右往左找</span></span><br><span class="line">	cout &lt;&lt; str2.<span class="built_in">rfind</span>(<span class="string">&quot;de&quot;</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//replace</span></span><br><span class="line">	cout &lt;&lt; str2.<span class="built_in">replace</span>(<span class="number">1</span>, <span class="number">4</span>, str1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>find查找是从左往后，rfind是从右往左</li>
<li>find找到字符串后返回查找的第一个字符位置，找不到返回-1</li>
<li>replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li>
</ul>
<h3 id="string字符串比较"><a href="#string字符串比较" class="headerlink" title="string字符串比较"></a>string字符串比较</h3><p>功能描述:</p>
<p>● 字符串之间的比较</p>
<p>比较方式:</p>
<p>● 字符串比较是按字符的ASCII码进行对比<br><code>=返回</code></p>
<p><code>&gt;返回 1</code></p>
<p><code>&lt;返回-1</code></p>
<p>函数原型:</p>
<p>int compare(const string &amp;s) const;&#x2F;&#x2F;与字符串s比较</p>
<p>int compare(const char *s) const;&#x2F;&#x2F;与字符串s比较</p>
<h3 id="string字符存取"><a href="#string字符存取" class="headerlink" title="string字符存取"></a>string字符存取</h3><p>I</p>
<p>string中单个字符存取方式有两种</p>
<p>.char&amp; operator[](int n);&#x2F;&#x2F;通过[]方式取字符</p>
<p>.char&amp; at(int n);&#x2F;&#x2F;通过at方法获取字符</p>
<h3 id="string插入和删除"><a href="#string插入和删除" class="headerlink" title="string插入和删除"></a>string插入和删除</h3><p>功能描述:</p>
<p>● 对string字符串进行插入和删除字符操作</p>
<p>函数原型:</p>
<p>string&amp; insert(int pos, const char* s);&#x2F;&#x2F;插入字符串</p>
<p>string&amp; insert(int pos, const string&amp; str);&#x2F;&#x2F;插入字符串</p>
<p>string&amp; insert(int pos, int n, char c);&#x2F;&#x2F;在指定位置插入n个字符c</p>
<p>string&amp; erase(int pos, int n &#x3D; npos);&#x2F;&#x2F;删除从Pos开始的n个字符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str1;</span><br><span class="line">	str1.<span class="built_in">insert</span>(<span class="number">0</span>, <span class="string">&quot;123&quot;</span>);<span class="comment">//在0的位置插入123</span></span><br><span class="line">	cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	str1.<span class="built_in">insert</span>(<span class="number">3</span>, <span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>);<span class="comment">//在4的位置插入3个&#x27;a&#x27;</span></span><br><span class="line">	cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	str1.<span class="built_in">erase</span>(<span class="number">0</span>, <span class="number">3</span>);<span class="comment">//将索引从0到3的元素删掉</span></span><br><span class="line">	cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="string子串"><a href="#string子串" class="headerlink" title="string子串"></a>string子串</h3><p>功能描述：</p>
<ul>
<li>从字符串中获取想要的子串</li>
</ul>
<p>函数原型：</p>
<ul>
<li>string substr(int pos&#x3D;0;int n&#x3D;npos)const;&#x2F;&#x2F;返回由pos开始的n个字符组成的字符串</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str1=<span class="string">&quot;37702034@qq.com&quot;</span>;</span><br><span class="line">	string str2 = str1.<span class="built_in">substr</span>(<span class="number">0</span>, str1.<span class="built_in">find</span>(<span class="string">&quot;@&quot;</span>));</span><br><span class="line">	cout &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h2><h3 id="vector基本概念"><a href="#vector基本概念" class="headerlink" title="vector基本概念"></a>vector基本概念</h3><p>功能:</p>
<ul>
<li>vector数据结构和数组非常相似,也称为单端数组</li>
</ul>
<p>vector与普通数组区别:</p>
<ul>
<li>不同之处在于数组是静态空间,而vector可以动态扩展</li>
</ul>
<p>动态扩展:</p>
<ul>
<li>并不是在原空间之后续接新空间,而是找更大的内存空间,然后将原数据拷贝新空间,释放原空间<br><img src="/github.fy/assets/2222.png"></li>
<li>vector容器的迭代器时支持随机访问的迭代器<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//vector容器的构造函数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.默认构造</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//通过迭代器访问</span></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator ite = v.<span class="built_in">begin</span>(); ite != v.<span class="built_in">end</span>(); ite++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *ite &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//2.通过区间的方式进行构造</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;<span class="built_in">v2</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());<span class="comment">//左边是闭区间，右边是开区间，获取他们之间区域的值进行拷贝</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.拷贝构造的方式</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;<span class="built_in">v3</span>(v2);<span class="comment">//拷贝</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="vector赋值操作"><a href="#vector赋值操作" class="headerlink" title="vector赋值操作"></a>vector赋值操作</h3><p>功能描述:</p>
<p>● 给vector容器进行赋值</p>
<p>函数原型:</p>
<p>vector&amp; operator&#x3D;(donst vector &amp;vec);&#x2F;&#x2F;重载等号操作符<br>assign(beg, end);&#x2F;&#x2F;<code>将[beg,end)区间中的数据拷贝赋值给本身。</code><br>assign(n, elem);&#x2F;&#x2F;将n个elem拷贝赋值给本身。</p>
<h2 id="queue容器"><a href="#queue容器" class="headerlink" title="queue容器"></a>queue容器</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Queue是一种先进先出的数据结构，有两个出口</p>
<h2 id="map-multimap容器"><a href="#map-multimap容器" class="headerlink" title="map&#x2F;multimap容器"></a>map&#x2F;multimap容器</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>map中的元素是成对出现的pair</li>
<li>pair的第一个元素为key键值，第二个为value实值</li>
<li>所有元素根据键值自动排列<br>本质：属于关联容器，底层结构使用二叉树实现<br>优点：</li>
<li>可以根据key值快速找到value值<br>map和multimap的区别：</li>
<li>map中不允许有重复的key元素</li>
<li>multimap允许</li>
</ul>
<h3 id="map构造和赋值"><a href="#map构造和赋值" class="headerlink" title="map构造和赋值"></a>map构造和赋值</h3><p>对map容器进行构造和赋值的操作<br>函数原型：</p>
<ul>
<li>map&lt;t1,t2&gt;mp;	&#x2F;&#x2F;map默认构造函数</li>
<li>map(const map&amp;mp);	&#x2F;&#x2F;map的拷贝构造函数<br>赋值：</li>
<li>map&amp; operator&#x3D;(const map&amp;mp);	&#x2F;&#x2F;重载赋值<br>插入数值：</li>
<li>map&lt;int,int&gt;mp;mp.insert(pair&lt;int,int&gt;(1,1));将元素（1,1）插入</li>
</ul>
<h3 id="map大小和交换"><a href="#map大小和交换" class="headerlink" title="map大小和交换"></a>map大小和交换</h3><p>函数原型：</p>
<ul>
<li>size();	&#x2F;&#x2F;返回容器中元素的数目</li>
<li>empty();	&#x2F;&#x2F;判断容器是否为空</li>
<li>swap(st);	&#x2F;&#x2F;交换两个集合容器</li>
</ul>
<h3 id="map插入和删除"><a href="#map插入和删除" class="headerlink" title="map插入和删除"></a>map插入和删除</h3><p>函数原型：</p>
<ul>
<li>insert(elem);	&#x2F;&#x2F;在容器中插入元素<ul>
<li>第一种：mp.insert(pair&lt;int,int&gt;(1,1))</li>
<li>第二种：mp.insert(make_pair(1,1))</li>
<li>第三种：mp.insert(map&lt;int,int&gt;::value_type(1,1))</li>
</ul>
</li>
<li>clear();	&#x2F;&#x2F;清除所有元素</li>
<li>erase(pos);	&#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器</li>
<li>erase(beg,end);	&#x2F;&#x2F;删除区间[beg,end)的所有元素，返回下一个元素的迭代器</li>
<li>erase(key);	&#x2F;&#x2F;删除键值为key的元素</li>
<li>在std::multimap中，find函数用于查找具有特定键的第一个元素。如果multimap中有多个具有相同键的元素，find函数只会返回第一个匹配元素的迭代器。如果你想要找到具有相同键的所有元素，你需要使用equal_range函数。</li>
</ul>
<h3 id="map查找和统计"><a href="#map查找和统计" class="headerlink" title="map查找和统计"></a>map查找和统计</h3><p>函数原型：</p>
<ul>
<li>find(key)	&#x2F;&#x2F;查找key是否存在，如果存在返回该键的元素的迭代器，若不存在则返回set.end();</li>
<li>count(key)	&#x2F;&#x2F;统计key元素的个数</li>
</ul>
<h3 id="map容器的排序"><a href="#map容器的排序" class="headerlink" title="map容器的排序"></a>map容器的排序</h3><p>map容器默认按照从大到小的方式进行排序，掌握如何改变排序顺序</p>
<h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建map容器</span></span><br><span class="line">	map&lt;string, <span class="type">int</span>&gt;mp;</span><br><span class="line">	<span class="comment">//利用pair匿名构造和insert给map中添加元素</span></span><br><span class="line">	mp.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;(<span class="string">&quot;fy&quot;</span>, <span class="number">20</span>));</span><br><span class="line">	mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;hg&quot;</span>, <span class="number">20</span>));</span><br><span class="line">	mp.<span class="built_in">insert</span>(map&lt;string, <span class="type">int</span>&gt;::<span class="built_in">value_type</span>(<span class="string">&quot;yxy&quot;</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (map&lt;string, <span class="type">int</span>&gt;::iterator p = mp.<span class="built_in">begin</span>(); p != mp.<span class="built_in">end</span>(); p++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;key:\t&quot;</span> &lt;&lt; p-&gt;first &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;value:\t&quot;</span> &lt;&lt; p-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;mp.<span class="built_in">find</span>(<span class="string">&quot;fy&quot;</span>)-&gt;second&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; mp.<span class="built_in">erase</span>(<span class="string">&quot;hg&quot;</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (map&lt;string, <span class="type">int</span>&gt;::iterator p = mp.<span class="built_in">begin</span>(); p != mp.<span class="built_in">end</span>(); p++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;key:\t&quot;</span> &lt;&lt; p-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;value:\t&quot;</span> &lt;&lt; p-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; mp[<span class="string">&quot;fy&quot;</span>] &lt;&lt; endl;</span><br><span class="line">	mp[<span class="string">&quot;fy&quot;</span>] = <span class="number">200</span>;</span><br><span class="line">	cout &lt;&lt; mp[<span class="string">&quot;fy&quot;</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="list容器"><a href="#list容器" class="headerlink" title="list容器"></a>list容器</h2><p>功能:将数据进行链式存储</p>
<p>链表(list)是一种物理存储单元上非连续的存储结构,数据元素的逻辑顺序是通过链表中的指针链接实现的</p>
<p>链表的组成:链表由一系列结点组成</p>
<p>结点的组成:一个是存储数据元素的数据域,另一个是存储下一个结点地址的指针域</p>
<p>STL中的链表是一个双向循环链表<br><img src="/github.fy/c++/1.png"></p>
<h3 id="list构造函数"><a href="#list构造函数" class="headerlink" title="list构造函数"></a>list构造函数</h3><p>函数原型:</p>
<ul>
<li>list<T> 1st;&#x2F;&#x2F;list采用采用模板类实现,对象的默认构造形式:</li>
<li>list(beg,end);&#x2F;&#x2F;构造函数将[beg,end)区间中的元素拷贝给本身。</li>
<li>list(elem);&#x2F;&#x2F;构造函数将n个elem拷贝给本身。</li>
<li>list(const list &amp;lst);&#x2F;&#x2F;拷贝构造函数。<br><code>容器一般都会有的构造方式：默认构造、拷贝构造、区间构造、拷贝n个</code></li>
</ul>
<h3 id="list赋值和交换"><a href="#list赋值和交换" class="headerlink" title="list赋值和交换"></a>list赋值和交换</h3><p>功能描述:<br>● 给list容器进行赋值,以及交换list容器</p>
<p>函数原型:</p>
<ul>
<li>assign(beg, end);&#x2F;&#x2F;将[beg,end)区间中的数据拷贝赋值给本身。</li>
<li>assign(n, elem);&#x2F;&#x2F;将n个elem拷贝赋值给本身。</li>
<li>list&amp; operator&#x3D;(const list &amp;lst);&#x2F;&#x2F;重载等号操作符</li>
<li>swap(lst);&#x2F;&#x2F;将Ist与本身的元素互换</li>
</ul>
<h3 id="list大小操作"><a href="#list大小操作" class="headerlink" title="list大小操作"></a>list大小操作</h3><p>函数原型：</p>
<ul>
<li>size();	&#x2F;&#x2F;返回容器中元素的数目</li>
<li>empty();	&#x2F;&#x2F;判断容器是否为空</li>
<li>resize(n); &#x2F;&#x2F;重新指定容器的长度为n，若容器变长，则以默认值填充新位置<br>       &#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除</li>
<li>resize(num,elem);	&#x2F;&#x2F;重新指定容器的长度为n，若容器变长，则以elem填充新位置,如果容器变短，则末尾超出容器长度的元素被删除</li>
</ul>
<h3 id="list插入和删除"><a href="#list插入和删除" class="headerlink" title="list插入和删除"></a>list插入和删除</h3><p>函数原型：</p>
<ul>
<li>push_back(elem);	&#x2F;&#x2F;在容器尾部加入一个元素</li>
<li>pop_back();	&#x2F;&#x2F;删除容器末尾的元素</li>
<li>push_front(elem);	&#x2F;&#x2F;在容器的开头添加一个元素</li>
<li>pop_front();	&#x2F;&#x2F;删除容器开头的元素</li>
<li>insert(pos,elem);	&#x2F;&#x2F;在pos的位置插入元素</li>
<li>insert(pos,n,elem);	&#x2F;&#x2F;在pos的位置插入n个元素</li>
<li>insert(pos,begin,end);	&#x2F;&#x2F;在pos的位置插入begin到end区间的元素</li>
<li>clear();	&#x2F;&#x2F;移除所有元素</li>
<li>erase(beg,end);	&#x2F;&#x2F;删除[beg,end)的数据</li>
<li>erase(pos);	&#x2F;&#x2F;删除位置为pos的数据</li>
<li>remove(elem);	&#x2F;&#x2F;删除容器中所有与elem匹配的元素</li>
</ul>
<h3 id="list数据存取"><a href="#list数据存取" class="headerlink" title="list数据存取"></a>list数据存取</h3><p>函数原型：</p>
<ul>
<li>front();	&#x2F;&#x2F;返回第一个元素</li>
<li>back();	&#x2F;&#x2F;返回最后一个元素</li>
</ul>
<h3 id="list迭代器注意事项"><a href="#list迭代器注意事项" class="headerlink" title="list迭代器注意事项"></a>list迭代器注意事项</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it = l1.<span class="built_in">begin</span>();</span><br><span class="line">it++;	<span class="comment">//支持双向</span></span><br><span class="line">it--;	</span><br><span class="line">it = it+<span class="number">1</span>;	<span class="comment">//不支持随机访问</span></span><br><span class="line">只能通过front和back的方式访问</span><br></pre></td></tr></table></figure>
<h3 id="list反转和排序"><a href="#list反转和排序" class="headerlink" title="list反转和排序"></a>list反转和排序</h3><p>函数原型：</p>
<ul>
<li>reverse();	&#x2F;&#x2F;反转链表</li>
<li>sort();	&#x2F;&#x2F;链表排序（默认升序）<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Rule</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> v1&gt;v2;	<span class="comment">//降序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="c-lambda表达式"><a href="#c-lambda表达式" class="headerlink" title="c++lambda表达式"></a>c++lambda表达式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[capture](paramters)-&gt;return_type&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>capture是捕获列表表示可以从函数外部可以捕获的变量</p>
<ul>
<li>[]表示什么都没捕获</li>
<li>[x]按值捕获外部变量x</li>
<li>[&amp;x]按引用捕获外部变量x</li>
<li>[&amp;]按引用捕获外部所有变量</li>
<li>[&#x3D;]按值捕获外部所有变量</li>
<li>[&#x3D;,&amp;x]外部变量除了x用引用捕获，其余都用值来捕获</li>
<li>[&amp;,x]外部变量除了x用值捕获，其余都用引用来捕获</li>
</ul>
<p>return_type函数会自动推断返回的数据类型</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://fylhg.github.io/github.fy">二马山石</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://fylhg.github.io/github.fy/2024/07/12/C++/">https://fylhg.github.io/github.fy/2024/07/12/C++/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://fylhg.github.io/github.fy" target="_blank">FY的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/github.fy/tags/c/">c++</a></div><div class="post_share"><div class="social-share" data-image="https://img2.baidu.com/it/u=1339810107,1799612389&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=512&amp;h=328" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/github.fy/2024/07/21/QT/" title="Qt"><img class="cover" src="https://t8.baidu.com/it/u=4067589254,2956208776&amp;fm=193" onerror="onerror=null;src='/github.fy/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Qt</div></div></a></div><div class="next-post pull-right"><a href="/github.fy/2024/07/04/esp32%E7%AC%94%E8%AE%B0/" title="esp32"><img class="cover" src="http://micropython.86x.net/en/latet/_images/esp32.jpg" onerror="onerror=null;src='/github.fy/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">esp32</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/github.fy/img/1.jpg" onerror="this.onerror=null;this.src='/github.fy/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">二马山石</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/github.fy/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/github.fy/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/github.fy/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">C++ 异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">1.1.</span> <span class="toc-text">抛出异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="toc-number">1.2.</span> <span class="toc-text">捕获异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.3.</span> <span class="toc-text">实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E6%A0%87%E5%87%86%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-number">1.4.</span> <span class="toc-text">C++ 标准的异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%96%B0%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-number">1.5.</span> <span class="toc-text">定义新的异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-1"><span class="toc-number">1.6.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.</span> <span class="toc-text">类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-number">2.1.</span> <span class="toc-text">类的封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%A4%84%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">对象的初始化和处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">2.2.1.</span> <span class="toc-text">构造函数的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.2.2.</span> <span class="toc-text">深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">2.2.3.</span> <span class="toc-text">构造函数的初始化列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E7%B1%BB%E6%88%90%E5%91%98"><span class="toc-number">2.2.4.</span> <span class="toc-text">类对象作为类成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98-%E5%8F%98%E9%87%8F-%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.5.</span> <span class="toc-text">静态成员(变量&amp;函数)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%92%8Cthis%E6%8C%87%E9%92%88"><span class="toc-number">2.3.</span> <span class="toc-text">c++对象模型和this指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%88%86%E5%BC%80%E5%AD%98%E5%82%A8"><span class="toc-number">2.3.1.</span> <span class="toc-text">成员变量和成员函数分开存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E6%8C%87%E9%92%88"><span class="toc-number">2.3.2.</span> <span class="toc-text">this指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.3.</span> <span class="toc-text">const修饰成员函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83"><span class="toc-number">2.4.</span> <span class="toc-text">友元</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E4%BD%9C%E5%8F%8B%E5%85%83"><span class="toc-number">2.4.1.</span> <span class="toc-text">全局函数作友元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%BD%9C%E5%8F%8B%E5%85%83"><span class="toc-number">2.4.2.</span> <span class="toc-text">类作友元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BD%9C%E5%8F%8B%E5%85%83"><span class="toc-number">2.4.3.</span> <span class="toc-text">成员函数作友元</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">2.5.</span> <span class="toc-text">运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">2.5.1.</span> <span class="toc-text">加号运算符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">2.5.2.</span> <span class="toc-text">左移运算符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">2.5.3.</span> <span class="toc-text">赋值运算符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">2.5.4.</span> <span class="toc-text">关系运算符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">2.5.5.</span> <span class="toc-text">函数调用运算符重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">2.6.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">2.6.1.</span> <span class="toc-text">继承基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">2.6.2.</span> <span class="toc-text">继承的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%9F%A5%E7%9C%8B"><span class="toc-number">2.6.3.</span> <span class="toc-text">继承模型的查看</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-number">2.6.4.</span> <span class="toc-text">继承中构造和析构的顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">2.6.5.</span> <span class="toc-text">继承同名成员的处理方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E5%90%8D%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">2.6.6.</span> <span class="toc-text">同名静态成员的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF%E8%AF%AD%E6%B3%95"><span class="toc-number">2.6.7.</span> <span class="toc-text">多继承语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98"><span class="toc-number">2.6.8.</span> <span class="toc-text">菱形继承问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">2.7.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">2.7.1.</span> <span class="toc-text">多态的基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">2.7.2.</span> <span class="toc-text">纯虚函数和抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%92%8C%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84"><span class="toc-number">2.7.3.</span> <span class="toc-text">虚析构和纯虚析构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">3.</span> <span class="toc-text">文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="toc-number">3.1.</span> <span class="toc-text">文本文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">3.1.1.</span> <span class="toc-text">写文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="toc-number">3.1.2.</span> <span class="toc-text">读文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-number">3.2.</span> <span class="toc-text">二进制文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%96%87%E4%BB%B6-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">写文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E6%96%87%E4%BB%B6-1"><span class="toc-number">3.2.2.</span> <span class="toc-text">读文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E7%89%88"><span class="toc-number">4.</span> <span class="toc-text">模版</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E7%89%88"><span class="toc-number">4.1.</span> <span class="toc-text">函数模版</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E7%89%88%E8%AF%AD%E6%B3%95"><span class="toc-number">4.1.0.1.</span> <span class="toc-text">函数模版语法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E7%89%88%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">4.1.1.</span> <span class="toc-text">函数模版注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E7%89%88%E6%A1%88%E4%BE%8B-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">4.1.2.</span> <span class="toc-text">函数模版案例-选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A8%A1%E7%89%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.3.</span> <span class="toc-text">普通函数与函数模版的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E6%A8%A1%E7%89%88%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-number">4.1.4.</span> <span class="toc-text">普通函数与模版函数的调用规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E7%89%88"><span class="toc-number">4.2.</span> <span class="toc-text">类模版</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">4.2.1.</span> <span class="toc-text">类模板基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E7%89%88%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A8%A1%E7%89%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.2.2.</span> <span class="toc-text">类模版与函数模版的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E7%89%88%E4%B8%AD%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%9B%E5%BB%BA%E6%97%B6%E6%9C%BA"><span class="toc-number">4.2.3.</span> <span class="toc-text">类模版中成员函数的创建时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E7%89%88%E5%AF%B9%E8%B1%A1%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">4.2.4.</span> <span class="toc-text">类模版对象做函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E7%89%88%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-number">4.2.5.</span> <span class="toc-text">类模版与继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E7%89%88%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E5%A4%96%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.6.</span> <span class="toc-text">类模版成员函数的类外实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E7%89%88%E5%88%86%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99"><span class="toc-number">4.2.7.</span> <span class="toc-text">类模版分文件编写</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#STL%E5%88%9D%E8%AF%86"><span class="toc-number">5.</span> <span class="toc-text">STL初识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#STL%E7%9A%84%E8%AF%9E%E7%94%9F"><span class="toc-number">5.1.</span> <span class="toc-text">STL的诞生</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">5.2.</span> <span class="toc-text">STL基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6"><span class="toc-number">5.3.</span> <span class="toc-text">STL六大组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL%E4%B8%AD%E5%AE%B9%E5%99%A8%EF%BC%8C%E7%AE%97%E6%B3%95%EF%BC%8C%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">5.4.</span> <span class="toc-text">STL中容器，算法，迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E5%AD%98%E6%94%BE%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.4.1.</span> <span class="toc-text">vector存放内置数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E6%94%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.4.2.</span> <span class="toc-text">存放自定义数据类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">5.5.</span> <span class="toc-text">string基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">5.5.1.</span> <span class="toc-text">string构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="toc-number">5.5.2.</span> <span class="toc-text">string赋值操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5"><span class="toc-number">5.5.3.</span> <span class="toc-text">string字符串拼接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E7%9A%84%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9B%BF%E6%8D%A2"><span class="toc-number">5.5.4.</span> <span class="toc-text">string的查找和替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83"><span class="toc-number">5.5.5.</span> <span class="toc-text">string字符串比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E5%AD%97%E7%AC%A6%E5%AD%98%E5%8F%96"><span class="toc-number">5.5.6.</span> <span class="toc-text">string字符存取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">5.5.7.</span> <span class="toc-text">string插入和删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E5%AD%90%E4%B8%B2"><span class="toc-number">5.5.8.</span> <span class="toc-text">string子串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vector%E5%AE%B9%E5%99%A8"><span class="toc-number">5.6.</span> <span class="toc-text">vector容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">5.6.1.</span> <span class="toc-text">vector基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="toc-number">5.6.2.</span> <span class="toc-text">vector赋值操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#queue%E5%AE%B9%E5%99%A8"><span class="toc-number">5.7.</span> <span class="toc-text">queue容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">5.7.1.</span> <span class="toc-text">基本概念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map-multimap%E5%AE%B9%E5%99%A8"><span class="toc-number">5.8.</span> <span class="toc-text">map&#x2F;multimap容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="toc-number">5.8.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E6%9E%84%E9%80%A0%E5%92%8C%E8%B5%8B%E5%80%BC"><span class="toc-number">5.8.2.</span> <span class="toc-text">map构造和赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E5%A4%A7%E5%B0%8F%E5%92%8C%E4%BA%A4%E6%8D%A2"><span class="toc-number">5.8.3.</span> <span class="toc-text">map大小和交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">5.8.4.</span> <span class="toc-text">map插入和删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E6%9F%A5%E6%89%BE%E5%92%8C%E7%BB%9F%E8%AE%A1"><span class="toc-number">5.8.5.</span> <span class="toc-text">map查找和统计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E5%AE%B9%E5%99%A8%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="toc-number">5.8.6.</span> <span class="toc-text">map容器的排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA"><span class="toc-number">5.8.7.</span> <span class="toc-text">代码演示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#list%E5%AE%B9%E5%99%A8"><span class="toc-number">5.9.</span> <span class="toc-text">list容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#list%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">5.9.1.</span> <span class="toc-text">list构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list%E8%B5%8B%E5%80%BC%E5%92%8C%E4%BA%A4%E6%8D%A2"><span class="toc-number">5.9.2.</span> <span class="toc-text">list赋值和交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C"><span class="toc-number">5.9.3.</span> <span class="toc-text">list大小操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">5.9.4.</span> <span class="toc-text">list插入和删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96"><span class="toc-number">5.9.5.</span> <span class="toc-text">list数据存取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">5.9.6.</span> <span class="toc-text">list迭代器注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list%E5%8F%8D%E8%BD%AC%E5%92%8C%E6%8E%92%E5%BA%8F"><span class="toc-number">5.9.7.</span> <span class="toc-text">list反转和排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">5.10.</span> <span class="toc-text">c++lambda表达式</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/github.fy/2024/11/09/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/" title="ffmpeg"><img src="https://so1.360tres.com/t019fc28863fbede04d.png" onerror="this.onerror=null;this.src='/github.fy/img/404.jpg'" alt="ffmpeg"/></a><div class="content"><a class="title" href="/github.fy/2024/11/09/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/" title="ffmpeg">ffmpeg</a><time datetime="2024-11-09T08:09:29.451Z" title="发表于 2024-11-09 16:09:29">2024-11-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/github.fy/2024/08/05/QT%20-%20add/" title="Qt"><img src="https://t8.baidu.com/it/u=4067589254,2956208776&amp;fm=193" onerror="this.onerror=null;this.src='/github.fy/img/404.jpg'" alt="Qt"/></a><div class="content"><a class="title" href="/github.fy/2024/08/05/QT%20-%20add/" title="Qt">Qt</a><time datetime="2024-08-05T05:59:31.581Z" title="发表于 2024-08-05 13:59:31">2024-08-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/github.fy/2024/07/31/%E5%8A%9B%E6%89%A3%E9%A2%98%E7%9B%AE/" title="leetcode"><img src="/github.fy/img/404.jpg" onerror="this.onerror=null;this.src='/github.fy/img/404.jpg'" alt="leetcode"/></a><div class="content"><a class="title" href="/github.fy/2024/07/31/%E5%8A%9B%E6%89%A3%E9%A2%98%E7%9B%AE/" title="leetcode">leetcode</a><time datetime="2024-07-31T08:42:06.141Z" title="发表于 2024-07-31 16:42:06">2024-07-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/github.fy/2024/07/21/QT/" title="Qt"><img src="https://t8.baidu.com/it/u=4067589254,2956208776&amp;fm=193" onerror="this.onerror=null;this.src='/github.fy/img/404.jpg'" alt="Qt"/></a><div class="content"><a class="title" href="/github.fy/2024/07/21/QT/" title="Qt">Qt</a><time datetime="2024-07-21T05:50:00.611Z" title="发表于 2024-07-21 13:50:00">2024-07-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/github.fy/2024/07/12/C++/" title="c++"><img src="https://img2.baidu.com/it/u=1339810107,1799612389&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=512&amp;h=328" onerror="this.onerror=null;this.src='/github.fy/img/404.jpg'" alt="c++"/></a><div class="content"><a class="title" href="/github.fy/2024/07/12/C++/" title="c++">c++</a><time datetime="2024-07-12T07:18:51.931Z" title="发表于 2024-07-12 15:18:51">2024-07-12</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://img2.baidu.com/it/u=1339810107,1799612389&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=512&amp;h=328')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 二马山石</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/github.fy/js/utils.js?v=4.13.0"></script><script src="/github.fy/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script id="canvas_nest" defer="defer" color="(0,205,205)" opacity="0.7" zIndex="-1" count="99" mobile="true" src="/github.fy/%5Bobject%20Object%5D"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>