<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>c++ | FY的博客</title><meta name="author" content="二马山石"><meta name="copyright" content="二马山石"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 类和对象类">
<meta property="og:type" content="article">
<meta property="og:title" content="c++">
<meta property="og:url" content="https://fylhg.github.io/github.fy/2024/07/12/C++/index.html">
<meta property="og:site_name" content="FY的博客">
<meta property="og:description" content="Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 类和对象类">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img2.baidu.com/it/u=1339810107,1799612389&fm=253&fmt=auto&app=138&f=JPEG?w=512&h=328">
<meta property="article:published_time" content="2024-07-12T07:18:51.931Z">
<meta property="article:modified_time" content="2024-07-15T08:41:23.234Z">
<meta property="article:author" content="二马山石">
<meta property="article:tag" content="c++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img2.baidu.com/it/u=1339810107,1799612389&fm=253&fmt=auto&app=138&f=JPEG?w=512&h=328"><link rel="shortcut icon" href="/github.fy/img/favicon.png"><link rel="canonical" href="https://fylhg.github.io/github.fy/2024/07/12/C++/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/github.fy/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/github.fy/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'c++',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-15 16:41:23'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/github.fy/img/1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/github.fy/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/github.fy/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/github.fy/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/github.fy/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/github.fy/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/github.fy/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/github.fy/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/github.fy/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/github.fy/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/github.fy/link/"><i class="fa-fw fas fa-link"></i><span> 连接</span></a></div><div class="menus_item"><a class="site-page" href="/github.fy/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img2.baidu.com/it/u=1339810107,1799612389&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=512&amp;h=328')"><nav id="nav"><span id="blog-info"><a href="/github.fy/" title="FY的博客"><img class="site-icon" src="/github.fy/img/1.jpg"/><span class="site-name">FY的博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/github.fy/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/github.fy/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/github.fy/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/github.fy/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/github.fy/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/github.fy/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/github.fy/link/"><i class="fa-fw fas fa-link"></i><span> 连接</span></a></div><div class="menus_item"><a class="site-page" href="/github.fy/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">c++</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-12T07:18:51.931Z" title="发表于 2024-07-12 15:18:51">2024-07-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-15T08:41:23.234Z" title="更新于 2024-07-15 16:41:23">2024-07-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/github.fy/categories/c/">c++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="c++"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id="类的封装"><a href="#类的封装" class="headerlink" title="类的封装"></a>类的封装</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	string Private=<span class="string">&quot;私有属性类外无法访问&quot;</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string Protected=<span class="string">&quot;保护属性类外无法访问&quot;</span>;<span class="comment">//但是子类可以访问父类中的保护属性</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">double</span> C;</span><br><span class="line">	<span class="type">double</span> S;</span><br><span class="line">	<span class="built_in">circle</span>(<span class="type">double</span> r)</span><br><span class="line">	&#123;</span><br><span class="line">		C = <span class="number">2</span> * r * pi;</span><br><span class="line">		S = pi * r * r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//通过设置的共有方法来实现对于私有属性和保护属性的设置修改等操作</span></span><br><span class="line">	<span class="function">string <span class="title">get_private</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Protected;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">circle <span class="title">fy</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;创建圆的周长为：&quot;</span> &lt;&lt; fy.C &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;创建圆的面积为：&quot;</span> &lt;&lt; fy.S &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对象的初始化和处理"><a href="#对象的初始化和处理" class="headerlink" title="对象的初始化和处理"></a>对象的初始化和处理</h2><h3 id="构造函数的分类"><a href="#构造函数的分类" class="headerlink" title="构造函数的分类"></a>构造函数的分类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="comment">//构造函数的分类：</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.无参构造函数，有参构造函数</span></span><br><span class="line">	<span class="built_in">Student</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;这是无参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Student</span>(<span class="type">int</span> a)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//当有参数的时候，赋值给类中的属性</span></span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;这是有参的普通构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//2.普通构造函数，拷贝构造函数</span></span><br><span class="line">	<span class="built_in">Student</span>(<span class="type">const</span> Student&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		age = p.age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Student</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数，内存销毁&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_student</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//对于不同类型的构造函数，有不同的创建方式</span></span><br><span class="line">	<span class="comment">//1.括号法：</span></span><br><span class="line">	Student stu1;<span class="comment">//无参构造</span></span><br><span class="line">	<span class="function">Student <span class="title">stu2</span><span class="params">(<span class="number">18</span>)</span></span>;<span class="comment">//有参构造的快速创建</span></span><br><span class="line">	<span class="comment">//Student stu1();错误 会被认为是函数声明</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.显式法：</span></span><br><span class="line">	Student stu3 = <span class="built_in">Student</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="comment">//Student(10)是一个匿名对象，如果单写的话，这个语句结束后就会调用析构函数	</span></span><br><span class="line">	Student stu4 = <span class="built_in">Student</span>(stu3);<span class="comment">//拷贝构造，将stu3的数据拷贝到stu4</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Student(stu3);错误不要利用拷贝构造函数来初始化匿名对象，会被认为是对象的声明</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.隐式法：</span></span><br><span class="line">	Student stu5 = <span class="number">10</span>;</span><br><span class="line">	Student stu6 = stu5;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="built_in">test_student</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>对象的构造函数会默认自带：一个无参构造函数，和一个浅拷贝构造函数。如要深拷贝需要自定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">student</span>(string Name,<span class="type">int</span> Age)</span><br><span class="line">	&#123;</span><br><span class="line">		name = Name;</span><br><span class="line">		age = <span class="keyword">new</span> <span class="built_in">int</span>(Age);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数初始化&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">student</span>(<span class="type">const</span> student&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		name = p.name;</span><br><span class="line">		<span class="comment">//浅拷贝构造函数,会将属性单纯的赋值过去</span></span><br><span class="line">		<span class="comment">//age = p.age;会出问题，他俩指向的地址相同析构函数释放内存的时候，会出现重复操作</span></span><br><span class="line">		<span class="comment">//所以深拷贝为了解决这个问题，则需要再次用new开辟堆的空间，使得两个析构函数在释放内存的时候</span></span><br><span class="line">		<span class="comment">//不会产生冲突</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//深拷贝：</span></span><br><span class="line">		age = <span class="keyword">new</span> <span class="built_in">int</span>(*(p.age));</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;深拷贝已经完成&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span>* age;</span><br><span class="line">	~<span class="built_in">student</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数已经释放内存&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">student <span class="title">fy</span><span class="params">(<span class="string">&quot;冯岩&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="comment">//无参构造函数，对象创建的时候不允许带括号</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//student hg(fy);</span></span><br><span class="line">	<span class="comment">//student hg = student(fy);</span></span><br><span class="line">	<span class="comment">//student hg = fy;</span></span><br><span class="line">	<span class="comment">//三种写法参考一下</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造函数的初始化列表"><a href="#构造函数的初始化列表" class="headerlink" title="构造函数的初始化列表"></a>构造函数的初始化列表</h3><p>作用:<br>C++提供了初始化列表语法,用来初始化属性</p>
<p>语法:<br>构造函数():属性1(值1),属性2(值2) … {}</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">get_private</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;age:&quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;grade:&quot;</span> &lt;&lt; grade &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">student</span>(<span class="type">int</span> Age,<span class="type">int</span> Grade,string Name) :<span class="built_in">age</span>(Age),<span class="built_in">grade</span>(Grade),<span class="built_in">name</span>(Name)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;age:&quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;grade:&quot;</span> &lt;&lt; grade &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//在构造函数中可以发现，私有属性已经被初始化了</span></span><br><span class="line">	&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span> grade;</span><br><span class="line">	string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">student <span class="title">fy</span><span class="params">(<span class="number">20</span>, <span class="number">100</span>, <span class="string">&quot;冯岩&quot;</span>)</span></span>;</span><br><span class="line">	fy.<span class="built_in">get_private</span>();<span class="comment">//共有方法来访问私有属性</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类对象作为类成员：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="built_in">student</span>(string Name) : <span class="built_in">name</span>(Name) &#123;</span><br><span class="line">	</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;student的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">teacher</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string name;</span><br><span class="line">	student fy;</span><br><span class="line">	<span class="built_in">teacher</span>(string Name,string stu):<span class="built_in">name</span>(Name),<span class="built_in">fy</span>(stu)&#123;</span><br><span class="line">	</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;teacher的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//fy(stu)相当于student fy = &quot;名字&quot; = stu</span></span><br><span class="line">	<span class="comment">//属于的是构造函数的隐式赋值的方法，直接实现对于类中对象为类的初始化</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//注：如果一个类中有成员类，那么在初始化的时候，回先调用类内成员类的构造函数</span></span><br><span class="line">	<span class="comment">//注：析构函数调用的先后顺序则相反</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">teacher</span>(<span class="string">&quot;韩歌&quot;</span>, <span class="string">&quot;冯岩&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="静态成员-变量-函数"><a href="#静态成员-变量-函数" class="headerlink" title="静态成员(变量&amp;函数)"></a>静态成员(变量&amp;函数)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//类对象作为类成员：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//静态成员变量的特点：</span></span><br><span class="line">	<span class="comment">//1.编译阶段就会给静态成员分配内存</span></span><br><span class="line">	<span class="comment">//2.类内声明，类外初始化</span></span><br><span class="line">	<span class="comment">//3.所有对象共享同一份数据</span></span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> num_A;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员函数的特点：</span></span><br><span class="line">	<span class="comment">//1.所有对象共享静态成员函数</span></span><br><span class="line">	<span class="comment">//2.静态成员函数只能对静态成员变量做出操作</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;这是一个静态成员函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;静态成员函数操作static静态成员变量：num_A&quot;</span> &lt;&lt; num_A &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">student</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		num_A++;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//静态成员也是有访问权限的</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> num_B;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> student::num_A = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> student::num_B = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//静态变量初始话在类外，类型 类名::变量名 = 值</span></span><br><span class="line"><span class="comment">//其中student::num_A表示的是作用域在student中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//静态成员的两种访问方式：</span></span><br><span class="line">	<span class="comment">//1.通过创建的类来访问</span></span><br><span class="line">	student fy;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;创建了 &quot;</span>&lt;&lt;fy.num_A&lt;&lt;<span class="string">&quot; 个student对象&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//2.通过类名直接访问  类名::static数据</span></span><br><span class="line">	student hg;</span><br><span class="line">	cout &lt;&lt;<span class="string">&quot;创建了 &quot;</span> &lt;&lt; student::num_A &lt;&lt;<span class="string">&quot; 个student对象&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//cout&lt;&lt;student::num_B&lt;&lt;endl;私有属性是访问不到的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员函数的两种调用方式：</span></span><br><span class="line">	hg.<span class="built_in">print</span>();<span class="comment">//1.调用静态成员函数</span></span><br><span class="line">	<span class="comment">//2.也可以同过类名直接调用</span></span><br><span class="line">	student::<span class="built_in">print</span>();</span><br><span class="line">	<span class="comment">//注：静态成员函数如果是私有的话，同样不可以被访问</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="c-对象模型和this指针"><a href="#c-对象模型和this指针" class="headerlink" title="c++对象模型和this指针"></a>c++对象模型和this指针</h2><h3 id="成员变量和成员函数分开存储"><a href="#成员变量和成员函数分开存储" class="headerlink" title="成员变量和成员函数分开存储"></a>成员变量和成员函数分开存储</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//类对象作为类成员：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//静态成员变量 - 不属于类对象上</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> num_A;</span><br><span class="line">	<span class="comment">//静态成员方法 - 不属于类对象上</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="comment">//非静态成员变量 - 属于类对象上</span></span><br><span class="line">	<span class="type">int</span> num_B;</span><br><span class="line">	<span class="comment">//非静态成员函数 - 不属于类对象上</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">do_print</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> student::num_A=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	student fy;</span><br><span class="line">	<span class="comment">//c++会给空对象分配内存空间：1个字节</span></span><br><span class="line">	<span class="comment">//目的是为了区分空对象占用内存的位置</span></span><br><span class="line">	<span class="comment">//每个空对象也应该有一个独一无二的内存地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size of student类创建的fy:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(fy) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>类对象中只有非静态变量属于类对象上，<br>而每一个非静态函数实例只会诞生一份函数实例，也就是多个对象会共用一个相同的代码块。</p>
<p>this指针就是为了解决区分不同对象对于非静态函数的调用，<br>this指针会指向被调用成员函数所指向的对象</p>
<p>this用途：</p>
<ul>
<li>1.当形参和函数内部变量名字重名的时候，可用this指针来区分</li>
<li>2.在类的非静态成员函数中返回类的对象 return *this<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">student</span>(string name,<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//当形参与类内变量重名的时候，可以用this保证正确传递</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;	</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="function">student&amp; <span class="title">return_stu</span><span class="params">(<span class="type">const</span> student&amp;p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		age+=p.age;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">//可以这样去记 const int&amp;a 与 const int*p -&gt; a 等价于 *p</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//注意如果我们用的是 student不是student&amp;</span></span><br><span class="line">		<span class="comment">//return *this会传递一个和当前类相同的副本，成拷贝了</span></span><br><span class="line">		<span class="comment">//只有用引用才会返回我们当前调用这个函数对应的对象</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">student <span class="title">fy</span><span class="params">(<span class="string">&quot;冯岩&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">student <span class="title">hg</span><span class="params">(<span class="string">&quot;韩歌&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="comment">//***************重点：*****************</span></span><br><span class="line">	<span class="comment">//链式变成思想</span></span><br><span class="line">	fy.<span class="built_in">return_stu</span>(hg).<span class="built_in">return_stu</span>(hg);</span><br><span class="line">	cout &lt;&lt; fy.age &lt;&lt; endl;<span class="comment">//fy20+hg20+hg20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a>const修饰成员函数</h3><p><em><strong>重点：</strong></em></p>
<ul>
<li>1.指向常量的指针：这种指针指向的对象不能通过该指针修改。声明方式为const int* ptr;或者int const* ptr;，意味着ptr是一个指向int类型常量的指针。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* ptr; <span class="comment">// ptr 是指向常量整数的指针</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span>* ptr; <span class="comment">// 同上，ptr 是指向常量整数的指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">ptr = &amp;x; <span class="comment">// 合法，ptr 指向 x 的地址</span></span><br><span class="line">*ptr = <span class="number">20</span>; <span class="comment">// 非法，因为 ptr 指向的是一个常量，不能修改其值</span></span><br></pre></td></tr></table></figure></li>
<li>2.常量的指针：这种指针本身是常量，声明方式为int* const ptr;，表示ptr是一个指向整数的常量指针，指针本身的值（即地址）不能修改。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="type">const</span> ptr; <span class="comment">// ptr 是一个指向整数的常量指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line">ptr = &amp;x; <span class="comment">// 合法，ptr 现在指向 x 的地址</span></span><br><span class="line">*ptr = <span class="number">30</span>; <span class="comment">// 合法，通过 ptr 可以修改 x 的值</span></span><br><span class="line">ptr = &amp;y; <span class="comment">// 非法，因为 ptr 是一个常量指针，不能修改其指向的地址</span></span><br></pre></td></tr></table></figure>
<em><strong>this就是一个常量指针！！！</strong></em><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常函数</span></span><br><span class="line"><span class="comment">//1.在成员函数后面加const，就成为常函数</span></span><br><span class="line"><span class="comment">//2.常函数内不可以修改成员属性</span></span><br><span class="line"><span class="comment">//3.成员属性的声明前+关键字mutable,在常函数中依旧可以修改。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">get_name</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//无法访问成员属性</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//只能访问加了关键字mutable的属性</span></span><br><span class="line">		age = <span class="number">0</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;访问加了关键字mutable的属性：age&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//常对象</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> Person fy;</span><br><span class="line">	<span class="comment">//常对象只能调用常函数</span></span><br><span class="line">	fy.<span class="built_in">get_name</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>友元的目的是让一个函数或者类去访问另一个类中的私有成员</p>
<p>友元的关键字为：<em><strong>friend</strong></em></p>
<p>友元的三种实现：</p>
<ul>
<li>全局函数作为友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
<h3 id="全局函数作友元"><a href="#全局函数作友元" class="headerlink" title="全局函数作友元"></a>全局函数作友元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">get_Person_Private</span><span class="params">(Person&amp; person)</span></span>;</span><br><span class="line">	<span class="comment">//告诉编译器这是一个该来的友元函数，可以访问类中的私有成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//全局函数作为友元函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_Person_Private</span><span class="params">(Person&amp; person)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Person中的私有属性name:&quot;</span> &lt;&lt; person.name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">fy</span><span class="params">(<span class="string">&quot;冯岩&quot;</span>)</span></span>;</span><br><span class="line">	<span class="built_in">get_Person_Private</span>(fy);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="类作友元"><a href="#类作友元" class="headerlink" title="类作友元"></a>类作友元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//成员函数作友元</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">father</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit_Son_mPrivate</span><span class="params">()</span></span>;</span><br><span class="line">	son* Son;</span><br><span class="line">	<span class="built_in">father</span>(string Son_name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span></span><br><span class="line">&#123;<span class="comment">//类作为友元，它的内部的方法可以访问son中的私有属性</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">father</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">son</span>(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">	string name;</span><br><span class="line">&#125;;</span><br><span class="line">father::<span class="built_in">father</span>(string son_name)</span><br><span class="line">&#123;</span><br><span class="line">	Son = <span class="keyword">new</span> <span class="built_in">son</span>(son_name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">father::visit_Son_mPrivate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; Son-&gt;name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="成员函数作友元"><a href="#成员函数作友元" class="headerlink" title="成员函数作友元"></a>成员函数作友元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//成员函数作友元</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">father</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit_son_mPrivate</span><span class="params">()</span></span>;<span class="comment">//希望通过父类的成员函数访问成员类中的私有属性</span></span><br><span class="line">	son* Son;</span><br><span class="line">	<span class="built_in">father</span>(string Son_name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//friend void visit_son_mPrivate();这样声明是错误的，因为这样定义的不是father中的函数</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">father::visit_son_mPrivate</span><span class="params">()</span></span>;<span class="comment">//必须在函数名字前加上作用域</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">son</span>(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">	string name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//之所以采用这种方式来定义构造函数，因为它涉及了多个类，所以在类都定义完后</span></span><br><span class="line"><span class="comment">//采取 类名::构造函数来定义</span></span><br><span class="line">father::<span class="built_in">father</span>(string Son_name)</span><br><span class="line">&#123;</span><br><span class="line">	Son = <span class="keyword">new</span> <span class="built_in">son</span>(Son_name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">father::visit_son_mPrivate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; Son-&gt;name &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">father <span class="title">me</span><span class="params">(<span class="string">&quot;hg&quot;</span>)</span></span>;</span><br><span class="line">	me.<span class="built_in">visit_son_mPrivate</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><ul>
<li>加号运算符重载</li>
<li>左移运算符重载</li>
<li>递增运算符重载</li>
<li>赋值运算符重载</li>
<li>关系运算符重载</li>
<li>函数调用运算符重载</li>
</ul>
<h3 id="加号运算符重载"><a href="#加号运算符重载" class="headerlink" title="加号运算符重载"></a>加号运算符重载</h3><ul>
<li>全局函数重载</li>
<li>成员函数重载<br><strong>注：无论哪种方式都需要在函数中创建一个新的类，最后将其return。</strong><br>全局函数重载<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Complex</span>(<span class="type">int</span> m_a, string m_name, <span class="type">double</span> m_digital) : <span class="built_in">m_A</span>(m_a), <span class="built_in">m_Name</span>(m_name), <span class="built_in">m_Digital</span>(m_digital) &#123;&#125;;</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">double</span> m_Digital;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//全局函数重载“+”</span></span><br><span class="line"><span class="comment">//opereator+加号重载</span></span><br><span class="line">Complex <span class="keyword">operator</span>+ (<span class="type">const</span> Complex&amp; A, <span class="type">const</span> Complex&amp; B)</span><br><span class="line">&#123;</span><br><span class="line">	Complex C = <span class="built_in">Complex</span>(<span class="number">10</span>, <span class="string">&quot;abc&quot;</span>, <span class="number">3.14</span>);</span><br><span class="line">	C.m_A = A.m_A + B.m_A;</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">A</span><span class="params">(<span class="number">10</span>, <span class="string">&quot;a&quot;</span>, <span class="number">3.1415</span>)</span></span>;</span><br><span class="line">	<span class="function">Complex <span class="title">B</span><span class="params">(<span class="number">11</span>, <span class="string">&quot;b&quot;</span>, <span class="number">3.1415</span>)</span></span>;</span><br><span class="line">	Complex C = A + B;</span><br><span class="line">	cout &lt;&lt; C.m_A &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
成员函数重载<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Complex</span>(<span class="type">int</span> m_a=<span class="number">0</span>, string m_name=<span class="string">&quot;&quot;</span>, <span class="type">double</span> m_digital=<span class="number">0.0</span>) : <span class="built_in">m_A</span>(m_a), <span class="built_in">m_Name</span>(m_name), <span class="built_in">m_Digital</span>(m_digital) &#123;&#125;;</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">double</span> m_Digital;</span><br><span class="line">	<span class="comment">//成员函数重载：operator+</span></span><br><span class="line">	Complex <span class="keyword">operator</span>+ ( <span class="type">const</span> Complex&amp; B)</span><br><span class="line">	&#123;</span><br><span class="line">		Complex C ;</span><br><span class="line">		C.m_A = <span class="keyword">this</span>-&gt;m_A + B.m_A;</span><br><span class="line">		<span class="keyword">return</span> C;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">A</span><span class="params">(<span class="number">10</span>, <span class="string">&quot;a&quot;</span>, <span class="number">3.1415</span>)</span></span>;</span><br><span class="line">	<span class="function">Complex <span class="title">B</span><span class="params">(<span class="number">11</span>, <span class="string">&quot;b&quot;</span>, <span class="number">3.1415</span>)</span></span>;</span><br><span class="line">	Complex C = A + B;</span><br><span class="line">	cout &lt;&lt; C.m_A &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a>左移运算符重载</h3><ul>
<li>全局函数重载<br>注：左移对象运算符重载，传入的引用参数前面最好加上const<br>因为有时候传入的可能是一个临时对象，（后置递增的时候就是这样的）。<br>临时对象在表达式结束的时候就会被销毁，加上const保障安全性<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;cout,<span class="type">const</span> 类名&amp;变量名)</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Complex</span>(<span class="type">int</span> m_a=<span class="number">0</span>, string m_name=<span class="string">&quot;&quot;</span>, <span class="type">double</span> m_digital=<span class="number">0.0</span>) : <span class="built_in">m_A</span>(m_a), <span class="built_in">m_Name</span>(m_name), <span class="built_in">m_Digital</span>(m_digital) &#123;&#125;;</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">double</span> m_Digital;</span><br><span class="line">	<span class="comment">//成员函数重载：operator&lt;&lt;</span></span><br><span class="line">	<span class="comment">//void operator&lt;&lt; (ostream &amp;cout )&#123;&#125;</span></span><br><span class="line">	<span class="comment">//不能这么写，这么写会导致 对象.operator&lt;&lt;(cout)相当于 对象&lt;&lt;cout,这样和正常的输出是相反的</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//全局函数重载：</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, Complex&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; p.m_Name &lt;&lt; p.m_A &lt;&lt; p.m_Digital;</span><br><span class="line">	<span class="comment">//把cout的引用返回，就可以链式的用cout的正常的功能了</span></span><br><span class="line">	<span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">A</span><span class="params">(<span class="number">10</span>, <span class="string">&quot;a&quot;</span>, <span class="number">3.1415</span>)</span></span>;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; A ;</span><br><span class="line">	<span class="comment">//当全局函数没有返回cout对象的时候后面不能加任何内容</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; A &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//当给return后可以链式的输出</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hero</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">hero</span>(<span class="type">int</span> bravery=<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span>* bravery;</span><br><span class="line">	<span class="comment">//运算符号重载</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//这里必须返回的是引用，不然会返回一个新的对象副本</span></span><br><span class="line">	hero&amp; <span class="keyword">operator</span>=(hero &amp;p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//编译器提供浅拷贝函数</span></span><br><span class="line">		<span class="comment">//this-&gt;name = p.name;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//先判断对象中是否有属性在堆区，先将堆区的内存释放，然后再深拷贝</span></span><br><span class="line">		<span class="keyword">if</span> (bravery != <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">delete</span>(bravery);<span class="comment">//释放内存后，要把属性置为空指针</span></span><br><span class="line">			bravery = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>-&gt;bravery = <span class="keyword">new</span> <span class="built_in">int</span>(*p.bravery);<span class="comment">//深拷贝防止析构函数内存重复释放</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">hero</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">delete</span>(bravery);</span><br><span class="line">		bravery = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">hero::<span class="built_in">hero</span>(<span class="type">int</span> bravery)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;bravery = <span class="keyword">new</span> <span class="built_in">int</span>(bravery);</span><br><span class="line">&#125;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> hero&amp; name)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; *(name.bravery);</span><br><span class="line">	<span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">hero <span class="title">fy</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">hero <span class="title">hg</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">	hero me;</span><br><span class="line">	me = fy;</span><br><span class="line">	cout &lt;&lt; me &lt;&lt; endl;<span class="comment">//10</span></span><br><span class="line">	me = hg;</span><br><span class="line">	cout &lt;&lt; me &lt;&lt; endl;<span class="comment">//20</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//10</span></span><br><span class="line">	me = hg = fy;<span class="comment">//要求重载=时函数要返回对象本身的引用</span></span><br><span class="line">	cout &lt;&lt; me &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h3><h3 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载"></a>函数调用运算符重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Myclass</span>(string s)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;构造函数：&quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//函数调用运算符重载，可以使得对象能和函数一样被调用</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt;<span class="string">&quot;()重载：&quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Myclass <span class="title">my</span><span class="params">(<span class="string">&quot;fyyf&quot;</span>)</span></span>;<span class="comment">//构造函数的调用</span></span><br><span class="line">	<span class="built_in">my</span>(<span class="string">&quot;fylhg&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="继承基本语法"><a href="#继承基本语法" class="headerlink" title="继承基本语法"></a>继承基本语法</h3><p>总结:<br>继承的好处:可以减少重复的代码</p>
<p><strong>class A : public B;</strong><br>A类称为子类 或 派生类<br>B类称为父类 或 基类</p>
<p>派生类中的成员,包含两大部分:<br>一类是从基类继承过来的,一类是自己增加的成员。<br>从基类继承过过来的表现其共性,而新增的成员体现了其个性。</p>
<h3 id="继承的方式"><a href="#继承的方式" class="headerlink" title="继承的方式"></a>继承的方式</h3><ul>
<li>公有继承</li>
<li>保护继承</li>
<li>私有继承<br><img src="/github.fy/assets/1366313.png"></li>
</ul>
<h3 id="继承模型的查看"><a href="#继承模型的查看" class="headerlink" title="继承模型的查看"></a>继承模型的查看</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">father</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//查看继承后对象的模型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用Visual Studio 2022 Developer Command Prompt</span></span><br><span class="line"><span class="comment">//cd到对应的目录下面</span></span><br><span class="line"><span class="comment">//dir查看当前路径下内容</span></span><br><span class="line"><span class="comment">//输入 cl /d1 reportSingleClassLayout类名 源.cpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> father</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	son fy;</span><br><span class="line">	<span class="comment">//16</span></span><br><span class="line">	<span class="comment">//父类中的非静态成员属性都会被继承下去</span></span><br><span class="line">	<span class="comment">//父类的私有属性会被编译器隐藏了，但却是被继承下来了。</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(son) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/github.fy/assets/4444.png"></p>
<h3 id="继承中构造和析构的顺序"><a href="#继承中构造和析构的顺序" class="headerlink" title="继承中构造和析构的顺序"></a>继承中构造和析构的顺序</h3><p>先调用父类的构造函数再调用子类的构造函数，析构函数则相反。</p>
<h3 id="继承同名成员的处理方式"><a href="#继承同名成员的处理方式" class="headerlink" title="继承同名成员的处理方式"></a>继承同名成员的处理方式</h3><p>问题：当子类与父类中出现相同名字的成员时，如何通过子类的对象访问到子类或者父类中的数据。</p>
<ul>
<li>访问子类中的同名成员，直接访问即可。</li>
<li>访问父类中的同名成员，需要加上作用域。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">father</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">father</span>(<span class="type">int</span> a)</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = a;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">return_mA</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;father中的m_A&quot;</span> &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> father</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">son</span>(<span class="type">int</span> a):<span class="built_in">father</span>(a)<span class="comment">//利用son中的构造函数对父类中的构造函数初始化</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_A = a;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">return_mA</span><span class="params">()</span><span class="comment">//父类和子类中都用同名函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;son中的m_A&quot;</span> &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> m_A;<span class="comment">//此时父类和子类中拥有相同名字的数据</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">son <span class="title">fy</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	fy.<span class="built_in">return_mA</span>();</span><br><span class="line">	fy.father::<span class="built_in">return_mA</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
总结：</li>
</ul>
<ol>
<li>子类对象可以直接访问到子类中同名成员<br>2.子类对象加作用域可以访问到父类同名成员<br>3.当子类与父类拥有同名的成员函数,子类会隐藏父类中同名成员函数,加作用域可以访问到父类中同名函数</li>
</ol>
<h3 id="同名静态成员的处理"><a href="#同名静态成员的处理" class="headerlink" title="同名静态成员的处理"></a>同名静态成员的处理</h3><p>首先复习一下静态成员和静态成员函数<br>静态成员属性：</p>
<ul>
<li>类内声明，类外初始化</li>
<li>访问方式：1.类名::静态成员属性。2.类.静态成员属性<br>静态成员函数：<br>  只能对于类中的静态成员属性进行操作。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">father</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">father</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> father::m_A = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> father</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">	<span class="comment">//子类和父类的静态成员重名</span></span><br><span class="line">	<span class="built_in">son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> son::m_A = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	son fy;</span><br><span class="line">	<span class="comment">//1.通过对象访问：</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;father中的m_A:&quot;</span> &lt;&lt; fy.father::m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;son中的m_A:&quot;</span> &lt;&lt; fy.son::m_A &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//2.通过类名访问：</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//由于son继承了father所以可以用下面这种方式访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;father中的m_A:&quot;</span> &lt;&lt; son::father::m_A&lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;son中的m_A:&quot;</span> &lt;&lt; son::m_A &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="多继承语法"><a href="#多继承语法" class="headerlink" title="多继承语法"></a>多继承语法</h3><p>C++允许一个类继承多个类</p>
<p>语法:</p>
<p>class 子类:继承方式 父类1,继承方式 父类2 …</p>
<p><em>注：多继承可能会引发父类中有同名成员出现,需要加作用域区分</em></p>
<p>C++实际开发中不建议用多继承</p>
<h3 id="菱形继承问题"><a href="#菱形继承问题" class="headerlink" title="菱形继承问题"></a>菱形继承问题</h3><p>利用虚继承，解决菱形继承问题<br>继承前面加上 virtual 变为虚继承<br>person成为虚基类<br>此时继承虚基类的类中会有一个vbptr（虚基指针）指向virtualtable列表，列表中记录着偏移量<br>这样多个继承了虚基类中的数据是同一份的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		string name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//利用虚继承，解决菱形继承问题</span></span><br><span class="line"><span class="comment">//继承前面加上 virtual 变为虚继承</span></span><br><span class="line"><span class="comment">//person成为虚基类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此时继承虚基类的类中会有一个vbptr（虚基指针）指向virtualtable列表，列表中记录着偏移量</span></span><br><span class="line"><span class="comment">//这样多个继承了虚基类中的数据是同一份的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">f</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> person</span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">y</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> person</span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">fy</span> :<span class="keyword">public</span> f, <span class="keyword">public</span> y</span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://fylhg.github.io/github.fy">二马山石</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://fylhg.github.io/github.fy/2024/07/12/C++/">https://fylhg.github.io/github.fy/2024/07/12/C++/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://fylhg.github.io/github.fy" target="_blank">FY的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/github.fy/tags/c/">c++</a></div><div class="post_share"><div class="social-share" data-image="https://img2.baidu.com/it/u=1339810107,1799612389&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=512&amp;h=328" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/github.fy/2024/07/04/esp32%E7%AC%94%E8%AE%B0/" title="esp32"><img class="cover" src="http://micropython.86x.net/en/latet/_images/esp32.jpg" onerror="onerror=null;src='/github.fy/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">esp32</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/github.fy/img/1.jpg" onerror="this.onerror=null;this.src='/github.fy/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">二马山石</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/github.fy/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/github.fy/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/github.fy/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.</span> <span class="toc-text">类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-number">1.1.</span> <span class="toc-text">类的封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%A4%84%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">对象的初始化和处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.2.1.</span> <span class="toc-text">构造函数的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.2.2.</span> <span class="toc-text">深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text">构造函数的初始化列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E7%B1%BB%E6%88%90%E5%91%98"><span class="toc-number">1.2.4.</span> <span class="toc-text">类对象作为类成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98-%E5%8F%98%E9%87%8F-%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.5.</span> <span class="toc-text">静态成员(变量&amp;函数)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%92%8Cthis%E6%8C%87%E9%92%88"><span class="toc-number">1.3.</span> <span class="toc-text">c++对象模型和this指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%88%86%E5%BC%80%E5%AD%98%E5%82%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">成员变量和成员函数分开存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E6%8C%87%E9%92%88"><span class="toc-number">1.3.2.</span> <span class="toc-text">this指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.3.</span> <span class="toc-text">const修饰成员函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83"><span class="toc-number">1.4.</span> <span class="toc-text">友元</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E4%BD%9C%E5%8F%8B%E5%85%83"><span class="toc-number">1.4.1.</span> <span class="toc-text">全局函数作友元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%BD%9C%E5%8F%8B%E5%85%83"><span class="toc-number">1.4.2.</span> <span class="toc-text">类作友元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BD%9C%E5%8F%8B%E5%85%83"><span class="toc-number">1.4.3.</span> <span class="toc-text">成员函数作友元</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">1.5.</span> <span class="toc-text">运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">1.5.1.</span> <span class="toc-text">加号运算符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">1.5.2.</span> <span class="toc-text">左移运算符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">1.5.3.</span> <span class="toc-text">赋值运算符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">1.5.4.</span> <span class="toc-text">关系运算符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">1.5.5.</span> <span class="toc-text">函数调用运算符重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">1.6.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">1.6.1.</span> <span class="toc-text">继承基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.6.2.</span> <span class="toc-text">继承的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%9F%A5%E7%9C%8B"><span class="toc-number">1.6.3.</span> <span class="toc-text">继承模型的查看</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.6.4.</span> <span class="toc-text">继承中构造和析构的顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.6.5.</span> <span class="toc-text">继承同名成员的处理方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E5%90%8D%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">1.6.6.</span> <span class="toc-text">同名静态成员的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF%E8%AF%AD%E6%B3%95"><span class="toc-number">1.6.7.</span> <span class="toc-text">多继承语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.8.</span> <span class="toc-text">菱形继承问题</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/github.fy/2024/07/12/C++/" title="c++"><img src="https://img2.baidu.com/it/u=1339810107,1799612389&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=512&amp;h=328" onerror="this.onerror=null;this.src='/github.fy/img/404.jpg'" alt="c++"/></a><div class="content"><a class="title" href="/github.fy/2024/07/12/C++/" title="c++">c++</a><time datetime="2024-07-12T07:18:51.931Z" title="发表于 2024-07-12 15:18:51">2024-07-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/github.fy/2024/07/04/esp32%E7%AC%94%E8%AE%B0/" title="esp32"><img src="http://micropython.86x.net/en/latet/_images/esp32.jpg" onerror="this.onerror=null;this.src='/github.fy/img/404.jpg'" alt="esp32"/></a><div class="content"><a class="title" href="/github.fy/2024/07/04/esp32%E7%AC%94%E8%AE%B0/" title="esp32">esp32</a><time datetime="2024-07-04T05:46:02.527Z" title="发表于 2024-07-04 13:46:02">2024-07-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/github.fy/2024/05/25/Verilog%E8%AF%AD%E6%B3%95/" title="verilog语法"><img src="https://picx.zhimg.com/v2-8914ff9e3185a4a0e1ac1f7b037e9cb8_720w.jpg?source=172ae18b" onerror="this.onerror=null;this.src='/github.fy/img/404.jpg'" alt="verilog语法"/></a><div class="content"><a class="title" href="/github.fy/2024/05/25/Verilog%E8%AF%AD%E6%B3%95/" title="verilog语法">verilog语法</a><time datetime="2024-05-25T03:19:49.606Z" title="发表于 2024-05-25 11:19:49">2024-05-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/github.fy/2024/05/24/FPGA%20-%20%E7%82%B9%E4%BA%AE%E7%AC%AC%E4%B8%80%E4%B8%AAled/" title="fpga-点亮第一个led"><img src="https://img1.baidu.com/it/u=2942801448,4270513960&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=281" onerror="this.onerror=null;this.src='/github.fy/img/404.jpg'" alt="fpga-点亮第一个led"/></a><div class="content"><a class="title" href="/github.fy/2024/05/24/FPGA%20-%20%E7%82%B9%E4%BA%AE%E7%AC%AC%E4%B8%80%E4%B8%AAled/" title="fpga-点亮第一个led">fpga-点亮第一个led</a><time datetime="2024-05-24T14:30:05.151Z" title="发表于 2024-05-24 22:30:05">2024-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/github.fy/2024/05/23/FPGA/" title="fpga"><img src="https://img1.baidu.com/it/u=4248986468,2019673196&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=479&amp;h=320" onerror="this.onerror=null;this.src='/github.fy/img/404.jpg'" alt="fpga"/></a><div class="content"><a class="title" href="/github.fy/2024/05/23/FPGA/" title="fpga">fpga</a><time datetime="2024-05-23T12:21:07.639Z" title="发表于 2024-05-23 20:21:07">2024-05-23</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://img2.baidu.com/it/u=1339810107,1799612389&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=512&amp;h=328')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 二马山石</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/github.fy/js/utils.js?v=4.13.0"></script><script src="/github.fy/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script id="canvas_nest" defer="defer" color="(0,205,205)" opacity="0.7" zIndex="-1" count="99" mobile="true" src="/github.fy/%5Bobject%20Object%5D"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>