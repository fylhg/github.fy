<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>fpga-点亮第一个led | FY的博客</title><meta name="author" content="二马山石"><meta name="copyright" content="二马山石"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[野火]FPGA Verilog开发实战指南——基于Altera EP4CE10 征途Mini开发板  野火征途Mini FPGA开发板，采用Altera EP4CE10F17C8作为主控，包含了FPGA入门必备的硬件，是FPGA入门的性价比之选。  » 2. 点亮你的LED灯   2. 点亮你的LED灯¶2.1. 章节导读¶在前面的章节我们已经将FPGA开发软件安装完毕，这一章里我们将通过建立一">
<meta property="og:type" content="article">
<meta property="og:title" content="fpga-点亮第一个led">
<meta property="og:url" content="https://fylhg.github.io/github.fy/2024/05/24/FPGA%20-%20%E7%82%B9%E4%BA%AE%E7%AC%AC%E4%B8%80%E4%B8%AAled/index.html">
<meta property="og:site_name" content="FY的博客">
<meta property="og:description" content="[野火]FPGA Verilog开发实战指南——基于Altera EP4CE10 征途Mini开发板  野火征途Mini FPGA开发板，采用Altera EP4CE10F17C8作为主控，包含了FPGA入门必备的硬件，是FPGA入门的性价比之选。  » 2. 点亮你的LED灯   2. 点亮你的LED灯¶2.1. 章节导读¶在前面的章节我们已经将FPGA开发软件安装完毕，这一章里我们将通过建立一">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img1.baidu.com/it/u=2942801448,4270513960&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=281">
<meta property="article:published_time" content="2024-05-24T14:30:05.151Z">
<meta property="article:modified_time" content="2024-09-11T09:00:57.022Z">
<meta property="article:author" content="二马山石">
<meta property="article:tag" content="fpga">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img1.baidu.com/it/u=2942801448,4270513960&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=281"><link rel="shortcut icon" href="/github.fy/img/favicon.png"><link rel="canonical" href="https://fylhg.github.io/github.fy/2024/05/24/FPGA%20-%20%E7%82%B9%E4%BA%AE%E7%AC%AC%E4%B8%80%E4%B8%AAled/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/github.fy/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/github.fy/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'fpga-点亮第一个led',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-11 17:00:57'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/github.fy/img/1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/github.fy/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/github.fy/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/github.fy/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/github.fy/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/github.fy/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/github.fy/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/github.fy/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/github.fy/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/github.fy/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/github.fy/link/"><i class="fa-fw fas fa-link"></i><span> 连接</span></a></div><div class="menus_item"><a class="site-page" href="/github.fy/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img1.baidu.com/it/u=2942801448,4270513960&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=281')"><nav id="nav"><span id="blog-info"><a href="/github.fy/" title="FY的博客"><img class="site-icon" src="/github.fy/img/1.jpg"/><span class="site-name">FY的博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/github.fy/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/github.fy/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/github.fy/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/github.fy/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/github.fy/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/github.fy/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/github.fy/link/"><i class="fa-fw fas fa-link"></i><span> 连接</span></a></div><div class="menus_item"><a class="site-page" href="/github.fy/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">fpga-点亮第一个led</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-24T14:30:05.151Z" title="发表于 2024-05-24 22:30:05">2024-05-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-11T09:00:57.022Z" title="更新于 2024-09-11 17:00:57">2024-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/github.fy/categories/fpga/">fpga</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="fpga-点亮第一个led"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/index.html">[野火]FPGA Verilog开发实战指南——基于Altera EP4CE10 征途Mini开发板</a></p>
<p><a target="_blank" rel="noopener" href="https://detail.tmall.com/item.htm?spm=a1z10.5-b-s.w4011-23268010681.61.57491550QDVCO3&id=620698035547&rn=e00cc4fa5edac965f85f43020a263844&abbucket=18"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_static/images/product.png" alt="产品图片"></a></p>
<p>野火征途Mini FPGA开发板，采用Altera EP4CE10F17C8作为主控，包含了FPGA入门必备的硬件，是FPGA入门的性价比之选。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/index.html"></a>»</li>
<li>2. 点亮你的LED灯</li>
</ul>
<hr>
<h1 id="2-点亮你的LED灯¶"><a href="#2-点亮你的LED灯¶" class="headerlink" title="2. 点亮你的LED灯¶"></a>2. 点亮你的LED灯<a href="#led" title="永久链接至标题">¶</a></h1><h2 id="2-1-章节导读¶"><a href="#2-1-章节导读¶" class="headerlink" title="2.1. 章节导读¶"></a>2.1. 章节导读<a href="#id1" title="永久链接至标题">¶</a></h2><p>在前面的章节我们已经将FPGA开发软件安装完毕，这一章里我们将通过建立一个完整的工程来验证软件安装是否正确，是否可以实现软件的基本操作。同时，我们以点亮一个led的工程为例，为大家讲解一下完整的FPGA开发流程。</p>
<h2 id="2-2-正确的设计流程¶"><a href="#2-2-正确的设计流程¶" class="headerlink" title="2.2. 正确的设计流程¶"></a>2.2. 正确的设计流程<a href="#id2" title="永久链接至标题">¶</a></h2><p>正确的设计流程是开发项目的关键，大概主要分为以下几个步骤：</p>
<ol>
<li><p>首先我们要进行设计前的规划，即对项目要有一个全局的考虑，分析项目的具体需求来设计系统的结构、划分系统的层次，确定各个子模块的结构关系和信号之间的相互关系，然后确定模块的端口信号有哪些；</p>
</li>
<li><p>根据每个模块的功能和自己的理解并结合芯片、接口的时序手册我们使用Visio画出该模块能正常工作的时序波形图；</p>
</li>
<li><p>根据所画的波形图严格设计代码，所谓的严格就是要保证设计代码的仿真结果要和所画的波形保持一致；</p>
</li>
<li><p>代码编写完成后对代码进行编译，目的是检查代码中的语法错误。若代码存在语法错误，对代码进行修改，再次编译，直至通过编译；</p>
</li>
<li><p>根据RTL代码设计合理的Testbench进行逻辑仿真（也称为前仿真、功能仿真）；</p>
</li>
<li><p>使用仿真工具进行仿真（可以使用软件自带的仿真工具，也可以使用其他的第三方仿真工具，本教程中我们使用ModelSim），并将仿真出来的波形和用Visio画出的时序波形图进行对比，如果对比有差别则修改代码直至相同；</p>
</li>
<li><p>绑定管脚后进行分析综合、布局布线，然后下载到硬件板卡中，此时如果硬件板卡能够正常工作，则说明前期的设计和编写的代码都正确；如果硬件板卡不能够正常工作，查找并解决问题，反复迭代直至正确实现功能，并重复后面的流程，最终保证硬件板卡能够正常工作。</p>
</li>
</ol>
<h2 id="2-3-工程文件夹的管理¶"><a href="#2-3-工程文件夹的管理¶" class="headerlink" title="2.3. 工程文件夹的管理¶"></a>2.3. 工程文件夹的管理<a href="#id3" title="永久链接至标题">¶</a></h2><p>在项目设计之前我们先做好准备工作，先给设计的工程建立清晰明了的文件体系，把不同的设计文件放到不同的文件夹中，养成这样一个好的习惯是为了日后更方便管理每一个项目。不同的设计文件是有类别差异的，如果不进行文件分类，而是将所有文件存放在一起，非常不易于后期文件的查找、管理和移植。</p>
<p>下面我们以点亮第一个led的项目为例进行演示。首先切记一点所有的工程路径中一定不能出现中文，否则会出现找不到文件路径的情况，因为我们使用的开发工具大都是国外的，对中文的支持性较差，所以推荐用“英文字母+数字或下划线”组合的方式来命名，且工程和文件夹的名字要有一定的意义，能够让阅读者看到名字就知道该工 程或文件大概的功能。这里我们将第一个项目的总文件夹命名为led。如图 9‑1所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led002.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led002.png" alt="Led002"></a></p>
<p>图 9‑1 总文件夹命名</p>
<p>然后在led总文件夹下建立4个子文件夹，分别来存储不同的文件集，如图 9‑2所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led003.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led003.png" alt="Led003"></a></p>
<p>图 9‑2 子文件命名</p>
<p>这四个文件夹的用途分别是：</p>
<p><strong>doc：</strong>该文件夹主要放置一些文档资料，如数据手册，使用Visio画的波形图、自己写的文档等都可以存放到这个文件夹里面。</p>
<p><strong>quartus_prj：</strong>该文件夹主要放置的是工程文件，使用Quartus II新建的工程就保存到这里，如果是使用的Xilinx的ISE开发工具，就可以命名为ise_prj，这样能很清晰的知道是用的什么开发软件进行开发的。</p>
<p><strong>rtl：</strong>该文件夹主要放置可综合的代码，就是最后可以生成硬件电路的代码，因为这部分代码主要是寄存器描述的寄存器传输级的代码所以文件夹取名为rtl（register transport level），因为也是我们的设计文件，所以也可以取名为design。</p>
<p><strong>sim:：</strong>该文件夹放置对可综合代码的仿真文件，即不可综合的代码，也叫testbench，所以也可以将文件夹取名为testbench或者tb都可以。</p>
<p>主要的文件夹就是这四个，后期的一些项目有可能还会用到Matlab、IP核，届时可以再新建一个单独管理Matlab文件和IP核文件的文件夹，文件数量可以根据自己的需求进行分类管理。</p>
<h2 id="2-4-一个完整的设计过程¶"><a href="#2-4-一个完整的设计过程¶" class="headerlink" title="2.4. 一个完整的设计过程¶"></a>2.4. 一个完整的设计过程<a href="#id4" title="永久链接至标题">¶</a></h2><p>这一小节不详细讲解语法、代码编写和思想结构，主要目的是测试软件安装激活后能否正常使用以及软件的基本操作步骤，通过第一个例子介绍后面所有设计实例的规范流程和方法（软件基本操作后面不再单独讲解，直接按照标准的开发流程重点讲解设计思想）。</p>
<h3 id="2-4-1-功能简介¶"><a href="#2-4-1-功能简介¶" class="headerlink" title="2.4.1. 功能简介¶"></a>2.4.1. 功能简介<a href="#id5" title="永久链接至标题">¶</a></h3><p>拿到一个项目后首先进行项目分析，分析实现的功能是什么、如何进行系统的结构和层次划分、每一部分用什么方法实现，由于我们是进行学习，不是开发产品，所以不考虑芯片选型的问题。</p>
<p>这里我们的第一个实例要求通过按键控制一个led灯的亮灭，按键未被按下时led灯处于熄灭状态，按键被按下时led灯处于点亮状态，实现一个最简单的有输入、输出的小工程。</p>
<h3 id="2-4-2-硬件资源¶"><a href="#2-4-2-硬件资源¶" class="headerlink" title="2.4.2. 硬件资源¶"></a>2.4.2. 硬件资源<a href="#id6" title="永久链接至标题">¶</a></h3><p>明确工程要实现的功能后，就要了解工程设计的硬件资源。在“点亮LED灯”的实验工程中，我们需要用到开发板上的按键和LED灯，我们要使用按键KEY1点亮LED灯D7，如图 9‑3所示。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led004.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led004.png" alt="Led004"></a></p>
<p>图 9‑3 硬件资源</p>
<p>由原理图可知，征途Mini开发板的按键未按下时为高电平、按下后为低电平；LED灯则为低电平点亮。如图 9‑4、图 9‑5所示。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led005.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led005.png" alt="Led005"></a></p>
<p>图 9‑4 按键部分原理图</p>
<p>`<a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led006.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led006.png" alt="Led006"></a></p>
<p>图 9‑5 LED灯原理图</p>
<h3 id="2-4-3-新建一个Visio文件及其配置¶"><a href="#2-4-3-新建一个Visio文件及其配置¶" class="headerlink" title="2.4.3. 新建一个Visio文件及其配置¶"></a>2.4.3. 新建一个Visio文件及其配置<a href="#visio" title="永久链接至标题">¶</a></h3><p>接下来就是在doc文件夹中新建一个名为led的Visio图，用于绘制我们设计过程中的结构框图和时序波形图，如图 9‑6所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led007.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led007.png" alt="Led007"></a></p>
<p>图 9‑6 Visio文件的建立及配置（一）</p>
<p>双击打开新建的Visio文件，不用选择绘图类型，直接点击“取消”，如图 9‑7所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led008.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led008.png" alt="Led008"></a></p>
<p>图 9‑7 Visio文件的建立及配置（二）</p>
<p>如图 9‑8所示，我们添加和FPGA设计相关的工具组件，先依次点击图中的①、②、③，再依次点击④中的三个工具组件，即可将FPGA相关的三个工具组件添加进来。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led009.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led009.png" alt="Led009"></a></p>
<p>图 9‑8 添加波形工具箱（一）</p>
<p>如图 9‑9所示，我们可以看到显示了已经添加的组件。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led010.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led010.png" alt="Led010"></a></p>
<p>图 9‑9 添加波形工具箱（二）</p>
<p>点击图 9‑10所示“&gt;”处将其展开。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led011.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led011.png" alt="Led011"></a></p>
<p>图 9‑10 Visio文件的建立及配置（五）</p>
<p>展开后如图 9‑11所示，三个设计好的专门用于FPGA设计的工具插件已经添加进来了（该插件也可以进行修改，或者重新设计符合自己习惯的插件）。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led012.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led012.png" alt="Led012"></a></p>
<p>图 9‑11 Visio文件的建立及配置（六）</p>
<p>为了画图时更好的对齐，我们可以把“视图”下的“网格”勾选上，如图 9‑12所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led013.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led013.png" alt="Led013"></a></p>
<p>图 9‑12 Visio文件的建立及配置（七）</p>
<p>做好上面的基本设置后就可以进行FPGA框图和时序波形图的设计了，更多细节的操作都可以在网上查询获取，这里不再进行一一讲解。</p>
<h3 id="2-4-4-模块和端口信号划分¶"><a href="#2-4-4-模块和端口信号划分¶" class="headerlink" title="2.4.4. 模块和端口信号划分¶"></a>2.4.4. 模块和端口信号划分<a href="#id7" title="永久链接至标题">¶</a></h3><p>接下来我们要对该项目的系统结构和层次进行设计，即要实现该功能需要设计哪些独立的模块，以及分析每一个模块的输入输出信号应该有哪些，这部分的设计往往是方案上的设计也称为系统架构的设计，非常重要。在公司中我们会设计一些较为复杂功能的项目，往往具有多种功能，为了简化设计，我们要把复杂的功能进行拆分简单化，划 分成相对独立的小功能，这些小功能的实现由一个个独立的模块来完成，每个小模块的功能和运转都是独立的，这样子在公司中就可以让多个人同时进行设计和验证，加快了开发效率，当每个人所分配的模块都设计好了以后，再将每个人设计的模块根据各自的功能和关系连接到一起，实现整体的功能。但是如何进行模块的划分和整体的布局 以及信号的端口设计都是需要我们在日后的学习中要不断积累的，通过做项目、多了解各种方案才能够使我们在对整体的设计结构和层次上有一个很好的把握。</p>
<p>我们今天设计的这个工程比较简单，因为只具有一个独立的功能，自然结构和层次就很简单了，所以只需要一个模块就可以实现了，我们将模块取名为led，然后再分析模块的输入输出信号应该有哪些。一个1bit的输入信号连接到按键上，取名key_in，一个1bit输出信号连接到led上，取名led_out。</p>
<p>根据上面的分析设计出的Visio框图如图 9‑13所示，在此设计中我们并不关心输入和输出之间通过什么方式来实现这种关系（可能是通过线连接、寄存器连接或者更复杂的逻辑连接），而只关心最后的输出是不是实现了我们期望的结果。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led014.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led014.png" alt="Led014"></a></p>
<p>图 9‑13 框图设计</p>
<p>为了使端口信号和功能更加清晰，我们将其整理为如表格 9‑1所示的表格。</p>
<p>表格 9‑1 端口信号描述</p>
<p>|<br>信号</p>
<p> | </p>
<p>位宽</p>
<p> | </p>
<p>类型</p>
<p> | </p>
<p>功能描述</p>
<p> |<br>| — | — | — | — |<br>| </p>
<p>key_in</p>
<p> | </p>
<p>1Bit</p>
<p> | </p>
<p>Input</p>
<p> | </p>
<p>按键的输入</p>
<p> |<br>| </p>
<p>led_out</p>
<p> | </p>
<p>1Bit</p>
<p> | </p>
<p>Output</p>
<p> | </p>
<p>输出控制led灯</p>
<p> |</p>
<h3 id="2-4-5-波形设计¶"><a href="#2-4-5-波形设计¶" class="headerlink" title="2.4.5. 波形设计¶"></a>2.4.5. 波形设计<a href="#id8" title="永久链接至标题">¶</a></h3><p>框图结构和端口信号设计完毕后就需要设计框图结构下模块功能的实现，也就是输入和输出之间怎么样的影响关系。输入和输出满足信号与系统的关系，这种关系是一种时序的、逻辑的关系，即既有时间上的关系又有逻辑上的关系。这种关系不再是结构的关系，对于这种时序的、逻辑的关系，我们用波形图的方式表达最为清晰直观。因为F PGA本身就是并行执行的，当信号较多时，我们仅靠人脑的记忆和联想如此众多信号的并行时序关系的效果可能并不是非常好，所以我们要通过绘制波形图的方法来将这种关系表达出来。波形画出来后一切时序和逻辑关系就清晰明了，无论是代码实现，还是日后再次拿过来分析代码，只要有波形图作为辅助参照，一切都是如此简单。但是 如何根据数据手册、设计要求来绘制波形图，也是我们设计方法中重点，需要跟着本教程长久的练习并加以总结才能够熟练掌握并运用自如。</p>
<p>为了使绘制的波形图更加直观，在绘制波形图前我们先统一定义输入信号用<strong>绿色</strong>标注，输出信号用<strong>红色</strong>标注，中间变量信号用<strong>黄色</strong>标注表示（本章不涉及中间变量，后面章节会有体现），本教程所有波形设计均是按照这个规范作图的，当然如果学习者有自己的颜色喜好也可以自定义配置 ，只要能够有所区分就可以。绘制波形图时首先要设计完善的测试激励以模拟最接近真实情况的输入信号，然后根据输入信号的波形画出相应的输出信号的波形。在画波形的过程中，你会详细了解到各信号之间的关系，这样先画波形的好处是能够在写代码之前对一些细节的问题做到预先了解，方便后面编写代码和调试时做到胸有成竹，在大 型复杂的项目中其优点更为明显，我们还有一个写代码的诀窍，就是如何根据波形图快速的编写出的代码，如果波形图正确，我们编写代码的速度会又快又正确，如果你基本功扎实，画图认真准确，毫不夸张的讲，根据波形图编写完的代码直接就是正确的，几乎不用调试，这在项目开发过程中的效率是相当高的。</p>
<p>本章的示例功能具体为：按键按下时即key_in为低电平，此时控制led灯的管脚为低电平，板卡硬件电路设计的led为低电平点亮，所以此时led灯为点亮状态。对于组合逻辑我们常用真值表来列出输入与输出的这种对应关系最为直接、明确，所以我们先列出如表格 9‑2所示的真值表，然后再根据真值表的输入与输出的对应关系画波形图。其波形如图 9‑14所示，与真值表的关系一一对应。</p>
<p>表格 9‑2 输入输出信号真值表</p>
<table>
<thead>
<tr>
<th>输入（input）</th>
<th>输出（output）</th>
</tr>
</thead>
<tbody><tr>
<td>key_in</td>
<td>led_out</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
<p>|1| 1|</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led015.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led015.png" alt="Led015"></a></p>
<p>图 9‑14 Visio绘制波形图</p>
<p>如果最后通过仿真得到的结果和Visio波形的输入输出的逻辑关系一致（因为是最简单的组合逻辑，所以还不考虑时序之间的关系），那么我们设计的代码一定是正确的。</p>
<h3 id="2-4-6-新建工程¶"><a href="#2-4-6-新建工程¶" class="headerlink" title="2.4.6. 新建工程¶"></a>2.4.6. 新建工程<a href="#id9" title="永久链接至标题">¶</a></h3><p>首先点击图标打开QuartusII13.0软件，如图 9‑15所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led016.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led016.png" alt="Led016"></a></p>
<p>图 9‑15 打开QuartusII13.0软件步骤（一）</p>
<p>紧接着跳出该界面，如图 9‑16所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led017.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led017.png" alt="Led017"></a></p>
<p>图 9‑16 打开QuartusII13.0软件步骤（二）</p>
<p>软件完全打开后是这样的界面，如图 9‑17所示</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led018.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led018.png" alt="Led018"></a></p>
<p>图 9‑17 打开QuartusII13.0软件步骤（三）</p>
<p>软件完全打开后会有一个快捷向导存在，如图 9‑18所示：是创建一个新的工程，是打开已经存在的工程，是最近打开过的工程列表，用户可以根据自己需求进行选择也可以不选择，不选择时可以直接点击界面右上角的 X 号退出。这里我们选择直接退出。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led019.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led019.png" alt="Led019"></a></p>
<p>图 9‑18 软件快捷向导</p>
<p>使用新工程向导新建工程，可以选择1，也可以选择2直接打开新工程向导界面。这里我们选择1，如图 9‑19所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led020.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led020.png" alt="Led020"></a></p>
<p>图 9‑19 新建工程步骤（一）</p>
<p>选择“New QuartusII Project”后点击“OK”，如图 9‑20所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led021.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led021.png" alt="Led021"></a></p>
<p>图 9‑20 新建工程步骤（二）</p>
<p>打开新工程向导首页，直接点击“Next”，如图 9‑21所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led022.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led022.png" alt="Led022"></a></p>
<p>图 9‑21 新建工程步骤（三）</p>
<p>是这个新建的工程的位置，选择到led文件夹下的quartus_prj文件夹；是这个工程的名字，也取名为led；是整个工程设计顶层的文件名，这个名字保持和2中的命名一致即可。然后点击“Next”，如图 9‑22所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led023.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led023.png" alt="Led023"></a></p>
<p>图 9‑22 新建工程步骤（四）</p>
<p>在“File name”栏选择添加已经写好的.v文件，如果有多个文件可以一次性全部添加进工程，因为我们还没有写好的.v文件，所以我们不进行添加，直接点击“Next”如图 9‑23所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led024.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led024.png" alt="Led024"></a></p>
<p>图 9‑23 新建工程步骤（四）</p>
<p>框是选择使用哪个系列的芯片，咱们使用的是CycloneIV系类的芯片；</p>
<p>框是选择该芯片的封装类型，选择FBGA封装；</p>
<p>框是管脚数量，选择256；</p>
<p>框是速度等级，选择8。</p>
<p>这4个选项设置好以后就得到了框的筛选结果，我们使用的芯片具体型号——EP4CE10F17C8。全部选择好后，点击“Next”，如图 9‑24所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led025.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led025.png" alt="Led025"></a></p>
<p>图 9‑24 新建工程步骤（五）</p>
<p>如图 9‑25所示：</p>
<p>是器件具体的名字；</p>
<p>是内核电压，我们使用的芯片内核电压是1.2v；</p>
<p>是Logic ELements（每个逻辑单元主要由一个四输出的查找表和一个寄存器构成，还包括其他的必要电路）的数量，逻辑单元数越多说明资源越多，能够实现更多的逻辑设计，芯片的价格也就越贵，设计逻辑代码主要使用的是这部分资源；</p>
<p>是用户可配置的I&#x2F;O共180个，虽然该芯片有256个管脚但是有一些管脚是不可以随意配置的，如电源管脚、固定功能的管脚，除去具有固定功能的管脚，留给用户可任意配置的管脚只有180个，设计中使用比较多的内存时就可以使用这部分专用资源；</p>
<p>是存储器的容量，共423936bit，主要是指Block RAM（块RAM），423936bit即46个M9K（每一块中包含8192个存储位，加上校验位共9216位，故称M9K）；</p>
<p>是嵌入式乘法器数目共46个，在进行数学运算时可以调用该部分的资源，以节省逻辑资源的开销；</p>
<p>是锁相环的数量，一共有两个，主要用于分频、倍频和时钟相位的调制；</p>
<p>是全局时钟管脚，一共有10个，全局时钟管脚是连接到全局时钟树上的，能够保证连接到全局时钟树上的时钟信号到达每个寄存器的时间都是相同的。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led026.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led026.png" alt="Led026"></a></p>
<p>图 9‑25 新建工程步骤（六）</p>
<p>这里是选择一些三方的开发工具，我们暂时先不用管，直接点击“Next”。如图 9‑26所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led027.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led027.png" alt="Led027"></a></p>
<p>图 9‑26 新建工程步骤（七）</p>
<p>最后生成整个新工程向导的一个总结，可以验证下是否和自己最初的选择有出入，如果没有问题点击“Finish”。如图 9‑27所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led028.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led028.png" alt="Led028"></a></p>
<p>图 9‑27 新建工程步骤（八）</p>
<p>新建工程完毕后你会在左上角出发现有如下的变化，会显示器件名和顶层设计文件名。如图 9‑28所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led029.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led029.png" alt="Led029"></a></p>
<p>图 9‑28 新建工程完毕</p>
<p>打开quartus_prj文件夹发现里面生成了一些文件夹和文件，led.qpf就是这个工程的工程文件；led.qsf就是工程的配置文件。如图 9‑29所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led030.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led030.png" alt="Led030"></a></p>
<p>图 9‑29 工程文件</p>
<h3 id="2-4-7-RTL代码的编写¶"><a href="#2-4-7-RTL代码的编写¶" class="headerlink" title="2.4.7. RTL代码的编写¶"></a>2.4.7. RTL代码的编写<a href="#rtl" title="永久链接至标题">¶</a></h3><p>在rtl文件夹下新建一个名为led的文本文件，然后重命名为led.v。如图 9‑30所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led031.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led031.png" alt="Led031"></a></p>
<p>图 9‑30 新建代码文本文件</p>
<p>使用Notepad++打开该文件，准备RTL代码的编写。如图 9‑31所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led032.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led032.png" alt="Led032"></a></p>
<p>图 9‑31 打开代码文件</p>
<p>开始RTL代码的编写，RTL代码编写出的模块叫RTL模块（后文中也称功能模块、可综合模块）。之所以叫RTL代码是因为用Verilog HDL在Resistances Transistors Logic（寄存器传输级逻辑）来描述硬件电路，RTL代码能够综合出真实的电路以实现我们设计的功能，区别于不可综 合的仿真代码。（本章的重点是熟悉整个开发流程和软件工具的使用，不进行代码的详细讲解）我们前面讲过，根据波形写代码，这种方法在组合逻辑中表达的不够明显，而且刚开始的例子都很简单，后面我们会用单独的章节来讲解如何根据波形图来实现代码，并在视频课中着重教授大家这种方法。</p>
<table class="highlighttable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="n">led</span>
<span class="p">(</span>
<span class="k">input</span> <span class="kt">wire</span> <span class="n">key_in</span> <span class="p">,</span> <span class="c1">//输入按键</span>

<p><span class="k">output</span> <span class="kt">wire</span> <span class="n">led_out</span> <span class="c1">&#x2F;&#x2F;输出控制led灯</span><br><span class="p">);</span></p>
<p><span class="c1">&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="c1">&#x2F;&#x2F;* Main Code /&#x2F;</span><br><span class="c1">&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="c1">&#x2F;&#x2F;led_out:led灯输出的结果为key_in按键的输入值</span><br><span class="k">assign</span> <span class="n">led_out</span> <span class="o">&#x3D;</span> <span class="n">key_in</span><span class="p">;</span></p>
<p><span class="k">endmodule</span><br></pre></div></td></tr></tbody></table></p>
<p>代码编写好后，需要将led.v文件添加到工程中。点击“File”切换到文件模式，在该模式下可以看到所有属于该工程下的文件。如图 9‑32所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led033.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led033.png" alt="Led033"></a></p>
<p>图 9‑32 添加代码文件步骤（一）</p>
<p>右键点击“File”，并选择“Add&#x2F;Remove File in Project…”，如图 9‑33所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led034.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led034.png" alt="Led034"></a></p>
<p>图 9‑33 添加代码文件步骤（二）</p>
<p>如图 9‑34所示，在“File name:”栏选择添加已经写好的.v文件，找到“ledrtl”路径下的“led.v”。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led035.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led035.png" alt="Led035"></a></p>
<p>图 9‑34 添加代码文件步骤（三）</p>
<p>打开后如图所示，点击“Add”添加到工程中，如图 9‑35所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led036.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led036.png" alt="Led036"></a></p>
<p>图 9‑35 添加代码文件步骤（四）</p>
<p>点击“OK”完成添加。如图 9‑36所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led037.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led037.png" alt="Led037"></a></p>
<p>图 9‑36 添加代码文件步骤（五）</p>
<p>添加后如图 9‑37所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led038.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led038.png" alt="Led038"></a></p>
<p>图 9‑37 添加代码文件步骤（六）</p>
<h3 id="2-4-8-代码的分析和综合¶"><a href="#2-4-8-代码的分析和综合¶" class="headerlink" title="2.4.8. 代码的分析和综合¶"></a>2.4.8. 代码的分析和综合<a href="#id10" title="永久链接至标题">¶</a></h3><p>点击如图 9‑38所示的图标进行代码的分析和综合，该步骤的目的是首先检查语法是否有错，其次是综合器将代码解释为电路的形式。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led039.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led039.png" alt="Led039"></a></p>
<p>图 9‑38 代码的分析和综合图（一）</p>
<p>如图 9‑39所示，只有红色框内为绿色，说明分析与综合完成，并没有语法错误产生。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led040.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led040.png" alt="Led040"></a></p>
<p>图 9‑39 代码的分析和综合图（二）</p>
<h3 id="2-4-9-RTL视图的查看¶"><a href="#2-4-9-RTL视图的查看¶" class="headerlink" title="2.4.9. RTL视图的查看¶"></a>2.4.9. RTL视图的查看<a href="#id11" title="永久链接至标题">¶</a></h3><p>双击“Netlist Viewers”下的“RTL Viewer”，如图 9‑40所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led041.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led041.png" alt="Led041"></a></p>
<p>图 9‑40 RTL视图的查看</p>
<p>打开后的界面如图所示，这就是我们设计的硬件电路结构，可见输入是key_in，然后通过一根线连接到输出led_out，和我们设计所表达的意思相同，如图 9‑41所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led042.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led042.png" alt="Led042"></a></p>
<p>图 9‑41 RTL视图</p>
<h3 id="2-4-10-Testbench的原理¶"><a href="#2-4-10-Testbench的原理¶" class="headerlink" title="2.4.10. Testbench的原理¶"></a>2.4.10. Testbench的原理<a href="#testbench" title="永久链接至标题">¶</a></h3><p>Testbench是测试脚本，测试谁？当然是测试我们用硬件描述语言（HDL）设计的电路，测试设计电路的整体功能、部分性能是否与预期的目标相符。有些初学者没有养成编写Testbench的习惯，总以为这是繁琐的、无用的，或者他们习惯用在线逻辑分析仪器来调试，其实不然，当你在编写大型工程代码的时候，综合一 次所用的时间少则十几分钟，多则几个小时，这种无用时间的消耗是我们所不允许的，在线逻辑分析仪虽然好用但是每修改一次代码我们就看结果就要综合一次，并不能节省时间，而使用Testbench做仿真的速度就很快，修改后即可马上看到结果，从而节省了我们大量的开发时间，所以大家务必养成从学习FPGA的一开始就编写 Testbench的好习惯。</p>
<p>编写 Testbench 进行测试的过程如下：</p>
<ol>
<li><p>产生模拟激励（输入波形）；</p>
</li>
<li><p>将产生的激励加入到被测试模块并观察其输出响应；</p>
</li>
<li><p>将输出响应与期望进行比较，从而判断设计的正确性。</p>
</li>
</ol>
<p>接下来就是仿真激励Testbench的编写，首先给大家介绍下Testbench的原理。</p>
<p>我们通常给Testbench的取名是在被测试的模块名前加个tb_（也可以在被测试的模块名后面加_tb），容易识别出具体验证的是哪个模块。如图 9‑42所示：蓝色的框中的区域就表示一个测试系统，我们要写的Testbench就是用代码实现该区域的功能，这个功能是只针对待测试led模块，如果换成其他的模块，需要在单独设计专门针对其他待测试系统的Testbench。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led043.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led043.png" alt="Led043"></a></p>
<p>图 9‑42 Testbench框图（一）</p>
<p>第二步是将待测试led模块放到tb_led模块框架中，如图 9‑43所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led044.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led044.png" alt="Led044"></a></p>
<p>图 9‑43 Testbench框图（二）</p>
<p>第三步是将两个模块进行连线，如图 9‑44所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led045.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led045.png" alt="Led045"></a></p>
<p>图 9‑44 Testbench框图（三）</p>
<p>tb_led模块和led模块的关系就是上面这种关系，但是我们需要怎么设计tb_led模块呢？我们需要做的就是希望tb_led模块能够产生key_in信号，然后这个信号通过led模块从led_out输出，我们观察led_out输出的信号是不是和最初设计的波形一致，如果严格一致则说明设计正确，代码综合布 局布线后下载到上板中能够正常工作的可能性越高，为什么说是越高而不是100%能够正常工作，是因为在高速系统中有时候逻辑仿真是对的，但是下载到板上依然不可以正常工作，其原因是因为逻辑并没有问题，真正的问题是在高速系统中往往需要进行时序约束，否则会由于系统工作太快导致时序违例，同样不能够正常工作。</p>
<p>可能大家还听说过后仿真（也称为时序仿真），我们为什么没做这个呢，做了是不是就能够保证下板后功能是100%正确的呢？答案是依然不能，虽然正确率可以相比于只做了逻辑仿真提高了，但是还是会存在下板后有问题的可能，而且后仿真的速度特别慢，所以我们干脆就不做这一步了，如果做了逻辑仿真后下板后仍有问题，我们可以 使用在线逻辑分析仪实时的对信号抓取确定是不是时序的问题，如果是时序的问题还要对系统进行静态时序分析（SAT）针对具体违例的时序加以约束。这样一说后仿真是不是没什么用了，当然也不是，前面我们讲过FPGA可以用在数字IC领域中，在数字IC的设计和验证中，往往要加入各种仿真延时文件，进行后仿真，但是本教程 不涉及数字IC的内容，因为数字IC虽然和FPGA相关，但又是一个全新的世界，如果个人想了解数字IC设计和验证或者以后想从事数字IC相关行业的工作可以在学习本教程后再继续深入学习。</p>
<h3 id="2-4-11-Testbench代码的编写¶"><a href="#2-4-11-Testbench代码的编写¶" class="headerlink" title="2.4.11. Testbench代码的编写¶"></a>2.4.11. Testbench代码的编写<a href="#id12" title="永久链接至标题">¶</a></h3><p>先在sim文件夹下新建一个名为tb_led的文本文件，然后重命名为tb_led.v。如图 9‑45所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led046.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led046.png" alt="Led046"></a></p>
<p>图 9‑45 新建仿真文件</p>
<p>使用Notepad++打开该文件，准备Testbench代码的编写。如图 9‑46所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led047.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led047.png" alt="Led047"></a></p>
<p>图 9‑46 仿真文件的编写</p>
<p>开始Testbench代码的编写（本章的重点是熟悉整个开发流程和软件工具的使用，不进行代码的详细讲解），此编写技巧和方法我们也会在后面的章节和视频课中详细讲解。</p>
<table class="highlighttable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="no">`timescale</span> <span class="mh">1</span><span class="n">ns</span><span class="o">/</span><span class="mh">1</span><span class="n">ns</span>
<span class="n">odule</span> <span class="n">tb_led</span><span class="p">();</span>

<p><span class="c1">&#x2F;&#x2F;&#x2F;</span><br><span class="o">&#x2F;</span><span class="n">*</span> <span class="n">Parameter</span> <span class="k">and</span> <span class="n">Internal</span> <span class="n">Signal</span> <span class="n">/&#x2F;</span><br><span class="c1">&#x2F;&#x2F;&#x2F;</span><br><span class="o">&#x2F;</span><span class="kt">wire</span> <span class="n">define</span><br><span class="n">ire</span> <span class="n">led_out</span> <span class="p">;</span></p>
<p><span class="c1">&#x2F;&#x2F;reg define</span><br><span class="kt">reg</span> <span class="n">key_in</span> <span class="p">;</span></p>
<p><span class="c1">&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="c1">&#x2F;&#x2F;* Main Code /&#x2F;</span><br><span class="c1">&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="c1">&#x2F;&#x2F;初始化输入信号</span><br><span class="k">initial</span> <span class="n">key_in</span> <span class="o">&lt;&#x3D;</span> <span class="mh">1</span><span class="mb">‘b0</span><span class="p">;</span></p>
<p><span class="c1">&#x2F;&#x2F;key_in:产生输入随机数，模拟按键的输入情况</span><br><span class="k">always</span> <span class="p">#</span><span class="mh">10</span> <span class="n">key_in</span> <span class="o">&lt;&#x3D;</span> <span class="p">{</span><span class="nb">$random</span><span class="p">}</span> <span class="o">%</span> <span class="mh">2</span><span class="p">;</span> <span class="cm">&#x2F;<em>取模求余数，产生非负随机数0、1</span><br><span class="cm">每隔10ns产生一次随机数</em>&#x2F;</span></p>
<p><span class="c1">&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="c1">&#x2F;&#x2F;* Instantiate /&#x2F;</span><br><span class="c1">&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="c1">&#x2F;&#x2F;————- led_inst ————-</span><br><span class="n">led</span> <span class="n">led_inst</span><br><span class="p">(</span><br><span class="p">.</span><span class="n">key_in</span> <span class="p">(</span><span class="n">key_in</span> <span class="p">),</span> <span class="c1">&#x2F;&#x2F;input key_in</span></p>
<p><span class="p">.</span><span class="n">led_out</span><span class="p">(</span><span class="n">led_out</span><span class="p">)</span> <span class="c1">&#x2F;&#x2F;output led_out</span><br><span class="p">);</span></p>
<p><span class="k">endmodule</span><br></pre></div></td></tr></tbody></table></p>
<p>代码编写好后，需要将tb_led.v文件添加到工程中。点击“File”切换到文件模式，在该模式下可以看到所有属于该工程下的文件。如图 9‑47所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led048.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led048.png" alt="Led048"></a></p>
<p>图 9‑47 工程测试文件的添加（一）</p>
<p>右键点击“File”，并选择“Add&#x2F;Remove File in Project…”。如图 9‑48所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led049.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led049.png" alt="Led049"></a></p>
<p>图 9‑48 工程测试文件的添加（二）</p>
<p>如图 9‑49所示，在“File name:”栏选择添加已经写好的.v文件，找到“ledsim”路径下“tb_led.v”。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led050.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led050.png" alt="Led050"></a></p>
<p>图 9‑49 工程测试文件的添加（三）</p>
<p>打开后如图所示，点击“Add”添加到工程中，如图 9‑50所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led051.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led051.png" alt="Led051"></a></p>
<p>图 9‑50 工程测试文件的添加（四）</p>
<p>点击“OK”完成添加。如图 9‑51所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led052.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led052.png" alt="Led052"></a></p>
<p>图 9‑51 工程测试文件的添加（五）</p>
<p>添加完成后如图 9‑52所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led053.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led053.png" alt="Led053"></a></p>
<p>图 9‑52 工程测试文件的添加（六）</p>
<h3 id="2-4-12-仿真设置¶"><a href="#2-4-12-仿真设置¶" class="headerlink" title="2.4.12. 仿真设置¶"></a>2.4.12. 仿真设置<a href="#id13" title="永久链接至标题">¶</a></h3><p>首先打开“Assignments”下的“Setting…”，如图 9‑53所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led054.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led054.png" alt="Led054"></a></p>
<p>图 9‑53 仿真设置（一）</p>
<p>然后选择“EDA Tool Settings”下的“Simulation”，如图 9‑54所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led055.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led055.png" alt="Led055"></a></p>
<p>图 9‑54 仿真设置（二）</p>
<p>如图 9‑55所示：框中“Tool name:”栏选择“ModelSim”，“ModelSim”就是独立的ModelSim，而“ModelSim-Altera”是安装QuartusII时自带的ModelSim；框中“Format for output netlist:”栏是选择输出网表的语言格式，该网表主要用于后仿真，因为我们在逻辑设计中往往不做后仿真，所以这里默认即可；框中“Time scale:”栏是选择输出网表的时间单位，所以也默认即可；选择框中的“Output direction:”选择输出网表的位置，这里我们默认即可。默认后即可在工程目录下产生一个名为simulation的文件夹，里面还有一个名为modelsim的子文件夹，这里不仅存放输出的网表文件，还存放了后面当ModelSim运行仿真后所产生的相关文件。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led056.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led056.png" alt="Led056"></a></p>
<p>图 9‑55 仿真设置（三）</p>
<h3 id="2-4-13-NativeLink的设置¶"><a href="#2-4-13-NativeLink的设置¶" class="headerlink" title="2.4.13. NativeLink的设置¶"></a>2.4.13. NativeLink的设置<a href="#nativelink" title="永久链接至标题">¶</a></h3><p>基于 NativeLink的设计就是在QuartusII中设置好一些参数后直接打开ModeSim软件可以立刻看到仿真的结果，可谓是一键操作式的仿真，十分方便。</p>
<p>先选择“NativeLink setting:”的“Comple test bench:”（如果设计了多个Testbench可以在该栏进行选择），然后点击后面的“Test Benches…”。如图 9‑56所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led057.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led057.png" alt="Led057"></a></p>
<p>图 9‑56 NativeLink设置（一）</p>
<p>直接点击“New…”，如图 9‑57所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led058.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led058.png" alt="Led058"></a></p>
<p>图 9‑57 NativeLink设置（二）</p>
<p>如图 9‑58所示：框“Test bench name:”就是前面“Comple test bench:”框中的名字，也就是上图中新建的这个Test Benches的名字（一般情况下框和框的名字保持一致即可）；框“Top level module in test bench:”是Testbench顶层的名字，这里只有一个层次那就是图 9‑59所示中的名字tb_led；是“End simulstion at:”是设置打开ModelSim时波形运行多久后停止，如果这里不设置就需要在仿真代码中仿真完毕的地方添加“$stop”代码暂停仿真，或者在弹出的ModelSi m界面中按暂停按钮，否则ModelSim会一直运行。我们设置的是1us，这个时间不长不短刚刚好，即打开ModelSim后运行1us后波形停止运行，如果所需要观察的波形1us时刻之后，可以在ModelSim中再设置运行时间后继续运行；框“File name:”选择sim文件夹下的tb_led.v文件。都设置好后点击“Add”将tb_led.v文件添加进来。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led059.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led059.png" alt="Led059"></a></p>
<p>图 9‑58 NativeLink设置（三）</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led060.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led060.png" alt="Led060"></a></p>
<p>图 9‑59 Testbench顶层名</p>
<p>设置好后点击“OK”，如图 9‑60所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led061.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led061.png" alt="Led061"></a></p>
<p>图 9‑60 NativeLink设置（四）</p>
<p>继续点击“OK”，如图 9‑61所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led062.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led062.png" alt="Led062"></a></p>
<p>图 9‑61 NativeLink设置（五）</p>
<p>最后这里点击“OK”，完成NativeLink的设置，如图 9‑62所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led063.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led063.png" alt="Led063"></a></p>
<p>图 9‑62 NativeLink设置完成</p>
<h3 id="2-4-14-打开ModelSim观察波形¶"><a href="#2-4-14-打开ModelSim观察波形¶" class="headerlink" title="2.4.14. 打开ModelSim观察波形¶"></a>2.4.14. 打开ModelSim观察波形<a href="#modelsim" title="永久链接至标题">¶</a></h3><p>因为第一个led工程实例相对简单，使用到ModelSim中的也是一些基本操作，所以本节只会对ModelSim软件的部分功能的使用进行讲解。但后期随着工程实例复杂度的提高，我们将会用到ModelSim中更高级的功能，那时再做详细讲解。</p>
<p>点击“Toos”下的“Run Simulation Tool”下的“RTL Simulaton”打开ModelSim进行功能仿真（因为主要是验证逻辑的正确性也称逻辑仿真）。如图 9‑63所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led064.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led064.png" alt="Led064"></a></p>
<p>图 9‑63 ModelSim仿真（一）</p>
<p>如果能够成功打开如下界面说明ModelSim破解和关联QuartusII都正确。如图 9‑64所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led065.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led065.png" alt="Led065"></a></p>
<p>图 9‑64 ModelSim仿真（二）</p>
<p>完全打开后的界面如图所示，会发现在Wave窗口有波形显示出来，如图 9‑65所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led066.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led066.png" alt="Led066"></a></p>
<p>图 9‑65 ModelSim仿真（三）</p>
<p>点击箭头处，把显示波形的界面单独打开，如图 9‑66所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led067.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led067.png" alt="Led067"></a></p>
<p>图 9‑66 ModelSim仿真（四）</p>
<p>点击图 9‑67中的放大镜图标显示如图 9‑68所示的全部仿真时间的波形，波形最后结束的位置对应的时间如图 9‑69所示在1000ns处，也就是1us，和图 9‑58中设置的结果是一致的。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led068.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led068.png" alt="Led068"></a></p>
<p>图 9‑67 ModelSim仿真（五）</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led069.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led069.png" alt="Led069"></a></p>
<p>图 9‑68 ModelSim仿真（六）</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led070.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led070.png" alt="Led070"></a></p>
<p>图 9‑69 ModelSim仿真（七）</p>
<p>如图 9‑70所示：点击框中第一个按钮即添加参考线（图 9‑71中黄色的线即是参考线），点击第二个按钮即去掉参考线。当鼠标在波形界面中点击时，参考线也会指定到该位置，如果有两条黄色参考线时，会两条参考线之间的显示时间差（如图 9‑72所示）。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led071.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led071.png" alt="Led071"></a></p>
<p>图 9‑70 ModelSim仿真（八）</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led072.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led072.png" alt="Led072"></a></p>
<p>图 9‑71 ModelSim仿真（九）</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led073.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led073.png" alt="Led073"></a></p>
<p>图 9‑72 ModelSim仿真（十）</p>
<p>点击图 9‑73左下角处的“小锁”即可固定参考线，被固定的参考线显示红色（添加和删减参考线也可以通过“小锁”旁边的“+”、“-”号实现）</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led074.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led074.png" alt="Led074"></a></p>
<p>图 9‑73 ModelSim仿真（十一）</p>
<p>为了更好地观察分析ModelSim仿真出的波形有以下几处按钮会用到。如图 9‑74所示：其中框中的图标是波形复位，点击后会出现如图 9‑75所示的框，我们直接点击“OK”即可对界面的波形进行全部清空；</p>
<p>框是设置运行一次仿真的时间，根据实际观察波形的需要填写相应的时间。但仿真的时间越久所需要等待的时间也会越久，所生成的仿真文件也会越大；</p>
<p>框中的第一个图标是运行左边设置的时间值，图中显示的是100ps，那么点击一次就运行100ps，运行完100ps后就会自动停止，也可以手动输入其他的时间单位和时间值。框中的第二个和第三个图标点击一次后波形会一直运行下去，直到点击第四个和第五个按钮时才会停止；</p>
<p>框中的图标分别是波形的下降沿定位和上升沿定位，当选中要观察的信号时，再点击这两个按钮时参考线就可以立刻定位到该信号的下降沿或上升沿，再次点击即跳到下一个下降沿或上升沿；</p>
<p>框中的第一个和第二个图标分别是波形方大和缩小（波形的放大缩小也可以按住键盘上的“Ctrl”键同时滚动鼠标滚轮）。第三个图标是全局波形显示。第四个图标作用是将参考线位置处的波形进行放大。第五个图标的作用是将参考线处的波形移动到波形显示窗口的最开头处。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led075.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led075.png" alt="Led075"></a></p>
<p>图 9‑74 ModelSim仿真（十二）</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led076.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led076.png" alt="Led076"></a></p>
<p>图 9‑75 ModelSim仿真（十三）</p>
<p>图 9‑76可以看出在参考线处key_in的值为16进制表示的1’h0，根据需要我们还可以设置为其他格式显示。如图 9‑77所示，鼠标右击信号名字“key_in”，选择“Radix”后会看到各种不同进制格式的显示方式，可以根据需要任意选择。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led077.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led077.png" alt="Led077"></a></p>
<p>图 9‑76 ModelSim仿真（十四）</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led078.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led078.png" alt="Led078"></a></p>
<p>图 9‑77 ModelSim仿真（十五）</p>
<h3 id="2-4-15-仿真波形分析¶"><a href="#2-4-15-仿真波形分析¶" class="headerlink" title="2.4.15. 仿真波形分析¶"></a>2.4.15. 仿真波形分析<a href="#id14" title="永久链接至标题">¶</a></h3><p>我们使用ModelSim仿真出来波形后可以直接观察出波形和预期之间的正确性，因为这个项目工程比较简单，只有两个信号，也没有内部信号，也不容易出错，所以可以直接分析得出，但是试想一下，如果有上百个信号，然后最后的输出结果还出现了错误，那你凭着自己的理解和观察就很难进行判断了，所以我们一开始就养成良好的 学习习惯，将ModelSim仿真出来的波形图和之前用根据自己理解用Visio画出来的波形图进行对比，既可以发现之前对整体设计的理解错误又能够方便的进行改错。</p>
<p>通过对比图 9‑78和图 9‑79发现两个图输入输出之间的关系是一模一样的（这里的一样不是说Visio波形中的key_in信号和ModelSim波形中的key_in信号都是先高后低的关系，而是Visio波形中的key_in信号和led_out之间的关系对应与ModelSim波形中的key_in信号和 led_out之间的关系是否一致），都是输入信号key_in与输出信号led_out相同，说明代码的设计结果符合预期的想法，可以进行下一步操作了。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led015.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led015.png" alt="Led015"></a></p>
<p>图 9‑78 ModelSim仿真（十六）</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led079.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led079.png" alt="Led079"></a></p>
<p>图 9‑79 ModelSim仿真（十七）</p>
<h3 id="2-4-16-引脚约束¶"><a href="#2-4-16-引脚约束¶" class="headerlink" title="2.4.16. 引脚约束¶"></a>2.4.16. 引脚约束<a href="#id15" title="永久链接至标题">¶</a></h3><p>仿真结束后即验证了代码设计的正确性，也就是说可以进行上板验证了，但是在上板之前还需要进行引脚约束，就是根据硬件原理图确定按键和led分别与FPGA芯片的哪个引脚对应。由原理图知上板上一共有四个普通按键和四个led灯我们选择其中一对按键和led灯，按键选择连接的FPGA管脚为M2，led灯选择连接的F PGA管脚为L7。</p>
<p>点击如图 9‑80所示按钮，打开管脚绑定界面。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led080.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led080.png" alt="Led080"></a></p>
<p>图 9‑80 管脚分配图（一）</p>
<p>打开后的界面如图 9‑81所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led081.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led081.png" alt="Led081"></a></p>
<p>图 9‑81 管脚分配图（二）</p>
<p>管脚绑定在数目比较少的情况下有两种方法（管脚数目特别多的时候用其他方法，后面章节会单独介绍），一种是在的“Location”列“key_in”行输入“M2”，在“led_out”行输入“L7”然后按回车键确定。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led082.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led082.png" alt="Led082"></a></p>
<p>图 9‑82 管脚分配图（三）</p>
<p>另一种方法是直接鼠标左键按住图 9‑83信号的名字，将其拖动到图 9‑84需要绑定的管脚上即可。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led083.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led083.png" alt="Led083"></a></p>
<p>图 9‑83 管脚分配图（四）</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led084.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led084.png" alt="Led084"></a></p>
<p>图 9‑84 管脚分配图（五）</p>
<p>绑定完后的管脚状态如图 9‑85所示，其中：</p>
<ol>
<li><p>Node Name：RTL代码中定义的端口名字。</p>
</li>
<li><p>Direction：管脚的输入输出方向。</p>
</li>
<li><p>Location：管脚绑定的位置。</p>
</li>
<li><p>I&#x2F;O Bank：用于支持对应不同的电平标准，即VCCIO。每个Bank只能有一种电压标准，一般情况下选择默认值就好。一种颜色下的I&#x2F;O口代表一组Bank。当管脚的Location约束完成以后，I&#x2F;O Bank会自动进行填充。</p>
</li>
<li><p>VREF Group：Bank内部的细分区域，非修改属性，会自动填充。</p>
</li>
</ol>
<p>(6) I&#x2F;O Standard：对管脚内部的I&#x2F;O进行不同的电平约束。FPGA I&#x2F;O的电压由I&#x2F;O Bank上的VCC引入，一个Bank上如果引入了3.3V的 TTL电平，那么此时整个Bank上输出3.3V的TTL电平。设置好以后工具可以结合Current Strength一起计算功率。如果没有特殊要求默认即可。</p>
<ol start="7">
<li><p>Reserved：这个是对管脚内部的I&#x2F;O逻辑进行约束的，这个约束的是FPGA在I&#x2F;O端的输入输出区域的逻辑。无特殊要求可以为空。</p>
</li>
<li><p>Current Strength：是驱动电流强度，一般选择默认值。如果需要驱动大功率的电路，可以在FPGA外围加驱动电路。</p>
</li>
<li><p>Slew Rate：是电压转换速率，表示单位时间内电压升高的幅值，跟信号跳变时间有关，一般选择默认值。</p>
</li>
<li><p>Differential Pair：差分管脚。</p>
</li>
<li><p>Filter：通过过滤选项显示指定种类的管脚。</p>
</li>
</ol>
<p>所有管脚配置完成后就可以关闭当前界面了。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led085.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led085.png" alt="Led085"></a></p>
<p>图 9‑85 管脚状态</p>
<p>全编译 ^^^</p>
<p>全编译和分析综合的不同是全编译需要进行布局布线，管脚绑定后就可以对全局进行布局布线了。点击如图 9‑86所示的按钮进行全部的分析综合布局布线。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led086.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led086.png" alt="Led086"></a></p>
<p>图 9‑86 编译过程（一）</p>
<p>如图 9‑87所示：框是综合后的资源使用率报告；</p>
<p>框是综合后提示的错误警告数，这里没有错误，只有警告和严重警告存在，一共7个；</p>
<p>框是编译时每一步详细的过程，包括执行每一个部分所使用的具体时间，从上到下顺序执行，第一个是之前进行过的分析与综合，第二个是布局和布线，第三个是生成程序文件，第四个是静态时序分析，第五个是写入网表，这5个步骤编译后都是自动完成的不需要进行干涉，如果后期自动完成不能满足需求是需要手动进行设置以实现优化；</p>
<p>框中从左往右依次是错误、严重警告、警告，只要不出现错误就暂时先不用管，当警告或者严重警告影响功能时再去分析；</p>
<p>框是编译的总进度；</p>
<p>框是在编译过程中实时显示的时间，该时间随着工程量对增大而增大，硬件的编译一次的时间是非常慢的，不像软件那样瞬间就完成了，所以这也是需要进行仿真的原因之一。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led087.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led087.png" alt="Led087"></a></p>
<p>图 9‑87 编译过程（二）</p>
<p>我们故意设置个错误，将第8行key_in后面的分号去掉（如图 9‑88所示），再进行综合。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led088.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led088.png" alt="Led088"></a></p>
<p>图 9‑88 编译过程（三）</p>
<p>编译后的结果如图 9‑89所示：框中提示有三个错误，其实我们只修改了一个地方，却提示三个错误，所以提示的错误数，并不是你真的有这么多个的错误，所以遇到提示很多错误的时候不到担心惧怕，很可能你修改了一处后错误一下子会减少很多。经验再久的工程师写代码时也难免会出现语法错误，初学者犯语法错误的更是常见的事 情，凡是这种由语法导致的错误都是最容易修改的；框处前会有个“×”号，因为有语法错误，所以分析和综合失败；框是具体的错误提示处，提示第9行附近有错误，然后双击该错误提示语句就会立刻定位到错误位置附近，我们发现第9行没有问题，那就是第9行之前有问题，我们在第7行发现key_in后缺少一个分号，所以添加上 分号再进行重新编译即可。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led089.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led089.png" alt="Led089"></a></p>
<p>图 9‑89 编译过程（四）</p>
<h3 id="2-4-17-通过JTAG将网表下载到开发板¶"><a href="#2-4-17-通过JTAG将网表下载到开发板¶" class="headerlink" title="2.4.17. 通过JTAG将网表下载到开发板¶"></a>2.4.17. 通过JTAG将网表下载到开发板<a href="#jtag" title="永久链接至标题">¶</a></h3><p>如图 9‑90所示，开发板连接5V直流电源，USB-Blaster下载器JTAG端连接开发板JTAG接口，另一端连接电脑USB接口。线路正确连接后，打开开关为板卡上电。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led090.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led090.png" alt="Led090"></a></p>
<p>图 9‑90 程序下载连线图</p>
<p>点击图 9‑91所示的图标，打开下载界面。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led091.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led091.png" alt="Led091"></a></p>
<p>图 9‑91 下载过程（一）</p>
<p>打开下载界面如图 9‑92所示：框是硬件连接设置，当前显示的是“No Hardware”即没有连接到硬件，我们需要选择连接的硬件是USB-Blaster，点击“Hardware Setup…”，在弹出的界面中（如图 9‑93所示）的“Currently selected hardware:”选择“USB-Blaster[USB-0]”，然后点击“Close”，此时会发现框处发生变化如图 9‑92所示“Hardware Setup…”处已经变成了“USB- Blaster[USB-0]”；框是选择下载的方式，我们选择“JTAG”下载模式；框是下载的进度表，下载成功后会在框内显示绿色并出现“100%(Successful)”；框是下载的文件，这里是“led.sof”文件。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led092.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led092.png" alt="Led092"></a></p>
<p>图 9‑92 下载过程（二）</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led093.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led093.png" alt="Led093"></a></p>
<p>图 9‑93 下载过程（三）</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led094.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led094.png" alt="Led094"></a></p>
<p>图 9‑94 下载过程（四）</p>
<p>如图 9‑95所示若没有“.sof”文件，点击“Add File…”，选择“ledquartus_prjoutput_files”路径下的“led.sof”后点击“Open”，如图 9‑96所示。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led095.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led095.png" alt="Led095"></a></p>
<p>图 9‑95 下载过程（五）</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led096.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led096.png" alt="Led096"></a></p>
<p>图 9‑96 下载过程（六）</p>
<p>当设置完成所有的下载设置后，即可点击图 9‑97所示的“Start”，然后等带下载过程，此过程十分快，下载完成后发现“Progress:”处显示绿色，并出现如图 9‑98所示的“100%(Successful)”，说明下载成功。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led097.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led097.png" alt="Led097"></a></p>
<p>图 9‑97 下载过程（七）</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led098.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led098.png" alt="Led098"></a></p>
<p>图 9‑98 下载过程（八）</p>
<p>下载完成后即可按下管脚绑定的按键，会发现同时被绑定的led随着按键的按下会被点亮，而按键松开时又熄灭，实现了我们最初预想的设计，如图 9‑99所示。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led099.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led099.png" alt="Led099"></a></p>
<p>图 9‑99 上板效果图</p>
<p>注意：尽量不要带电插拔 JTAG 口，否则容易烧坏 FPGA 的 JTAG 口。如果用万用表测到 JTAG 号 TDI TDO TMS TCK 任意一个与地短路了，那你的 FPGA 可能已经被烧坏了。并不是每次热插拔 JTAG 口都一定会烧坏，但是至少会有一定烧坏的可能性，为了能让开发板陪伴我们学习完本教程，所以最好谨慎行事！</p>
<h3 id="2-4-18-未使用管脚的默认设置¶"><a href="#2-4-18-未使用管脚的默认设置¶" class="headerlink" title="2.4.18. 未使用管脚的默认设置¶"></a>2.4.18. 未使用管脚的默认设置<a href="#id16" title="永久链接至标题">¶</a></h3><p>我们使用的开发板上面有很多功能，在做一个个例子的时候不可能同时全部用上所有的FPGA管脚，而在Quartus软件中默认未使用管脚的状态为弱上拉输入，所以未使用到的管脚上也是有电压的，只是驱动能力很弱，这往往会导致一些不安全的隐患，所以我们需要将未使用管脚的状态设置为三态输入。具体操作如下：</p>
<p>如图 9‑100所示，鼠标右击“Cyclone IV E: EP4CE10F17C8”选择“Device…”。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led100.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led100.png" alt="Led100"></a></p>
<p>图 9‑100 管脚的默认设置（一）</p>
<p>在打开的界面中（如图 9‑101所示）点击“Device and Pin Options…” 。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led101.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led101.png" alt="Led101"></a></p>
<p>图 9‑101 管脚的默认设置（二）</p>
<p>在打开的界面中（如图 9‑102所示）选择“Unused Pins”，在“Reserve all unused pins:”框中发现默认的设置是“As input tri-stated weak pull-up”即弱上拉输入，意思是所有没有定义的引脚，都作为输入引脚，并附加弱上拉电阻。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led102.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led102.png" alt="Led102"></a></p>
<p>图 9‑102 管脚的默认设置（三）</p>
<p>我们在“Reserve all unused pins:”框中选择“As input tri-stated”即三态输入，然后点击“OK”完成设置，如图 9‑103、图 9‑104所示。在本例中，默认的选择 “As input tr-stated with week pull- up”是一个安全的选项，除此之外，“As input tri-stated”等也是安全的选项。但是“ As output driving ground ”是一个危险选项，意思是未用到的 FPGA 引脚会被下拉到地。危险在于如果这些引脚在被 PCB 上的外围电路上拉到高电位，则可能会产生一个强烈的灌入电流，可能会烧毁 FPGA的引脚。因此为了避免经济损失，无论如何请你注意一下这里的选择，不要莫名其妙地把 FPGA烧坏了。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led103.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led103.png" alt="Led103"></a></p>
<p>图 9‑103 管脚的默认设置（四）</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led104.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led104.png" alt="Led104"></a></p>
<p>图 9‑104 管脚的默认设置（五）</p>
<p>未使用的管脚状态设置完成后需要重新编译才能够进行映射。点击全编译按钮，会弹出一个对话框，当下载界面被修改（如图 9‑105所示）或者关闭时（如图 9‑106所示）会提示是否保存原下载界面的设置，这里我们不保存，所以点击“No”，如果个人需要保存点击“Yes”后重命名备注好即可。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led105.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led105.png" alt="Led105"></a></p>
<p>图 9‑105 管脚的默认设置（六）</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led106.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led106.png" alt="Led106"></a></p>
<p>图 9‑106 管脚的默认设置（七）</p>
<h3 id="2-4-19-程序的固化¶"><a href="#2-4-19-程序的固化¶" class="headerlink" title="2.4.19. 程序的固化¶"></a>2.4.19. 程序的固化<a href="#id17" title="永久链接至标题">¶</a></h3><p>为什么网表下载后还要再进行固化呢？当你把下载网表的上板断电后再重新上电发现之前的功能已经不存在了，也就是说下载后的网表消失了。为什么会这样子呢，很多人不禁问道，其实我们使用的这款FPGA芯片是基于SRAM的结构，即下载后的网表存储在FPGA内部的SRAM中，我们也知道SRAM有掉电易失的特性，这也就 是我们为什么掉电后功能就消失的原因。所以我们要想使网表重新上电后仍然存在就需要将网表存储到片外的flash中，flash芯片型号为WinBond 25Q16，存储容量为16Mbit（2M字节），采用SPI协议和FPGA进行通信，可做为FPGA的配置芯片（完全兼容EPCS16芯片），以保证FPGA在重新上电后仍能继续工作。具体操作如下：</p>
<p>点击“File”下的“Convert Programming Files…”，如图 9‑107所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led107.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led107.png" alt="Led107"></a></p>
<p>图 9‑107 程序的固化（一）</p>
<p>打开后的界面如图 9‑108所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led108.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led108.png" alt="Led108"></a></p>
<p>图 9‑108 程序的固化（二）</p>
<p>“Programming file type:”栏是选择输出文件的类型，我们选择“JTAG Indirect ConfIguration File(.jic)”，如图 9‑109所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led109.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led109.png" alt="Led109"></a></p>
<p>图 9‑109 程序的固化（三）</p>
<p>“Configuration device:”栏是flash的型号，我们选择“EPCS16”，如图 9‑110所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led110.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led110.png" alt="Led110"></a></p>
<p>图 9‑110 程序的固化（四）</p>
<p>“File name:”栏是选择输出.jic文件的位置，“ledquartus_prjoutput_files”，并重命名为“led.jic”，如图 9‑111所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led111.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led111.png" alt="Led111"></a></p>
<p>图 9‑111 程序的固化（五）</p>
<p>如图 9‑112所示，点击“Input files to convert”框中的“Flash Loader”后会发现“Add Device…”从不能被选择的情况下可以被选择，然后点击“Add Device…”</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led112.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led112.png" alt="Led112"></a></p>
<p>图 9‑112 程序的固化（六）</p>
<p>如图 9‑113所示，选择我们使用的FPGA芯片所属的型号，在“Device family”框中将“Cyclone IV E”前的括号勾选上，在“Device name”框中将“EP4CE10”前的括号勾选上，然后点击“OK”。添加后如图 9‑114所示。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led113.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led113.png" alt="Led113"></a></p>
<p>图 9‑113 程序的固化（七）</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led114.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led114.png" alt="Led114"></a></p>
<p>图 9‑114 程序的固化（八）</p>
<p>如图 9‑115所示，点击“Input files to convert”框中的“Sof Data”后会发现“Add File…”可以被选择，然后点击“Add File…”。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led115.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led115.png" alt="Led115"></a></p>
<p>图 9‑115 程序的固化（九）</p>
<p>因为“led.jic”文件的生成需要“led.sof”文件的参与，所以选择路径“ledquaruts_prjoutput_files”下的“led.sof”文件后点击“Open”，如图 9‑116所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led116.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led116.png" alt="Led116"></a></p>
<p>图 9‑116 程序的固化（十）</p>
<p>选择“led.sof”文件后如图 9‑117所示，然后点击“Generate”生成“led.jic”文件</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led117.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led117.png" alt="Led117"></a></p>
<p>图 9‑117 程序的固化（十一）</p>
<p>如图 9‑118所示，“led.jic”文件生成成功，点击“OK”。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led118.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led118.png" alt="Led118"></a></p>
<p>图 9‑118 程序的固化（十二）</p>
<p>然后点击“Close”关闭该界面，如图 9‑119示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led119.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led119.png" alt="Led119"></a></p>
<p>图 9‑119 程序的固化（十三）</p>
<p>回到下载界面，右击“led.sof”，点击“Delete”将其删除。如图 9‑120所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led120.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led120.png" alt="Led120"></a></p>
<p>图 9‑120 程序的固化（十四）</p>
<p>点击“Add File…”将“led.jic”文件添加进来，如图 9‑121所示：</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led121.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led121.png" alt="Led121"></a></p>
<p>图 9‑121 程序的固化（十五）</p>
<p>如图 9‑122所示，选择“ledquartus_prjoutput_files”路径下“led.jic”的文件，然后点击“OK”。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led122.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led122.png" alt="Led122"></a></p>
<p>图 9‑122 程序的固化（十六）</p>
<p>如图 9‑123所示，先将“Program&#x2F;Configure”下的方框打上钩，然后点击“Start”执行程序的固化。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led123.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led123.png" alt="Led123"></a></p>
<p>图 9‑123 程序的固化（十七）</p>
<p>如图 9‑124所示，下载的进度较之前明显慢很多，所以我们在平时调试的时候可以不固化程序，等待所有的工作都完成后，最后的再把完成的程序固化到开发板中。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led124.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Led124.png" alt="Led124"></a></p>
<p>图 9‑124 程序的固化（十八）</p>
<h2 id="2-5-章末总结¶"><a href="#2-5-章末总结¶" class="headerlink" title="2.5. 章末总结¶"></a>2.5. 章末总结<a href="#id18" title="永久链接至标题">¶</a></h2><p>本章通过led灯的例子让大家了解了一个完整的FPGA开发流程，其中有几个步骤是非常关键的，涉及到FPGA的开发方法，如：模块和端口信号划分、波形设计、RTL代码的编写、Testbench代码的编写、仿真波形分析。我们会在后面的章节和实例中重点对以上提到的关键步骤做详细的分析。只要大家根据我们的教程训 练，一定可以掌握这种方法。</p>
<h2 id="2-6-拓展训练¶"><a href="#2-6-拓展训练¶" class="headerlink" title="2.6. 拓展训练¶"></a>2.6. 拓展训练<a href="#id19" title="永久链接至标题">¶</a></h2><p>自己按照整个流程操作一遍后，在独立不看教程的情况下训练一遍，熟悉FPGA的开发流程和相关软件的操作，只有工具使用熟练了，才能够加快开发效率。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/index.html">[野火]FPGA Verilog开发实战指南——基于Altera EP4CE10 征途Mini开发板</a></p>
<p><a target="_blank" rel="noopener" href="https://detail.tmall.com/item.htm?spm=a1z10.5-b-s.w4011-23268010681.61.57491550QDVCO3&id=620698035547&rn=e00cc4fa5edac965f85f43020a263844&abbucket=18"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_static/images/product.png" alt="产品图片"></a></p>
<p>野火征途Mini FPGA开发板，采用Altera EP4CE10F17C8作为主控，包含了FPGA入门必备的硬件，是FPGA入门的性价比之选。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/index.html"></a>»</li>
<li>3. 简单组合逻辑 — 多路选择器</li>
</ul>
<hr>
<h1 id="3-简单组合逻辑-—-多路选择器¶"><a href="#3-简单组合逻辑-—-多路选择器¶" class="headerlink" title="3. 简单组合逻辑 — 多路选择器¶"></a>3. 简单组合逻辑 — 多路选择器<a href="#id1" title="永久链接至标题">¶</a></h1><h2 id="3-1-章节导读¶"><a href="#3-1-章节导读¶" class="headerlink" title="3.1. 章节导读¶"></a>3.1. 章节导读<a href="#id2" title="永久链接至标题">¶</a></h2><p>在上一章节，我们以点亮LED灯的实验为例，为读者详细讲解了FPGA开发的正确流程、Quartus软件的使用、程序的下载与固化，读者务必理解掌握；在本章节，我们用Verilog语言描述一个具有多路选择器功能的电路，使读者能够掌握新的语法知识和基本的框图、波形、代码设计方法，最后通过仿真来验证设计的正确 性。</p>
<h2 id="3-2-理论学习¶"><a href="#3-2-理论学习¶" class="headerlink" title="3.2. 理论学习¶"></a>3.2. 理论学习<a href="#id3" title="永久链接至标题">¶</a></h2><p>多路选择器是数据选择器的别称。在多路数据传送过程中，能够根据需要将其中任意一路选出来的电路，叫做数据选择器，也称多路选择器或多路开关。在选择变量控制下，从多路数据输入中某一路数据送至输出端。对于一个具有2^n个输入和1个输出的多路选择器，有n个选择变量。多路选择器也是FPGA内部的一个基本资源，主要 用于内部信号的选通。简单的多路选择器还可以通过级联生成更大的多路选择器。</p>
<h2 id="3-3-实战演练¶"><a href="#3-3-实战演练¶" class="headerlink" title="3.3. 实战演练¶"></a>3.3. 实战演练<a href="#id4" title="永久链接至标题">¶</a></h2><h3 id="3-3-1-实验目标¶"><a href="#3-3-1-实验目标¶" class="headerlink" title="3.3.1. 实验目标¶"></a>3.3.1. 实验目标<a href="#id5" title="永久链接至标题">¶</a></h3><p>设计并实现2选1多路选择器，主要功能是通过选通控制信号S确定选通A路或B路作为信号输出。当选通控制信号S为1时，信号输出为A路信号；当选通控制信号S为0时，信号输出为B路信号。</p>
<h3 id="3-3-2-硬件资源¶"><a href="#3-3-2-硬件资源¶" class="headerlink" title="3.3.2. 硬件资源¶"></a>3.3.2. 硬件资源<a href="#id6" title="永久链接至标题">¶</a></h3><p>我们使用开发板上的按键和LED灯进行2选1多路选择器的验证，选取KEY1、KEY2、KEY3分别作为信号A、信号B和选通信号S的信号输入；以LED灯D6作为信号输出O，如图 10‑1所示。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Multiplexer002.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Multiplexer002.png" alt="Multiplexer002"></a></p>
<p>图 10‑1 硬件资源</p>
<p>由原理图可知，征途Mini开发板的按键未按下时为高电平、按下后为低电平；LED灯则为低电平点亮。如图 10‑2、图 10‑3所示。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Multiplexer003.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Multiplexer003.png" alt="Multiplexer003"></a></p>
<p>图 10‑2 按键部分原理图</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Multiplexer004.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Multiplexer004.png" alt="Multiplexer004"></a></p>
<p>图 10‑3 LED灯原理图</p>
<h3 id="3-3-3-程序设计¶"><a href="#3-3-3-程序设计¶" class="headerlink" title="3.3.3. 程序设计¶"></a>3.3.3. 程序设计<a href="#id7" title="永久链接至标题">¶</a></h3><h4 id="3-3-3-1-模块框图¶"><a href="#3-3-3-1-模块框图¶" class="headerlink" title="3.3.3.1. 模块框图¶"></a>3.3.3.1. 模块框图<a href="#id8" title="永久链接至标题">¶</a></h4><p>根据功能分析，该工程只需实现一个2选1多路选择器的功能，所以设计成一个模块即可。模块命名mux2_1，模块的输入有三个1bit信号，两个名为in1和in2的数据输入信号和一个名为sel的选通控制信号，输出为1bit名为out的数据输出信号。根据上面的分析设计出的Visio框图如图 10‑4所示。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Multiplexer005.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Multiplexer005.png" alt="Multiplexer005"></a></p>
<p>图 10‑4 模块框图</p>
<p>端口列表与功能总结如表格 10‑1所示。</p>
<p>表格 10‑1 输入输出信号描述</p>
<table>
<thead>
<tr>
<th>信号</th>
<th>位宽</th>
<th>类型</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>in1</td>
<td>1Bit</td>
<td>Input</td>
<td>输入信号1</td>
</tr>
<tr>
<td>in2</td>
<td>1Bit</td>
<td>Input</td>
<td>输入信号2</td>
</tr>
<tr>
<td>sel</td>
<td>1Bit</td>
<td>Input</td>
<td>选通信号</td>
</tr>
<tr>
<td>out</td>
<td>8Bit</td>
<td>Output</td>
<td>输出信号</td>
</tr>
</tbody></table>
<h4 id="3-3-3-2-波形图绘制¶"><a href="#3-3-3-2-波形图绘制¶" class="headerlink" title="3.3.3.2. 波形图绘制¶"></a>3.3.3.2. 波形图绘制<a href="#id9" title="永久链接至标题">¶</a></h4><p>框图结构设计完毕后就可以实现该模块的具体功能了，也就是要找到输入和输出之间具体的映射关系。输入和输出满足信号与系统中输入与响应的关系。其中输入信号的名字用绿色表示，输出信号的名字用红色表示，任意模拟输入波形，画出输出信号的波形。</p>
<p>经分析得，当sel为低电平时，out的输出波形和in2相同；当sel为高电平时，out的输出波形和in1相同。根据分析的输入输出关系，我们列出如表格 10‑2所示的真值表，然后再根据真值表的输入与输出的对应关系画出波形图。其波形图如图 10‑5所示，图中蓝色的线代表有效信号。</p>
<p>表格 10‑2 真值表</p>
<table>
<thead>
<tr>
<th>输入（input）</th>
<th>输出（output）</th>
<th>选择器（sel）</th>
<th>输出（out）</th>
</tr>
</thead>
<tbody><tr>
<td>in1</td>
<td>in2</td>
<td>sel</td>
<td>out</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Multiplexer006.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Multiplexer006.png" alt="Multiplexer006"></a></p>
<p>图 10‑5 信号波形关系图</p>
<h4 id="3-3-3-3-代码编写¶"><a href="#3-3-3-3-代码编写¶" class="headerlink" title="3.3.3.3. 代码编写¶"></a>3.3.3.3. 代码编写<a href="#id10" title="永久链接至标题">¶</a></h4><p>实现2选1多路选择器功能的Verilog代码形式有很多种，我们这里主要列举三种实现方法，这三种方法对应的核心语法各不相同，后面我们还会经常用到。</p>
<ol>
<li>always中if-else实现方法</li>
</ol>
<table class="highlighttable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="n">mux2_1</span> <span class="c1">//模块的开头以“module”开始，然后是模块名“mux2_1”</span>
<span class="p">(</span>
<span class="k">input</span> <span class="kt">wire</span> <span class="n">in1</span><span class="p">,</span> <span class="c1">//输入端1，信号名后就是端口列表“();”（端口列表里</span>
<span class="c1">//面列举了该模块对外输入、输出信号的方式、类型、</span>
<span class="c1">//位宽、名字），该写法采用了Verilog-2001标准，这</span>
<span class="c1">//样更直观且实例化时也更方便，之前的Verilog-1995</span>
<span class="c1">//标准是将模块对外输入、输出信号的方式、类型、位</span>
<span class="c1">//宽都放到外面</span>

<p><span class="k">input</span> <span class="kt">wire</span> <span class="n">in2</span><span class="p">,</span> <span class="c1">&#x2F;&#x2F;输入端2，当数据只有一位宽时位宽表示可以省略</span><br><span class="c1">&#x2F;&#x2F;且输入只能是wire型变量</span></p>
<p><span class="k">input</span> <span class="kt">wire</span> <span class="n">sel</span><span class="p">,</span> <span class="c1">&#x2F;&#x2F;选择端，每行信号以“,”结束，最后一个后面不加“,”</span></p>
<p><span class="k">output</span> <span class="kt">reg</span> <span class="n">out</span> <span class="c1">&#x2F;&#x2F;结果输出，输出可以是wire型变量也可以是reg型变</span><br><span class="c1">&#x2F;&#x2F;量如果输出在always块中被赋值（即在“&lt;&#x3D;”的左边）</span><br><span class="c1">&#x2F;&#x2F;就要用reg型变量，如果输出在assign语句中被赋值</span><br><span class="c1">&#x2F;&#x2F;（即在“&#x3D;”的左边）就要用wire型变量</span><br><span class="p">);</span> <span class="c1">&#x2F;&#x2F;端口列表括号后有个“;”不要忘记</span></p>
<p><span class="c1">&#x2F;&#x2F;out:组合逻辑输出sel选择的结果</span><br><span class="k">always</span><span class="p">@(</span><span class="o"><em></span><span class="p">)</span><span class="c1">&#x2F;&#x2F;“</em>”为通配符，表示只要if括号中的条件或赋值号右边的变量发生变化</span><br><span class="c1">&#x2F;&#x2F;则立即执行下面的代码，“(*)”在此always中等价于“(sel, in1, in2)”写法</span></p>
<p><span class="k">if</span><span class="p">(</span><span class="n">sel</span> <span class="o">&#x3D;&#x3D;</span> <span class="mh">1</span><span class="mb">‘b1</span><span class="p">)</span><span class="c1">&#x2F;&#x2F;当“if…else…”中只有一个变量时不需要加“begin…end”</span><br><span class="c1">&#x2F;&#x2F;也显得整个代码更加简洁</span></p>
<p><span class="n">out</span> <span class="o">&#x3D;</span> <span class="n">in1</span><span class="p">;</span> <span class="c1">&#x2F;&#x2F;always块中如果表达的是组合逻辑关系时使用“&#x3D;”进行赋值</span><br><span class="c1">&#x2F;&#x2F;每句赋值以“;”结束</span><br><span class="k">else</span><br><span class="n">out</span> <span class="o">&#x3D;</span> <span class="n">in2</span><span class="p">;</span></p>
<p><span class="c1">&#x2F;&#x2F;模块的结尾以“endmodule”结束</span><br><span class="c1">&#x2F;&#x2F;每个模块只能有一组“module”和“endmodule”，所有的代码都要在它们中间编写</span><br><span class="k">endmodule</span><br></pre></div></td></tr></tbody></table></p>
<p>根据上面RTL代码综合出的RTL视图如图 10‑6所示。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Multiplexer007.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Multiplexer007.png" alt="Multiplexer007"></a></p>
<p>图 10‑6 RTL视图（一）</p>
<p>有人可能会有稍稍的疑问，就是为什么always块中被赋值的一定要是reg型变量，他并没有生成寄存器而是实现的的组合逻辑的功能？因为在Verilog语言中，寄存器的特点是，它需要在仿真运行器件中保存其值，也就是说这个变量在仿真时需要占据内存空间，而上面的always块只对sel、in1、in2三个变量 的输入敏感，如果没有这三个变量的变化事件，则out变量将需要保存其值，因此它们必须被定义为reg型变量，但是在综合之后，并不对应硬件锁存器或者触发器（后面会讲到什么时候会出现综合成这两种的情况）。</p>
<p>（2）always中case实现方法</p>
<table class="highlighttable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39</pre></div></td><td class="code"><div class="highlight"><pre><span></span>module mux2_1
(
input wire in1, //输入端1
input wire in2, //输入端2
input wire sel, //选择端

<p>output reg out &#x2F;&#x2F;结果输出<br>);</p>
<p>&#x2F;&#x2F;out:组合逻辑输出选择结果<br>always@(*)<br>case(sel)<br>1’b1 : out &#x3D; in1;<br>1’b0 : out &#x3D; in2;<br>&#x2F;&#x2F;如果sel不能列举出所有的情况一定要加default<br>&#x2F;&#x2F;此处sel只有两种情况，并且完全列举了，所以default可以省略<br>default : out &#x3D; in1;<br>endcase</p>
<p>endmodule<br>据上面RTL代码综合出的RTL视图如图 10‑7所示<br>ini10008|<br>10‑7 RTL视图（二）<br>3）assign中条件运算符（三元运算符）实现方法<br>module mux2_1<br>(<br>input wire in1, &#x2F;&#x2F;输入端1<br>input wire in2, &#x2F;&#x2F;输入端2<br>input wire sel, &#x2F;&#x2F;选择端</p>
<p>output wire out &#x2F;&#x2F;结果输出<br>);</p>
<p>&#x2F;&#x2F;out:组合逻辑输出选择结果<br>&#x2F;&#x2F;此处使用的是条件运算符（三元运算符），当括号里面的条件成立时<br>&#x2F;&#x2F;执行”?”后面的结果；如果括号里面的条件不成立时，执行“：”后面的结果<br>assign out &#x3D; (sel &#x3D;&#x3D; 1’b1) ? in1 : in2;</p>
<p>endmodule<br></pre></div></td></tr></tbody></table></p>
<p>根据上面RTL代码综合出的RTL视图如图 10‑8所示，我们发现这并不是最基本的门电路，而是一个多路器的符号，之前不是说数字电路不都是由最基本的门电路构成的吗，这个为什么不是呀？因为我们描述的角度不同，我们是从寄存器传输级这个层次来描述的，最基本的单元可能就是这些寄存器、多路器、译码器、比较器、加法 器等等，这些基本的单元再往底层划分还是可以由其他的门电路构成的，所以在描述这些电路功能时我们也可以用最基本的门电路来描述，那我们最后看到的RTL视图就是由门电路构成的了，其缺点就是效率太低。既然我们可以从更高的层次描述实现的功能来提高效率，为什么还要用低层次的描述方式呢，所以基于门级的描述我们很少用 ，大家在看其他资料的时候有很多都是将这两者混在一起讲的，这样是让初学者感觉迷惑的地方。那就有人问了还有没有更高层次的描述方法？当然有，比寄存器传输级还高的描述方式有算法级和系统级，将会使用到更高级的语言，如System Verilog和Ssytem C，也可以使用C和C++再通过高层次综合（High-level Synthesis，HLS）的方式来实现。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Multiplexer009.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Multiplexer009.png" alt="Multiplexer009"></a></p>
<p>图 10‑8 RTL视图（三）</p>
<p>通过以上三种不同的代码编写方式，我们首先可以了解到一个最基本模块的书写格式和方法，还知道Veriolg语言和C语言相似的地方就是实现相同功能，其代码方式是多种多样的，所以大家在代码的实现上就有很多的选择，看到别人不同的写法也不要大惊小怪，我们要关注的是最后的功能，在不考虑资源使用的情况下只要功能满足 要求，代码的灵活性可以随意控制。通过对比发现以上三种不同代码方式实现的2选1多路选择器对应综合出的RTL视图虽有所差别，但综合工具在布局布线和最后映射FPGA资源时会自动优化，使最终的功能和占用的逻辑资源都是相同的。</p>
<h4 id="3-3-3-4-仿真验证¶"><a href="#3-3-3-4-仿真验证¶" class="headerlink" title="3.3.3.4. 仿真验证¶"></a>3.3.3.4. 仿真验证<a href="#id11" title="永久链接至标题">¶</a></h4><p>仿真文件编写</p>
<p>仿真文件的代码如下所示</p>
<table class="highlighttable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">\`timescale</span> <span class="mh">1</span><span class="n">ns</span><span class="o">/</span><span class="mh">1</span><span class="n">ns</span> <span class="c1">//时间尺度、精度单位定义，决定“#（不可被综合，但在可</span>
<span class="c1">//综合代码中也可以写，只是会在仿真时表达效果，而综合</span>
<span class="c1">//时会自动被综合器优化掉）”后面的数字表示的时间尺度和</span>
<span class="c1">//精度，具体表达含义为:“时间尺度/时间精度”。为了以后</span>
<span class="c1">//编写方便我们将该句放在所有“.v”文件的开头，后面的代</span>
<span class="c1">//码示例将不再显示该句</span>

<p><span class="k">module</span> <span class="n">tb_mux2_1</span><span class="p">();</span><span class="c1">&#x2F;&#x2F;testbench的格式和待测试RTL模块的格式相同</span><br><span class="c1">&#x2F;&#x2F;也是以“module”开始以“endmodule”结束，所有的代码都要</span><br><span class="c1">&#x2F;&#x2F;在它们中间编写。不同的是在testbench中端口列表为空</span><br><span class="c1">&#x2F;&#x2F;因为testbench不对外进行信号的输入输出，只是自己产生</span><br><span class="c1">&#x2F;&#x2F;激励信号提供给内部实例化待测RTL模块使用，所以端口列表</span><br><span class="c1">&#x2F;&#x2F;中没有内容，只是列出“()”，当然可以将“()”省略，括号</span><br><span class="c1">&#x2F;&#x2F;后有个“;”不要忘记</span></p>
<p><span class="c1">&#x2F;&#x2F;要在initial块和always块中被赋值的变量一定要是reg型</span><br><span class="c1">&#x2F;&#x2F;在testbench中待测试RTL模块的输入永远是reg型变量</span><br><span class="kt">reg</span> <span class="n">in1</span><span class="p">;</span><br><span class="kt">reg</span> <span class="n">in2</span><span class="p">;</span><br><span class="kt">reg</span> <span class="n">sel</span><span class="p">;</span></p>
<p><span class="c1">&#x2F;&#x2F;输出信号，我们直接观察，也不用在任何地方进行赋值</span><br><span class="c1">&#x2F;&#x2F;所以是wire型变量（在testbench中待测试RTL模块的输出永远是wire型变量）</span><br><span class="kt">wire</span> <span class="n">out</span><span class="p">;</span></p>
<p><span class="c1">&#x2F;&#x2F;initial语句是可以被综合的，一般只在testbench中表达而不在RTL代码中表达</span><br><span class="c1">&#x2F;&#x2F;initial块中的语句上电后只执行一次，主要用于初始化仿真中要输入的信号</span><br><span class="c1">&#x2F;&#x2F;初始化值在没有特殊要求的情况下给0或1都可以。如果不赋初值，仿真时信号</span><br><span class="c1">&#x2F;&#x2F;会显示为不定态（ModelSim中的波形显示红色）</span><br><span class="k">initial</span><br><span class="k">begin</span> <span class="c1">&#x2F;&#x2F;在仿真中begin…end块中的内容都是顺序执行的，</span><br><span class="c1">&#x2F;&#x2F;在没有延时的情况下几乎没有差别，看上去是同时执行的，</span><br><span class="c1">&#x2F;&#x2F;如果有延时才能表达的比较明了；</span><br><span class="c1">&#x2F;&#x2F;而在rtl代码中begin…end相当于括号的作用，</span><br><span class="c1">&#x2F;&#x2F;在同一个always块中给多个变量赋值的时候要加上</span><br><span class="n">in1</span> <span class="o">&lt;&#x3D;</span> <span class="mh">1</span><span class="mb">‘b0</span><span class="p">;</span><br><span class="n">in2</span> <span class="o">&lt;&#x3D;</span> <span class="mh">1</span><span class="mb">‘b0</span><span class="p">;</span><br><span class="n">sel</span> <span class="o">&lt;&#x3D;</span> <span class="mh">1</span><span class="mb">‘b0</span><span class="p">;</span><br><span class="k">end</span></p>
<p><span class="c1">&#x2F;&#x2F;in1:产生输入随机数，模拟输入端1的输入情况</span><br><span class="k">always</span> <span class="p">#</span><span class="mh">10</span> <span class="n">in1</span> <span class="o">&lt;&#x3D;</span> <span class="p">{</span><span class="nb">$random</span><span class="p">}</span> <span class="o">%</span> <span class="mh">2</span><span class="p">;</span><span class="c1">&#x2F;&#x2F;取模求余数，产生随机数1’b0、1’b1</span><br><span class="c1">&#x2F;&#x2F;每隔10ns产生一次随机数</span></p>
<p><span class="c1">&#x2F;&#x2F;in2:产生输入随机数，模拟输入端2的输入情况</span><br><span class="k">always</span> <span class="p">#</span><span class="mh">10</span> <span class="n">in2</span> <span class="o">&lt;&#x3D;</span> <span class="p">{</span><span class="nb">$random</span><span class="p">}</span> <span class="o">%</span> <span class="mh">2</span><span class="p">;</span></p>
<p><span class="c1">&#x2F;&#x2F;sel:产生输入随机数，模拟选择端的输入情况</span><br><span class="k">always</span> <span class="p">#</span><span class="mh">10</span> <span class="n">sel</span> <span class="o">&lt;&#x3D;</span> <span class="p">{</span><span class="nb">$random</span><span class="p">}</span> <span class="o">%</span> <span class="mh">2</span><span class="p">;</span></p>
<p><span class="c1">&#x2F;&#x2F;下面的语句是为了在ModelSim仿真中直接打印出来信息便于观察信号变化的状态</span><br><span class="c1">&#x2F;&#x2F;也可以不使用下面的语句而直接观察仿真出的波形</span><br><span class="c1">&#x2F;&#x2F;————————————————————</span><br><span class="k">initial</span> <span class="k">begin</span><br><span class="nb">$timeformat</span><span class="p">(</span><span class="o">-</span><span class="mh">9</span><span class="p">,</span> <span class="mh">0</span><span class="p">,</span> <span class="s">“ns”</span><span class="p">,</span> <span class="mh">6</span><span class="p">);</span><span class="c1">&#x2F;&#x2F;设置显示的时间格式，此处表示的是(打印时间单</span><br><span class="c1">&#x2F;&#x2F;位为纳秒，小数点后打印的小数位为0位，时间值</span><br><span class="c1">&#x2F;&#x2F;后打印的字符串为“ns”，打印的最小数量字符为6个)</span></p>
<p><span class="c1">&#x2F;&#x2F;只要监测的变量（时间、in1, in2, sel, out）发生变化，就会打印出相应的信息</span><br><span class="nb">$monitor</span><span class="p">(</span><span class="s">“@time %t:in1&#x3D;%b in2&#x3D;%b sel&#x3D;%b out&#x3D;%b”</span><span class="p">,</span><span class="nb">$time</span><span class="p">,</span><span class="n">in1</span><span class="p">,</span><span class="n">in2</span><span class="p">,</span><span class="n">sel</span><span class="p">,</span><span class="n">out</span><span class="p">);</span><br><span class="k">end</span><br><span class="c1">&#x2F;&#x2F;————————————————————</span></p>
<p><span class="c1">&#x2F;&#x2F;待测试RTL模块的实例化，相当于将待测试模块放到测试模块中，并将输入输出对应连接上</span><br><span class="c1">&#x2F;&#x2F;测试模块中产生激励信号给待测试模块的输入，以观察待测试模块的输出信号是否正确</span><br><span class="c1">&#x2F;&#x2F;————————mux2_1_inst————————</span><br><span class="n">mux2_1</span> <span class="n">mux2_1_inst</span> <span class="c1">&#x2F;&#x2F;第一个是被实例化模块的名子，第二个是我们自己定义的在另一个</span><br><span class="c1">&#x2F;&#x2F;模块中实例化后的名字。同一个模块可以在另一个模块中或不同的</span><br><span class="c1">&#x2F;&#x2F;另外模块中被多次实例化，第一个名字相同，第二个名字不同</span><br><span class="p">(</span><br><span class="c1">&#x2F;&#x2F;前面的“in1”表示被实例化模块中的信号，后面的“in1”表示实例化该模块并要和这个</span><br><span class="c1">&#x2F;&#x2F;模块的该信号相连接的信号（可以取名不同，一般取名相同，方便连接和观察）</span><br><span class="c1">&#x2F;&#x2F;“.”可以理解为将这两个信号连接在一起</span><br><span class="p">.</span><span class="n">in1</span><span class="p">(</span><span class="n">in1</span><span class="p">),</span> <span class="c1">&#x2F;&#x2F;input in1</span><br><span class="p">.</span><span class="n">in2</span><span class="p">(</span><span class="n">in2</span><span class="p">),</span> <span class="c1">&#x2F;&#x2F;input in2</span><br><span class="p">.</span><span class="n">sel</span><span class="p">(</span><span class="n">sel</span><span class="p">),</span> <span class="c1">&#x2F;&#x2F;inputsel</span></p>
<p><span class="p">.</span><span class="n">out</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="c1">&#x2F;&#x2F;output out</span><br><span class="p">);</span></p>
<p><span class="k">endmodule</span><br></pre></div></td></tr></tbody></table></p>
<p>注：上面用到了2个initial块和4个always块，上电后这6个模块同时执行，也就是所谓的“并行”执行，在RTL代码中也是同样的。</p>
<p>仿真波形分析</p>
<p>在验证RTL逻辑时，我们不用关心内部结构是如何实现的，只需达到被验证的“黑盒子”模块需要什么激励才能够比较完全的达到验证功能正确性的目的，根据此需求来提供相应的输入激励，观察输出是否为我们最初设计的结果。这个模块的输入信号只有两个，因为是组合逻辑，输入信号的时序关系也很简单，只需要给不同的输入输出值 就可以了，我们在testbench中使用随机数函数生成随机变化的0、1给输入端口，先通过ModelSim仿真出的波形验证RTL逻辑是否正确，再通过观察“Transcript”中打印的信息进行验证。</p>
<p>根据在QuartusII中的设置，ModelSim打开后仿真波形自动运行的时间为1us，这里我们不需要观察这么多时间。先清空波形，然后重新设置仿真时间为500ns，运行后即可验证结果的正确性（在某些情况下仿真波形运行1u后仍不能观察到所需要验证的结果，此时可以再重新设置仿真时间，该时间也不宜设置太久 ，否则会使会导致运行的时间过长且运行后占用较大的电脑内存空间，总之以适度原则为主，或者用修改参数的方法同比例缩小必要仿真时间）。</p>
<p>通过图 10‑9所示的波形我们可以观察到，当sel为高电平时，out输出为in1的值；当sel为低电平时，out输出为in2的值，完全符合我们代码中的逻辑设计。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Multiplexer010.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Multiplexer010.png" alt="Multiplexer010"></a></p>
<p>图 10‑9 仿真波形图</p>
<p>下面我们通过观察“Transcript”界面（如图 10‑10所示）打印的结果再进行验证（如果打开的界面找不到Wave或Transcript窗口可以点击“Tool”下面的列表进行添加，如图 10‑11所示）。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Multiplexer011.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Multiplexer011.png" alt="Multiplexer011"></a></p>
<p>图 10‑10 打印结果</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Multiplexer012.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Multiplexer012.png" alt="Multiplexer012"></a></p>
<p>图 10‑11 添加打印结果</p>
<p>我们通过观察“Transcript”界面（如图 10‑12所示）中打印的结果发现红色小框组成的结果即为out输出的结果，我们可以发现这个打印信息和真值表的样式几乎是一模一样，在组合逻辑中，因为不考虑延时的问题，所以一行有效数据对应的就是独立的一行，清晰直观，将打印信息与前面绘制的真值表进行比对，能够更加快速验证结果的正确性。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Multiplexer013.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Multiplexer013.png" alt="Multiplexer013"></a></p>
<p>图 10‑12 Transcript界面图</p>
<h3 id="3-3-4-上板验证¶"><a href="#3-3-4-上板验证¶" class="headerlink" title="3.3.4. 上板验证¶"></a>3.3.4. 上板验证<a href="#id12" title="永久链接至标题">¶</a></h3><h4 id="3-3-4-1-引脚约束¶"><a href="#3-3-4-1-引脚约束¶" class="headerlink" title="3.3.4.1. 引脚约束¶"></a>3.3.4.1. 引脚约束<a href="#id13" title="永久链接至标题">¶</a></h4><p>仿真验证通过后，准备上板验证，上板验证之前先要进行引脚约束。工程中各输入输出信号与开发板引脚对应关系如表格 10‑3所示。引脚配置如图 10‑13所示。</p>
<p>表格 10‑3 引脚分配表</p>
<table>
<thead>
<tr>
<th><strong>信号名</strong></th>
<th><strong>信号类型</strong></th>
<th><strong>对应引脚</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td>in1</td>
<td>Input</td>
<td>M2</td>
<td>按键</td>
</tr>
<tr>
<td>in2</td>
<td>Input</td>
<td>M1</td>
<td>按键</td>
</tr>
<tr>
<td>sel</td>
<td>Input</td>
<td>E15</td>
<td>按键</td>
</tr>
<tr>
<td>out</td>
<td>Output</td>
<td>L7</td>
<td>LED灯</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Multiplexer014.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Multiplexer014.png" alt="Multiplexer014"></a></p>
<p>图 10‑13 引脚配置图</p>
<h4 id="3-3-4-2-结果验证¶"><a href="#3-3-4-2-结果验证¶" class="headerlink" title="3.3.4.2. 结果验证¶"></a>3.3.4.2. 结果验证<a href="#id14" title="永久链接至标题">¶</a></h4><p>如图 10‑14所示，开发板连接5V直流电源和USB-Blaster下载器JTAG端口。线路正确连接后，打开开关为板卡上电。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Multiplexer015.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Multiplexer015.png" alt="Multiplexer015"></a></p>
<p>图 10‑14 程序下载连线图</p>
<p>如图 10‑15所示，使用“Programmer”为开发板下载程序。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Multiplexer016.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Multiplexer016.png" alt="Multiplexer016"></a></p>
<p>图 10‑15 程序下载窗口</p>
<p>程序下载完毕后，开始进行结果验证。如图 10‑16、图 10‑17所示，当按键KEY3未被按下时，sel输出为高电平，输出信号为in1；按键KEY1未按下，in1输出高电平，led灯未被点亮；按键KEY1按下，in1输出低电平，led灯点亮。如图 10‑18所示，当按键KEY3按下时，sel输出为低电平，输出信号为in2；按键KEY2按下，in2输出低电平，led灯点亮。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Multiplexer017.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Multiplexer017.png" alt="Multiplexer017"></a></p>
<p>图 10‑16 结果验证（一）</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Multiplexer018.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Multiplexer018.png" alt="Multiplexer018"></a></p>
<p>图 10‑17 结果验证（二）</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Multiplexer019.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Multiplexer019.png" alt="Multiplexer019"></a></p>
<p>图 10‑18 结果验证（三）</p>
<h2 id="3-4-章末总结¶"><a href="#3-4-章末总结¶" class="headerlink" title="3.4. 章末总结¶"></a>3.4. 章末总结<a href="#id15" title="永久链接至标题">¶</a></h2><p>本章通过2选1多路选择器介绍了如何编写一个最简单的RTL逻辑功能模块以及对应的仿真的代码如何编写，并进行了仿真验证。其中介绍了很多语法的实际应用和需要注意事项，希望读者能够掌握。</p>
<p><strong>新语法总结</strong></p>
<p><strong>重点掌握</strong></p>
<p>1、always块描述组合逻辑的用法</p>
<p>2、assign语句的用法</p>
<p>3、initial的用法（不可综合，常用于Testbech中初始化信号，但也可以在可综合的模块中用于初始化寄存器）</p>
<p>4、if-else的用法</p>
<p>5、case的用法</p>
<p>6、条件运算符（三元运算符）的用法</p>
<p>7、begin…end（对多条语句赋值时使用，因为我们设计RTL代码的原则是一个always块中最好只有一个变量，所以begin…end在RTL代码中几乎很少使用，而在Tetbench中使用的更多）</p>
<p>8、#延时（不可综合，但允许在可综合的模块中使用，其延时单位仍由可综合模块中的`timescale决定，但是综合时被其延时时间被综合器忽略）</p>
<p>9、<a href="#id16">`</a>timescale（配合“#”允许在可综合模块中使用）</p>
<p>10、&#x3D;（赋值号的一种，阻塞赋值，在可综合的模块中表达组合逻辑的语句时使用）</p>
<p>11、&#x3D;&#x3D;（常用的比较运算符）</p>
<p>12、&#x2F;&#x2F;（注释一行代码时使用）</p>
<p><strong>一般掌握</strong></p>
<p>1、$timeformat在Testbench中的用法（不可综合）</p>
<p>2、$monitor在Testbench中的用法（不可综合）</p>
<p>3、$time在Testbench中的用法（不可综合）</p>
<p><strong>知识点总结</strong></p>
<p>1、功能模块的书写结构、格式（端口列表推荐使用Verilog-2001标准）</p>
<p>2、仿真模块的书写结构、格式（端口列表中没有任何信号）</p>
<p>3、如何进行实例化调用（信号名的对应关系和连线）</p>
<p>4、在ModelSim中通过观察波形和查看“Transcript”界面中打印的信息对设计的代码进行功能验证（如果有语法或者仿真错误也会在该界面中提示）</p>
<h2 id="3-5-拓展训练¶"><a href="#3-5-拓展训练¶" class="headerlink" title="3.5. 拓展训练¶"></a>3.5. 拓展训练<a href="#id18" title="永久链接至标题">¶</a></h2><p>完成本章实例程后，希望大家可以自己多动手练习，并分别用本章中提到的三种方式分别编写一个8选1多路选择器，并编写对应的Testbench，且使用ModelSim进行验证，以达到强化熟悉语法、模块结构和软件操作流程的目的。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/index.html">[野火]FPGA Verilog开发实战指南——基于Altera EP4CE10 征途Mini开发板</a></p>
<p><a target="_blank" rel="noopener" href="https://detail.tmall.com/item.htm?spm=a1z10.5-b-s.w4011-23268010681.61.57491550QDVCO3&id=620698035547&rn=e00cc4fa5edac965f85f43020a263844&abbucket=18"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_static/images/product.png" alt="产品图片"></a></p>
<p>野火征途Mini FPGA开发板，采用Altera EP4CE10F17C8作为主控，包含了FPGA入门必备的硬件，是FPGA入门的性价比之选。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/index.html"></a>»</li>
<li>4. 简单组合逻辑 — 译码器</li>
</ul>
<hr>
<h1 id="4-简单组合逻辑-—-译码器¶"><a href="#4-简单组合逻辑-—-译码器¶" class="headerlink" title="4. 简单组合逻辑 — 译码器¶"></a>4. 简单组合逻辑 — 译码器<a href="#id1" title="永久链接至标题">¶</a></h1><h2 id="4-1-章节导读¶"><a href="#4-1-章节导读¶" class="headerlink" title="4.1. 章节导读¶"></a>4.1. 章节导读<a href="#id2" title="永久链接至标题">¶</a></h2><p>上一章节我们学习、设计并实现了简单组合逻辑中的多路选择器，在本章我们用Verilog语言描述一个具有3-8译码器功能的电路，通过学习3-8译码器继续巩固整个设计流程以及语法的使用。</p>
<h2 id="4-2-理论学习¶"><a href="#4-2-理论学习¶" class="headerlink" title="4.2. 理论学习¶"></a>4.2. 理论学习<a href="#id3" title="永久链接至标题">¶</a></h2><p>译码是编码的逆过程，在编码时，每一种二进制代码，都赋予了特定的含义，即都表示了一个确定的信号或者对象。把代码状态的特定含义翻译出来的过程叫做译码，实现译码操作的电路称为译码器。或者说，译码器是可以将输入二进制代码的状态翻译成输出信号，以表示其原来含义的电路。</p>
<p>译码器（decoder）是一类多输入多输出组合逻辑电路器件，其可以分为：变量译码和显示译码两类。变量译码器一般是一种较少输入变为较多输出的器件，常见的有n线-2^n线译码和8421BCD码译码两类；显示译码器用来将二进制数转换成对应的七段码，一般其可分为驱动LED和驱动LCD两类。</p>
<p>本节我们主要讲解变量译码，最常见的变量译码器为3-8译码器，主要用于端口的扩展。假如我们有8个led灯需要单独控制，理论上我们需要用8个I&#x2F;O口，普通的单片机也够用，但是如果我们控制的不是8个led灯，而是一个点阵屏，那就可想而知我们要使用的I&#x2F;O口数量不是一般控制器就能满足的了，即便是I&#x2F;O资源丰 富的FPGA在面对巨大的点阵屏时也可能面临管脚资源不够用的尴尬境地。此种情况下使用3-8译码器就可以很好的解决这个问题，我们可以通过控制器控制3个I&#x2F;O输出的8种情况来分别控制8个输出状态，相当于用3个I&#x2F;O口就可以独立控制8个led灯，即一个3-8译码器就能够节约出来5个I&#x2F;O口，算起来是相当合算 的。现在的3-8译码器大都做成了独立ASIC芯片，价格也往往非常便宜。</p>
<h2 id="4-3-实战演练¶"><a href="#4-3-实战演练¶" class="headerlink" title="4.3. 实战演练¶"></a>4.3. 实战演练<a href="#id4" title="永久链接至标题">¶</a></h2><h3 id="4-3-1-实验目标¶"><a href="#4-3-1-实验目标¶" class="headerlink" title="4.3.1. 实验目标¶"></a>4.3.1. 实验目标<a href="#id5" title="永久链接至标题">¶</a></h3><p>设计并仿真验证3-8译码器。</p>
<p>注：3-8译码器的上板验证需要用到8个led灯或者数码管，因为板卡led灯数目不够且数码管部分还未作讲解，3-8译码器只进行仿真验证，不再上板测试，上板测试可等到数码管讲解完毕后，读者自行验证。</p>
<h3 id="4-3-2-程序设计¶"><a href="#4-3-2-程序设计¶" class="headerlink" title="4.3.2. 程序设计¶"></a>4.3.2. 程序设计<a href="#id6" title="永久链接至标题">¶</a></h3><h4 id="4-3-2-1-模块框图¶"><a href="#4-3-2-1-模块框图¶" class="headerlink" title="4.3.2.1. 模块框图¶"></a>4.3.2.1. 模块框图<a href="#id7" title="永久链接至标题">¶</a></h4><p>根据功能分析，该工程只需实现一个3-8译码器的功能，所以设计成一个模块即可。模块命名decoder3_8，模块的输入为3个1bit信号，输出为1个8bit信号，实现通过输入3个信号组成的二进制的8种情况来控制对应输出8bit的8种不同状态。根据上面的分析设计出的Visio框图如图 11‑1所示。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/decoder002.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/decoder002.png" alt="decoder002"></a></p>
<p>图 11‑1 模块框图</p>
<p>端口列表与功能描述如表格 11‑1所示。</p>
<p>表格 11‑1 输入输出信号描述</p>
<table>
<thead>
<tr>
<th>信号</th>
<th>位宽</th>
<th>类型</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>in1</td>
<td>1Bit</td>
<td>Input</td>
<td>输入信号1</td>
</tr>
<tr>
<td>in2</td>
<td>1Bit</td>
<td>Input</td>
<td>输入信号2</td>
</tr>
<tr>
<td>in3</td>
<td>1Bit</td>
<td>Input</td>
<td>输入信号3</td>
</tr>
<tr>
<td>out</td>
<td>8Bit</td>
<td>Output</td>
<td>译码后的输出信号</td>
</tr>
</tbody></table>
<h4 id="4-3-2-2-波形图绘制¶"><a href="#4-3-2-2-波形图绘制¶" class="headerlink" title="4.3.2.2. 波形图绘制¶"></a>4.3.2.2. 波形图绘制<a href="#id8" title="永久链接至标题">¶</a></h4><p>和之前一样，框图结构设计完毕后就可以通过波形图的方式来描述输入和输出之间具体的映射关系。经分析得，输入为3个1bit信号，其任意二进制组合有8种情况，每种组合与out输出8bit的 8种状态一一对应，实现由3种输入控制对应的8种输出的译码效果。我们根据上面的分析列出如表格 11‑2所示的真值表，然后再根据真值表的输入与输出的对应关系画波形图。其波形如图 11‑2所示，与真值表的关系一一对应。</p>
<p>表格 11‑2 3-8译码器真值表</p>
<table>
<thead>
<tr>
<th>in1</th>
<th>in2</th>
<th>in3</th>
<th>out</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0000_0001</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0000_0010</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0000_0100</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0000_1000</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0001_0000</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0010_0000</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0100_0000</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1000_0000</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/decoder003.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/decoder003.png" alt="decoder003"></a></p>
<p>图 11‑2 信号波形关系图</p>
<h4 id="4-3-2-3-代码编写¶"><a href="#4-3-2-3-代码编写¶" class="headerlink" title="4.3.2.3. 代码编写¶"></a>4.3.2.3. 代码编写<a href="#id9" title="永久链接至标题">¶</a></h4><p>实现3-8译码器功能的Verilog代码形式也有很多种，我们这里主要列举两种最容易理解的方法，通过这两种方法的用法对比，使学习者能对if-else和case这两种语法有一个比较深刻的理解。</p>
<ol>
<li>always中if-else实现方法</li>
</ol>
<table class="highlighttable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="n">decoder3_8</span>
<span class="p">(</span>
<span class="k">input</span> <span class="kt">wire</span> <span class="n">in1</span> <span class="p">,</span> <span class="c1">//输入信号in1</span>
<span class="k">input</span> <span class="kt">wire</span> <span class="n">in2</span> <span class="p">,</span> <span class="c1">//输入信号in2</span>
<span class="k">input</span> <span class="kt">wire</span> <span class="n">in3</span> <span class="p">,</span> <span class="c1">//输入信号in3</span>

<p><span class="k">output</span> <span class="kt">reg</span> <span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">out</span> <span class="c1">&#x2F;&#x2F;输出信号out</span><br><span class="p">);</span></p>
<p><span class="c1">&#x2F;&#x2F;out:根据3个输入信号选择输出对应的8bit out信号</span><br><span class="k">always</span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><br><span class="c1">&#x2F;&#x2F;使用”{}”位拼接符将3个1bit数据按照顺序拼成一个3bit数据</span><br><span class="k">if</span><span class="p">({</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">}</span> <span class="o">&#x3D;&#x3D;</span> <span class="mh">3</span><span class="mb">‘b000</span><span class="p">)</span><br><span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0000</span><span class="n">_0001</span><span class="p">;</span><br><span class="k">else</span> <span class="k">if</span><span class="p">({</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">}</span> <span class="o">&#x3D;&#x3D;</span> <span class="mh">3</span><span class="mb">‘b001</span><span class="p">)</span><br><span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0000</span><span class="n">_0010</span><span class="p">;</span><br><span class="k">else</span> <span class="k">if</span><span class="p">({</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">}</span> <span class="o">&#x3D;&#x3D;</span> <span class="mh">3</span><span class="mb">‘b010</span><span class="p">)</span><br><span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0000</span><span class="n">_0100</span><span class="p">;</span><br><span class="k">else</span> <span class="k">if</span><span class="p">({</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">}</span> <span class="o">&#x3D;&#x3D;</span> <span class="mh">3</span><span class="mb">‘b011</span><span class="p">)</span><br><span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0000</span><span class="n">_1000</span><span class="p">;</span><br><span class="k">else</span> <span class="k">if</span><span class="p">({</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">}</span> <span class="o">&#x3D;&#x3D;</span> <span class="mh">3</span><span class="mb">‘b100</span><span class="p">)</span><br><span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0001</span><span class="n">_0000</span><span class="p">;</span><br><span class="k">else</span> <span class="k">if</span><span class="p">({</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">}</span> <span class="o">&#x3D;&#x3D;</span> <span class="mh">3</span><span class="mb">‘b101</span><span class="p">)</span><br><span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0010</span><span class="n">_0000</span><span class="p">;</span><br><span class="k">else</span> <span class="k">if</span><span class="p">({</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">}</span> <span class="o">&#x3D;&#x3D;</span> <span class="mh">3</span><span class="mb">‘b110</span><span class="p">)</span><br><span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0100</span><span class="n">_0000</span><span class="p">;</span><br><span class="k">else</span> <span class="k">if</span><span class="p">({</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">}</span> <span class="o">&#x3D;&#x3D;</span> <span class="mh">3</span><span class="mb">‘b111</span><span class="p">)</span><br><span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b1000</span><span class="n">_0000</span><span class="p">;</span><br><span class="k">else</span><br><span class="c1">&#x2F;&#x2F;最后一个else对应的if中的条件只有一种情况，还可能产生以上另外的7种情况</span><br><span class="c1">&#x2F;&#x2F;如果不加这个else综合器会把不符合该if中条件的上面另外7种情况都考虑进去</span><br><span class="c1">&#x2F;&#x2F;会产生大量的冗余逻辑并产生latch（锁存器），所以在组合逻辑中最后一个if</span><br><span class="c1">&#x2F;&#x2F;后一定要加上else，并任意指定一种确定的输出情况</span><br><span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0000</span><span class="n">_0001</span><span class="p">;</span></p>
<p><span class="k">endmodule</span><br></pre></div></td></tr></tbody></table></p>
<p>根据上面RTL代码综合出的RTL视图如图 11‑3所示。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/decoder004.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/decoder004.png" alt="decoder004"></a></p>
<p>图 11‑3 RTL视图（一）</p>
<p>（2）always中case实现方法</p>
<table class="highlighttable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="n">decoder3_8</span>
<span class="p">(</span>
<span class="k">input</span> <span class="kt">wire</span> <span class="n">in1</span> <span class="p">,</span> <span class="c1">//输入信号in1</span>
<span class="k">input</span> <span class="kt">wire</span> <span class="n">in2</span> <span class="p">,</span> <span class="c1">//输入信号in2</span>
<span class="k">input</span> <span class="kt">wire</span> <span class="n">in3</span> <span class="p">,</span> <span class="c1">//输入信号in3</span>

<p><span class="k">output</span> <span class="kt">reg</span> <span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">out</span> <span class="c1">&#x2F;&#x2F;输出信号out</span><br><span class="p">);</span></p>
<p><span class="c1">&#x2F;&#x2F;out:根据输入的3bit in信号选择输出对应的8bit out信号</span><br><span class="k">always</span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><br><span class="k">case</span><span class="p">({</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">})</span><br><span class="mh">3</span><span class="mb">‘b000</span> <span class="o">:</span> <span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0000</span><span class="n">_0001</span><span class="p">;</span> <span class="c1">&#x2F;&#x2F;输入与输出的8种译码对应关系</span><br><span class="mh">3</span><span class="mb">‘b001</span> <span class="o">:</span> <span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0000</span><span class="n">_0010</span><span class="p">;</span><br><span class="mh">3</span><span class="mb">‘b010</span> <span class="o">:</span> <span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0000</span><span class="n">_0100</span><span class="p">;</span><br><span class="mh">3</span><span class="mb">‘b011</span> <span class="o">:</span> <span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0000</span><span class="n">_1000</span><span class="p">;</span><br><span class="mh">3</span><span class="mb">‘b100</span> <span class="o">:</span> <span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0001</span><span class="n">_0000</span><span class="p">;</span><br><span class="mh">3</span><span class="mb">‘b101</span> <span class="o">:</span> <span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0010</span><span class="n">_0000</span><span class="p">;</span><br><span class="mh">3</span><span class="mb">‘b110</span> <span class="o">:</span> <span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0100</span><span class="n">_0000</span><span class="p">;</span><br><span class="mh">3</span><span class="mb">‘b111</span> <span class="o">:</span> <span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b1000</span><span class="n">_0000</span><span class="p">;</span><br><span class="c1">&#x2F;&#x2F;因为case中列举了in所有可能输入的8种情况，且每种情况都有对应确定的输出</span><br><span class="c1">&#x2F;&#x2F;所以此处default可以省略，但是为了以后因不能够完全列举而产生latch</span><br><span class="c1">&#x2F;&#x2F;所以我们默认一定要加上default，并任意指定一种确定的输出情况</span><br><span class="k">default</span><span class="o">:</span> <span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0000</span><span class="n">_0001</span><span class="p">;</span><br><span class="k">endcase</span></p>
<p><span class="k">endmodule</span><br></pre></div></td></tr></tbody></table></p>
<p>根据上面RTL代码综合出的RTL视图如图 11‑4所示。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/decoder005.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/decoder005.png" alt="decoder005"></a></p>
<p>图 11‑4 RTL视图（二）</p>
<p>有了上一章中多路选择器的例子后，我们再使用if-else和case想必大家已经不再陌生，对如何编写一个模块的基本结构也有了大概的了解。通过以上两种不同的代码编写方式，我们进行一个总结：经过验证对比发现两种方法虽然最后实现的功能是一样的，而所得到的RTL视图差别较大，但最后的逻辑资源使用却是相同的（时 序逻辑中不一定相同），说明综合器进行了适当的优化。if-else的这种写法是存在优先级的，即第一个if中的条件的优先级最高，后面的if中的条件的优先级依次递减，好在该if中的条件只有一个，也只会产生一种情况，并不会产生优先级的冲突，所以这里优先级的高低关系并不会对最后的功能产生任何影响。而case在 任何时候都不存在优先级的问题，而是通过判断case中的条件来选择对应的输出。</p>
<p>通过RTL视图我们也能够发现if括号里面的条件会生成名为“EQUAL”的比较器单元，而case则会生成名为“DECODER”的译码器单元，这些单元并不是FPGA硬件底层中最小单元，而只是一种用于RTL视图中易于表达的抽象后的图形，使之更易于我们观察、理解其代码所实现功能的硬件结构的大致样子，也符合了 “HDL（硬件描述语言）”所表述的含义。</p>
<h4 id="4-3-2-4-仿真验证¶"><a href="#4-3-2-4-仿真验证¶" class="headerlink" title="4.3.2.4. 仿真验证¶"></a>4.3.2.4. 仿真验证<a href="#id10" title="永久链接至标题">¶</a></h4><p>仿真文件编写</p>
<p>仿真参考代码如下所示：</p>
<table class="highlighttable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">\`timescale</span> <span class="mh">1</span><span class="n">ns</span><span class="o">/</span><span class="mh">1</span><span class="n">ns</span>
<span class="k">module</span> <span class="n">tb_decoder3_8</span><span class="p">();</span>

<p><span class="c1">&#x2F;&#x2F;reg define</span><br><span class="kt">reg</span> <span class="n">in1</span><span class="p">;</span><br><span class="kt">reg</span> <span class="n">in2</span><span class="p">;</span><br><span class="kt">reg</span> <span class="n">in3</span><span class="p">;</span></p>
<p><span class="c1">&#x2F;&#x2F;wire define</span><br><span class="kt">wire</span> <span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">out</span><span class="p">;</span></p>
<p><span class="c1">&#x2F;&#x2F;初始化输入信号</span><br><span class="k">initial</span> <span class="k">begin</span><br><span class="n">in1</span> <span class="o">&lt;&#x3D;</span> <span class="mh">1</span><span class="mb">‘b0</span><span class="p">;</span><br><span class="n">in2</span> <span class="o">&lt;&#x3D;</span> <span class="mh">1</span><span class="mb">‘b0</span><span class="p">;</span><br><span class="n">in3</span> <span class="o">&lt;&#x3D;</span> <span class="mh">1</span><span class="mb">‘b0</span><span class="p">;</span><br><span class="k">end</span></p>
<p><span class="c1">&#x2F;&#x2F;in1:产生输入随机数，模拟输入端1的输入情况</span><br><span class="k">always</span> <span class="p">#</span><span class="mh">10</span> <span class="n">in1</span> <span class="o">&lt;&#x3D;</span> <span class="p">{</span><span class="nb">$random</span><span class="p">}</span> <span class="o">%</span> <span class="mh">2</span><span class="p">;</span></p>
<p><span class="c1">&#x2F;&#x2F;in2:产生输入随机数，模拟输入端2的输入情况</span><br><span class="k">always</span> <span class="p">#</span><span class="mh">10</span> <span class="n">in2</span> <span class="o">&lt;&#x3D;</span> <span class="p">{</span><span class="nb">$random</span><span class="p">}</span> <span class="o">%</span> <span class="mh">2</span><span class="p">;</span></p>
<p><span class="c1">&#x2F;&#x2F;in3:产生输入随机数，模拟输入端3的输入情况</span><br><span class="k">always</span> <span class="p">#</span><span class="mh">10</span> <span class="n">in3</span> <span class="o">&lt;&#x3D;</span> <span class="p">{</span><span class="nb">$random</span><span class="p">}</span> <span class="o">%</span> <span class="mh">2</span><span class="p">;</span></p>
<p><span class="c1">&#x2F;&#x2F;————————————————————</span><br><span class="k">initial</span> <span class="k">begin</span><br><span class="nb">$timeformat</span><span class="p">(</span><span class="o">-</span><span class="mh">9</span><span class="p">,</span> <span class="mh">0</span><span class="p">,</span> <span class="s">“ns”</span><span class="p">,</span> <span class="mh">6</span><span class="p">);</span><br><span class="nb">$monitor</span><span class="p">(</span><span class="s">“@time %t:in1&#x3D;%b in2&#x3D;%b in3&#x3D;%b out&#x3D;%b”</span><span class="p">,</span><span class="nb">$time</span><span class="p">,</span><span class="n">in1</span><span class="p">,</span><span class="n">in2</span><span class="p">,</span><span class="n">in3</span><span class="p">,</span><span class="n">out</span><span class="p">);</span><br><span class="k">end</span><br><span class="c1">&#x2F;&#x2F;————————————————————</span></p>
<p><span class="c1">&#x2F;&#x2F;————-decoder3_8_inst—————-</span><br><span class="n">decoder3_8</span> <span class="n">decoder3_8_ins</span><br><span class="p">(</span><br><span class="p">.</span><span class="n">in1</span><span class="p">(</span><span class="n">in1</span><span class="p">),</span> <span class="c1">&#x2F;&#x2F;input in1</span><br><span class="p">.</span><span class="n">in2</span><span class="p">(</span><span class="n">in2</span><span class="p">),</span> <span class="c1">&#x2F;&#x2F;input in2</span><br><span class="p">.</span><span class="n">in3</span><span class="p">(</span><span class="n">in3</span><span class="p">),</span> <span class="c1">&#x2F;&#x2F;input in3</span></p>
<p><span class="p">.</span><span class="n">out</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="c1">&#x2F;&#x2F;output [7:0] out</span><br><span class="p">);</span></p>
<p><span class="k">endmodule</span><br></pre></div></td></tr></tbody></table></p>
<p>仿真波形分析</p>
<p>RTL代码设计完成后，我们按照流程编写Testbench，然后启动ModelSim进行仿真测试验证，同样我们也让波形跑了500ns，通过图 11‑5所示的波形我们可以观察到，3个输入的in均为任意随机数，所以由in组成的3bit数据也为随机数，而每个随机数都对一个out输出的8bit值，我们仔细核对 输入in和输出out之间的对应关系，发现波形中3个输入信号in与输出信号out之间的对应关系和编写的代码中的译码关系是完全一致的，完全符合我们代码中的逻辑设计。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/decoder006.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/decoder006.png" alt="decoder006"></a></p>
<p>图 11‑5 仿真波形图</p>
<p>我们观察“Transcript”界面（如图 11‑6所示）中打印的结果，将其与前面绘制的真值表进行比对，发现结果是一致的，从而进一步验证了RTL代码设计的正确性。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/decoder007.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/decoder007.png" alt="decoder007"></a></p>
<p>图 11‑6 打印结果</p>
<h2 id="4-4-章末总结¶"><a href="#4-4-章末总结¶" class="headerlink" title="4.4. 章末总结¶"></a>4.4. 章末总结<a href="#id11" title="永久链接至标题">¶</a></h2><p>本章主要讲解了数字电路中的经典组合逻辑3-8译码器如何用Verilog代码去实现，并对比了if- else语句和case语句所表达的逻辑的异同，希望大家在以后的应用中能够合理、熟练的使用这两种语法。本章所涉及到的大部分语法和知识点都已在上一章中讲解使用过，希望大家能够强化学习，加深对语法的认知，熟练掌握Verilog语言中的“单词（关键字）”和“句子（常用语句）”，并大胆尝试使用。</p>
<p><strong>新语法总结</strong></p>
<p>重点掌握</p>
<p>1、{ ，}位拼接运算符（两个数之间中间用“，”隔开，也可以有多个“，”进行更多位的拼接）</p>
<h2 id="4-5-拓展训练¶"><a href="#4-5-拓展训练¶" class="headerlink" title="4.5. 拓展训练¶"></a>4.5. 拓展训练<a href="#id12" title="永久链接至标题">¶</a></h2><p>体会if-else和case语法的不同，然后自己验证观察if-else实现的译码器中的最后一个else去掉后综合后所生成的RTL视图是怎样的。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/index.html">[野火]FPGA Verilog开发实战指南——基于Altera EP4CE10 征途Mini开发板</a></p>
<p><a target="_blank" rel="noopener" href="https://detail.tmall.com/item.htm?spm=a1z10.5-b-s.w4011-23268010681.61.57491550QDVCO3&id=620698035547&rn=e00cc4fa5edac965f85f43020a263844&abbucket=18"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_static/images/product.png" alt="产品图片"></a></p>
<p>野火征途Mini FPGA开发板，采用Altera EP4CE10F17C8作为主控，包含了FPGA入门必备的硬件，是FPGA入门的性价比之选。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/index.html"></a>»</li>
<li>5. 简单组合逻辑 — 半加器</li>
</ul>
<hr>
<h1 id="5-简单组合逻辑-—-半加器¶"><a href="#5-简单组合逻辑-—-半加器¶" class="headerlink" title="5. 简单组合逻辑 — 半加器¶"></a>5. 简单组合逻辑 — 半加器<a href="#id1" title="永久链接至标题">¶</a></h1><h2 id="5-1-章节导读¶"><a href="#5-1-章节导读¶" class="headerlink" title="5.1. 章节导读¶"></a>5.1. 章节导读<a href="#id2" title="永久链接至标题">¶</a></h2><p>在上面两章节，我们设计并实现了简单组合逻辑中的多路选择器和3-8译码器，本章我们用Verilog语言描述一个具有半加器功能的电路，我们先从半加器作为引开始讲起，并在下一章中通过半加器构成的全加器来引入层次化设计的方法。</p>
<h2 id="5-2-理论学习¶"><a href="#5-2-理论学习¶" class="headerlink" title="5.2. 理论学习¶"></a>5.2. 理论学习<a href="#id3" title="永久链接至标题">¶</a></h2><p>数字电路中加法器是经常用到的一种基本器件，主要用于两个数或者多个数的加和，加法器又分为半加器（half adder）和全加器（full adder）。半加器电路是指对两个输入数据位相加，输出一个结果位和进位，没有进位输入的加法器电路。是实现两个一位二进制数的加法运算电路。而全加器是在半加器的基础上的升级版，除了加数和被加数加和外还要加上上一级传进来的进位信号。</p>
<h2 id="5-3-实战演练¶"><a href="#5-3-实战演练¶" class="headerlink" title="5.3. 实战演练¶"></a>5.3. 实战演练<a href="#id4" title="永久链接至标题">¶</a></h2><h3 id="5-3-1-实验目标¶"><a href="#5-3-1-实验目标¶" class="headerlink" title="5.3.1. 实验目标¶"></a>5.3.1. 实验目标<a href="#id5" title="永久链接至标题">¶</a></h3><p>设计并实现一个半加器，使用开发板上的按键KEY1、KEY2作为被加数输入，选择开发板上的LED灯D7加和的输出，LED灯D8进位输出。</p>
<h3 id="5-3-2-硬件资源¶"><a href="#5-3-2-硬件资源¶" class="headerlink" title="5.3.2. 硬件资源¶"></a>5.3.2. 硬件资源<a href="#id6" title="永久链接至标题">¶</a></h3><p>我们使用开发板上的按键和LED灯进行半加器的验证，选取KEY1、KEY2分别作为被加数in1、被加数in2的信号输入；以LED灯D7为和的输出sum，以LED灯D8为进位的输出count；如图 12‑1所示。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Half_adder002.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Half_adder002.png" alt="Half_adder002"></a></p>
<p>图 12‑1 硬件资源</p>
<p>由原理图可知，征途Mini按键未按下时为高电平、按下后为低电平；LED灯则为低电平点亮。如图 12‑2、图 12‑3所示。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Half_adder003.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Half_adder003.png" alt="Half_adder003"></a></p>
<p>图 12‑2 按键部分原理图</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Half_adder004.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Half_adder004.png" alt="Half_adder004"></a></p>
<p>图 12‑3 LED灯原理图</p>
<h3 id="5-3-3-程序设计¶"><a href="#5-3-3-程序设计¶" class="headerlink" title="5.3.3. 程序设计¶"></a>5.3.3. 程序设计<a href="#id7" title="永久链接至标题">¶</a></h3><h4 id="5-3-3-1-模块框图¶"><a href="#5-3-3-1-模块框图¶" class="headerlink" title="5.3.3.1. 模块框图¶"></a>5.3.3.1. 模块框图<a href="#id8" title="永久链接至标题">¶</a></h4><p>根据功能分析，该工程只需实现一个半加器的功能，所以设计成一个模块即可。模块命名half_adder，半加器由两个1bit的加数，分别命名为in1和in2，输出也有两个信号，为什么会是两个呢？我们不要忘记两个数加和后除了求得的“和”以外会有“进位”的情况，这里我们把进位信号单独拉出来，所以输出就有两个 信号，分别为1bit的sum和cout信号，该模块的功能是实现输入任意两个1bit加数的组合都能求得正确的和与进位值。根据上面的分析设计出的Visio框图如图 12‑4所示。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Half_adder005.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Half_adder005.png" alt="Half_adder005"></a></p>
<p>图 12‑4 模块框图</p>
<p>端口列表与功能总结如表格 12‑1所示。</p>
<p>表格 12‑1 输入输出信号描述</p>
<table>
<thead>
<tr>
<th>信号</th>
<th>位宽</th>
<th>类型</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>in1</td>
<td>1Bit</td>
<td>Input</td>
<td>加数1</td>
</tr>
<tr>
<td>in2</td>
<td>1Bit</td>
<td>Input</td>
<td>加数2</td>
</tr>
<tr>
<td>sum</td>
<td>1Bit</td>
<td>Output</td>
<td>两个加数的求和结果</td>
</tr>
<tr>
<td>cout</td>
<td>1Bit</td>
<td>Output</td>
<td>两个加数求和后的进位信号</td>
</tr>
</tbody></table>
<h4 id="5-3-3-2-波形图绘制¶"><a href="#5-3-3-2-波形图绘制¶" class="headerlink" title="5.3.3.2. 波形图绘制¶"></a>5.3.3.2. 波形图绘制<a href="#id9" title="永久链接至标题">¶</a></h4><p>经分析得，in1和in2均为1bit输入信号，其任意组合有4种，就能够全覆盖验证所有的输入情况，这里我们任意画了4种输入情况，每种输入情况的组合根据相加的结果会对应输出4种求得的和与进位关系，我们根据这种关系可以轻松的列出如表格 12‑2所示的真值表，然后再根据真值表的输入与输出的对应关系画出波形图。其波形如图 12‑5所示，与真值表的关系一一对应。</p>
<p>表格 12‑2 半加器真值表</p>
<table>
<thead>
<tr>
<th>输入（input）</th>
<th>输出（output）</th>
<th>和（sum）</th>
<th>进位（count）</th>
</tr>
</thead>
<tbody><tr>
<td>in1</td>
<td>in2</td>
<td>sum</td>
<td>cout</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Half_adder006.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Half_adder006.png" alt="Half_adder006"></a></p>
<p>图 12‑5 信号波形关系图</p>
<h4 id="5-3-3-3-代码编写¶"><a href="#5-3-3-3-代码编写¶" class="headerlink" title="5.3.3.3. 代码编写¶"></a>5.3.3.3. 代码编写<a href="#id10" title="永久链接至标题">¶</a></h4><p>半加器参考代码如下所示。</p>
<table class="highlighttable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="n">half_adder</span>
<span class="p">(</span>
<span class="k">input</span> <span class="kt">wire</span> <span class="n">in1</span> <span class="p">,</span> <span class="c1">//加数1</span>
<span class="k">input</span> <span class="kt">wire</span> <span class="n">in2</span> <span class="p">,</span> <span class="c1">//加数2</span>

<p><span class="k">output</span> <span class="kt">wire</span> <span class="n">sum</span> <span class="p">,</span> <span class="c1">&#x2F;&#x2F;两个数的加和</span><br><span class="k">output</span> <span class="kt">wire</span> <span class="n">cout</span> <span class="c1">&#x2F;&#x2F;两个数加和后的进位</span><br><span class="p">);</span></p>
<p><span class="c1">&#x2F;&#x2F;sum:两个数加和的输出</span><br><span class="c1">&#x2F;&#x2F;cout:两个数进位的输出</span><br><span class="k">assign</span> <span class="p">{</span><span class="n">cout</span><span class="p">,</span> <span class="n">sum</span><span class="p">}</span> <span class="o">&#x3D;</span> <span class="n">in1</span> <span class="o">+</span> <span class="n">in2</span><span class="p">;</span></p>
<p><span class="k">endmodule</span><br></pre></div></td></tr></tbody></table></p>
<p>根据上面RTL代码综合出的RTL视图如图 12‑6所示，我们可以看到加法器被抽象为一个“ADDER”的基本单元。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Half_adder007.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Half_adder007.png" alt="Half_adder007"></a></p>
<p>图 12‑6 RTL视图</p>
<h4 id="5-3-3-4-仿真验证¶"><a href="#5-3-3-4-仿真验证¶" class="headerlink" title="5.3.3.4. 仿真验证¶"></a>5.3.3.4. 仿真验证<a href="#id11" title="永久链接至标题">¶</a></h4><p>仿真文件编写</p>
<p>半加器仿真参考代码如下所示。</p>
<table class="highlighttable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">\`timescale</span> <span class="mh">1</span><span class="n">ns</span><span class="o">/</span><span class="mh">1</span><span class="n">ns</span>
<span class="k">module</span> <span class="n">tb_half_adder</span><span class="p">();</span>

<p><span class="c1">&#x2F;&#x2F;reg define</span><br><span class="kt">reg</span> <span class="n">in1</span><span class="p">;</span><br><span class="kt">reg</span> <span class="n">in2</span><span class="p">;</span></p>
<p><span class="c1">&#x2F;&#x2F;wire define</span><br><span class="kt">wire</span> <span class="n">sum</span><span class="p">;</span><br><span class="kt">wire</span> <span class="n">cout</span><span class="p">;</span></p>
<p><span class="c1">&#x2F;&#x2F;初始化输入信号</span><br><span class="k">initial</span> <span class="k">begin</span><br><span class="n">in1</span> <span class="o">&lt;&#x3D;</span> <span class="mh">1</span><span class="mb">‘b0</span><span class="p">;</span><br><span class="n">in2</span> <span class="o">&lt;&#x3D;</span> <span class="mh">1</span><span class="mb">‘b0</span><span class="p">;</span><br><span class="k">end</span></p>
<p><span class="c1">&#x2F;&#x2F;in1:产生输入随机数，模拟加数1的输入情况</span><br><span class="c1">&#x2F;&#x2F;取模求余数，产生随机数1’b0、1’b1，每隔10ns产生一次随机数</span><br><span class="k">always</span> <span class="p">#</span><span class="mh">10</span> <span class="n">in1</span> <span class="o">&lt;&#x3D;</span> <span class="p">{</span><span class="nb">$random</span><span class="p">}</span> <span class="o">%</span> <span class="mh">2</span><span class="p">;</span></p>
<p><span class="c1">&#x2F;&#x2F;in2:产生输入随机数，模拟加数2的输入情况</span><br><span class="k">always</span> <span class="p">#</span><span class="mh">10</span> <span class="n">in2</span> <span class="o">&lt;&#x3D;</span> <span class="p">{</span><span class="nb">$random</span><span class="p">}</span> <span class="o">%</span> <span class="mh">2</span><span class="p">;</span></p>
<p><span class="c1">&#x2F;&#x2F;————————————————————</span><br><span class="k">initial</span> <span class="k">begin</span><br><span class="nb">$timeformat</span><span class="p">(</span><span class="o">-</span><span class="mh">9</span><span class="p">,</span> <span class="mh">0</span><span class="p">,</span> <span class="s">“ns”</span><span class="p">,</span> <span class="mh">6</span><span class="p">);</span><br><span class="nb">$monitor</span><span class="p">(</span><span class="s">“@time %t:in1&#x3D;%b in2&#x3D;%b sum&#x3D;%b cout&#x3D;%b”</span><span class="p">,</span><span class="nb">$time</span><span class="p">,</span><span class="n">in1</span><span class="p">,</span><span class="n">in2</span><span class="p">,</span><span class="n">sum</span><span class="p">,</span><span class="n">cout</span><span class="p">);</span><br><span class="k">end</span><br><span class="c1">&#x2F;&#x2F;————————————————————</span></p>
<p><span class="c1">&#x2F;&#x2F;——————–half_adder_inst—————–</span><br><span class="n">half_adder</span> <span class="n">half_adder_inst</span><br><span class="p">(</span><br><span class="p">.</span><span class="n">in1</span> <span class="p">(</span><span class="n">in1</span> <span class="p">),</span> <span class="c1">&#x2F;&#x2F;input in1</span><br><span class="p">.</span><span class="n">in2</span> <span class="p">(</span><span class="n">in2</span> <span class="p">),</span> <span class="c1">&#x2F;&#x2F;input in2</span></p>
<p><span class="p">.</span><span class="n">sum</span> <span class="p">(</span><span class="n">sum</span> <span class="p">),</span> <span class="c1">&#x2F;&#x2F;output sum</span><br><span class="p">.</span><span class="n">cout</span> <span class="p">(</span><span class="n">cout</span> <span class="p">)</span> <span class="c1">&#x2F;&#x2F;output cout</span><br><span class="p">);</span></p>
<p><span class="k">endmodule</span><br></pre></div></td></tr></tbody></table></p>
<p>仿真波形分析</p>
<p>Testbench编写完成后，我们启动ModelSim进行功能仿真验证，同样我们也让波形跑了500ns，通过图 12‑7所示的波形我们可以观察到，in1和in2输入的值均为1bit随机数，而与之对应的sum和cout都是在输入变化的同一时刻立即变化，我们仔细核对每一组输入和输出之间的对应关系，发现波形中的“+”计算结果都是正确的，完全符合我们代码中的逻辑设计。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Half_adder008.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Half_adder008.png" alt="Half_adder008"></a></p>
<p>图 12‑7 仿真波形图</p>
<p>我们通过观察“Transcript”界面（如图 12‑8所示）中打印的结果发现与前面绘制真值表的结果一一对应，从而进一步验证了RTL代码设计的正确性。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Half_adder009.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Half_adder009.png" alt="Half_adder009"></a></p>
<p>图 12‑8 打印结果</p>
<h3 id="5-3-4-上板验证¶"><a href="#5-3-4-上板验证¶" class="headerlink" title="5.3.4. 上板验证¶"></a>5.3.4. 上板验证<a href="#id12" title="永久链接至标题">¶</a></h3><h4 id="5-3-4-1-引脚约束¶"><a href="#5-3-4-1-引脚约束¶" class="headerlink" title="5.3.4.1. 引脚约束¶"></a>5.3.4.1. 引脚约束<a href="#id13" title="永久链接至标题">¶</a></h4><p>仿真验证通过后，准备上板验证，上板验证之前先要进行引脚约束。工程中各输入输出信号与开发板引脚对应关系如表格 12‑3所示。引脚配置如图 12‑9所示。</p>
<p>表格 12‑3 引脚分配表</p>
<table>
<thead>
<tr>
<th><strong>信号名</strong></th>
<th><strong>信号类型</strong></th>
<th><strong>对应引脚</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td>in1</td>
<td>Input</td>
<td>M2</td>
<td>按键</td>
</tr>
<tr>
<td>in2</td>
<td>Input</td>
<td>M1</td>
<td>按键</td>
</tr>
<tr>
<td>sum</td>
<td>Output</td>
<td>L7</td>
<td>LED灯</td>
</tr>
<tr>
<td>count</td>
<td>Output</td>
<td>M6</td>
<td>LED灯</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Half_adder010.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Half_adder010.png" alt="Half_adder010"></a></p>
<p>图 12‑9 引脚配置图</p>
<h4 id="5-3-4-2-结果验证¶"><a href="#5-3-4-2-结果验证¶" class="headerlink" title="5.3.4.2. 结果验证¶"></a>5.3.4.2. 结果验证<a href="#id14" title="永久链接至标题">¶</a></h4><p>如图 12‑10所示，开发板连接5V直流电源和USB-Blaster下载器JTAG端口。线路正确连接后，打开开关为板卡上电。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Half_adder011.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Half_adder011.png" alt="Half_adder011"></a></p>
<p>图 12‑10 程序下载连线图</p>
<p>如图 12‑11所示，使用“Programmer”为开发板下载程序。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Half_adder012.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Half_adder012.png" alt="Half_adder012"></a></p>
<p>图 12‑11 程序下载窗口</p>
<p>程序下载完毕后，开始进行结果验证。如图 12‑12所示，当按键KEY1、KEY2同时按下，in1和in2输出均为低电平，得到和sum为0，进位count为0，D7、D8均被点亮。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Half_adder013.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Half_adder013.png" alt="Half_adder013"></a></p>
<p>图 12‑12 上板验证（一）</p>
<p>如图 12‑13、图 12‑14所示，只按下按键KEY1或KEY2，in1或in2输出低电平，得到和sum为1，进位count为0， D8被点亮。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Half_adder014.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Half_adder014.png" alt="Half_adder014"></a></p>
<p>图 12‑13 上板验证（二）</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Half_adder015.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Half_adder015.png" alt="Half_adder015"></a></p>
<p>图 12‑14 上板验证（三）</p>
<p>如图 12‑15所示，两按键均未按下，in1和in2输出均为高电平，得到和sum为0，进位count为1，D7被点亮。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Half_adder016.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Half_adder016.png" alt="Half_adder016"></a></p>
<p>图 12‑15 上板验证（四）</p>
<h2 id="5-4-章末总结¶"><a href="#5-4-章末总结¶" class="headerlink" title="5.4. 章末总结¶"></a>5.4. 章末总结<a href="#id15" title="永久链接至标题">¶</a></h2><p>本章主要讲解了数字电路中进行加法运算的基本加法单元——加法器，而我们设计的是一个没有前级进位功能且加数只有1bit的半加器，主要目的是为了引出下一章中的全加器。本章例子中所使用的语法和设计方法流程基本和之前相同，希望学习者能够进一步巩固开发方法和基本开发流程，认真完成章末的思考题。</p>
<p><strong>新语法总结</strong></p>
<p>重点掌握</p>
<p>+（最常用的数学运算符）</p>
<h2 id="5-5-拓展训练¶"><a href="#5-5-拓展训练¶" class="headerlink" title="5.5. 拓展训练¶"></a>5.5. 拓展训练<a href="#id16" title="永久链接至标题">¶</a></h2><ol>
<li><p>尝试用always语句块的方式实现半加器；</p>
</li>
<li><p>我们在数电中往往通过真值表把组合逻辑化简成由与非门构成的最简电路形式，然后再根据表达式用Verilog语言实现。</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/index.html">[野火]FPGA Verilog开发实战指南——基于Altera EP4CE10 征途Mini开发板</a></p>
<p><a target="_blank" rel="noopener" href="https://detail.tmall.com/item.htm?spm=a1z10.5-b-s.w4011-23268010681.61.57491550QDVCO3&id=620698035547&rn=e00cc4fa5edac965f85f43020a263844&abbucket=18"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_static/images/product.png" alt="产品图片"></a></p>
<p>野火征途Mini FPGA开发板，采用Altera EP4CE10F17C8作为主控，包含了FPGA入门必备的硬件，是FPGA入门的性价比之选。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/index.html"></a>»</li>
<li>6. 避免Latch的产生</li>
</ul>
<hr>
<h1 id="6-避免Latch的产生¶"><a href="#6-避免Latch的产生¶" class="headerlink" title="6. 避免Latch的产生¶"></a>6. 避免Latch的产生<a href="#latch" title="永久链接至标题">¶</a></h1><h2 id="6-1-章节导读¶"><a href="#6-1-章节导读¶" class="headerlink" title="6.1. 章节导读¶"></a>6.1. 章节导读<a href="#id1" title="永久链接至标题">¶</a></h2><p>本章主要讲解Latch是什么，以及它的产生、危害、如何避免等相关知识，目的是为了让大家在设计相关的电路时能够更加规范，从而避免出现不可预测的问题。</p>
<h2 id="6-2-Latch是什么¶"><a href="#6-2-Latch是什么¶" class="headerlink" title="6.2. Latch是什么¶"></a>6.2. Latch是什么<a href="#id2" title="永久链接至标题">¶</a></h2><p>Latch其实就是锁存器，是一种在异步电路系统中，对输入信号电平敏感的单元，用来存储信息。锁存器在数据未锁存时，输出端的信号随输入信号变化，就像信号通过一个缓冲器，一旦锁存信号有效，则数据被锁存，输入信号不起作用。因此，锁存器也被称为透明锁存器，指的是不锁存时输出对于输入是透明的。</p>
<h2 id="6-3-Latch的危害¶"><a href="#6-3-Latch的危害¶" class="headerlink" title="6.3. Latch的危害¶"></a>6.3. Latch的危害<a href="#id3" title="永久链接至标题">¶</a></h2><p>之所以在这里讲关于Latch的问题是因为只有组合逻辑才会产生这种问题，产生Latch是我们在同步电路中尽量避免的，但并不表示Latch没有用的或者说是错误的，Latch在异步电路中是非常有用的，只是我们设计的是同步电路，要尽量避免。</p>
<p>在同步电路中Latch会产生不好的效果，如对毛刺敏感；不能异步复位，上电后处于不定态；还会让静态时序分析变得十分复杂；在FPGA的资源中，大部分器件没有锁存器这个东西，所以需要用使用寄存器来组成锁存器所以会占用更多逻辑资源；在ASIC设计中，锁存器也会带来额外的延时和DFT，并不利于提高系统的工作频 率，所以要避免产生。在这里我们把会产生组合逻辑的几种情况列举出来，希望大家以后能够避免出现类似的问题。</p>
<h2 id="6-4-几种产生Latch的情况¶"><a href="#6-4-几种产生Latch的情况¶" class="headerlink" title="6.4. 几种产生Latch的情况¶"></a>6.4. 几种产生Latch的情况<a href="#id4" title="永久链接至标题">¶</a></h2><p>关于Latch的介绍如果能够理解原理最好，如对原理理解不透彻可以先记住规范的写法，避免产生不可控的因素，从而综合出更好的电路。以下不规范的3种产生Latch的写法一定要尽量避免。</p>
<ol>
<li><p>组合逻辑中if语句没有else；</p>
</li>
<li><p>组合逻辑中case的条件不能够完全列举时且不写default；</p>
</li>
<li><p>组合逻辑中输出变量赋值给自己。</p>
</li>
</ol>
<p><strong>情况一：</strong>组合逻辑中if语句没有else</p>
<table class="highlighttable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="n">latch_one</span>
<span class="p">(</span>
<span class="k">input</span> <span class="kt">wire</span> <span class="n">in1</span> <span class="p">,</span> <span class="c1">//输入信号in1</span>
<span class="k">input</span> <span class="kt">wire</span> <span class="n">in2</span> <span class="p">,</span> <span class="c1">//输入信号in2</span>
<span class="k">input</span> <span class="kt">wire</span> <span class="n">in3</span> <span class="p">,</span> <span class="c1">//输入信号in3</span>

<p><span class="k">output</span> <span class="kt">reg</span> <span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">out</span> <span class="c1">&#x2F;&#x2F;输出信号out</span><br><span class="p">);</span></p>
<p><span class="c1">&#x2F;&#x2F;out:根据3个输入信号选择输出对应的8bit out信号</span><br><span class="k">always</span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><br><span class="k">if</span><span class="p">({</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">}</span> <span class="o">&#x3D;&#x3D;</span> <span class="mh">3</span><span class="mb">‘b000</span><span class="p">)</span><br><span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0000</span><span class="n">_0001</span><span class="p">;</span><br><span class="k">else</span> <span class="k">if</span><span class="p">({</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">}</span> <span class="o">&#x3D;&#x3D;</span> <span class="mh">3</span><span class="mb">‘b001</span><span class="p">)</span><br><span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0000</span><span class="n">_0010</span><span class="p">;</span><br><span class="k">else</span> <span class="k">if</span><span class="p">({</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">}</span> <span class="o">&#x3D;&#x3D;</span> <span class="mh">3</span><span class="mb">‘b010</span><span class="p">)</span><br><span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0000</span><span class="n">_0100</span><span class="p">;</span><br><span class="k">else</span> <span class="k">if</span><span class="p">({</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">}</span> <span class="o">&#x3D;&#x3D;</span> <span class="mh">3</span><span class="mb">‘b011</span><span class="p">)</span><br><span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0000</span><span class="n">_1000</span><span class="p">;</span><br><span class="k">else</span> <span class="k">if</span><span class="p">({</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">}</span> <span class="o">&#x3D;&#x3D;</span> <span class="mh">3</span><span class="mb">‘b100</span><span class="p">)</span><br><span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0001</span><span class="n">_0000</span><span class="p">;</span><br><span class="k">else</span> <span class="k">if</span><span class="p">({</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">}</span> <span class="o">&#x3D;&#x3D;</span> <span class="mh">3</span><span class="mb">‘b101</span><span class="p">)</span><br><span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0010</span><span class="n">_0000</span><span class="p">;</span><br><span class="k">else</span> <span class="k">if</span><span class="p">({</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">}</span> <span class="o">&#x3D;&#x3D;</span> <span class="mh">3</span><span class="mb">‘b110</span><span class="p">)</span><br><span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0100</span><span class="n">_0000</span><span class="p">;</span><br><span class="k">else</span> <span class="k">if</span><span class="p">({</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">}</span> <span class="o">&#x3D;&#x3D;</span> <span class="mh">3</span><span class="mb">‘b111</span><span class="p">)</span><br><span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b1000</span><span class="n">_0000</span><span class="p">;</span><br><span class="c1">&#x2F;&#x2F; else 把最后一个if的else注释掉</span><br><span class="c1">&#x2F;&#x2F; out &#x3D; 8’b0000_0001;</span></p>
<p><span class="k">endmodule</span><br></pre></div></td></tr></tbody></table></p>
<p>根据上面RTL代码综合出的RTL视图如图 14‑1所示，我们可以看到其结构相当的复杂，红色中的结构即为Latch锁存器，如图 14‑2所示。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Latch002.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Latch002.png" alt="Latch002"></a></p>
<p>图 14‑1 RTL视图（一）</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Latch003.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Latch003.png" alt="Latch003"></a></p>
<p>图 14‑2 Latch锁存器</p>
<p>在综合后的界面的“Messages”窗口中提示输出有“latch”产生，此时我就应该关注一下此“latch”是否真的是我们有意产生的。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Latch004.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Latch004.png" alt="Latch004"></a></p>
<p>图 14‑3 Messages窗口提示</p>
<p><strong>情况二：</strong>组合逻辑中case的条件不能够完全列举且不写default</p>
<table class="highlighttable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="n">latch_two</span>
<span class="p">(</span>
<span class="k">input</span> <span class="kt">wire</span> <span class="n">in1</span> <span class="p">,</span> <span class="c1">//输入信号in1</span>
<span class="k">input</span> <span class="kt">wire</span> <span class="n">in2</span> <span class="p">,</span> <span class="c1">//输入信号in2</span>
<span class="k">input</span> <span class="kt">wire</span> <span class="n">in3</span> <span class="p">,</span> <span class="c1">//输入信号in2</span>

<p><span class="k">output</span> <span class="kt">reg</span> <span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">out</span> <span class="c1">&#x2F;&#x2F;输出信号out</span><br><span class="p">);</span></p>
<p><span class="c1">&#x2F;&#x2F;out:根据3个输入信号选择输出对应的8bit out信号</span><br><span class="k">always</span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><br><span class="k">case</span><span class="p">({</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">})</span><br><span class="mh">3</span><span class="mb">‘b000</span> <span class="o">:</span> <span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0000</span><span class="n">_0001</span><span class="p">;</span><br><span class="mh">3</span><span class="mb">‘b001</span> <span class="o">:</span> <span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0000</span><span class="n">_0010</span><span class="p">;</span><br><span class="mh">3</span><span class="mb">‘b010</span> <span class="o">:</span> <span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0000</span><span class="n">_0100</span><span class="p">;</span><br><span class="mh">3</span><span class="mb">‘b011</span> <span class="o">:</span> <span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0000</span><span class="n">_1000</span><span class="p">;</span><br><span class="mh">3</span><span class="mb">‘b100</span> <span class="o">:</span> <span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0001</span><span class="n">_0000</span><span class="p">;</span><br><span class="mh">3</span><span class="mb">‘b101</span> <span class="o">:</span> <span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0010</span><span class="n">_0000</span><span class="p">;</span><br><span class="mh">3</span><span class="mb">‘b110</span> <span class="o">:</span> <span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0100</span><span class="n">_0000</span><span class="p">;</span><br><span class="c1">&#x2F;&#x2F;把最后一种情况和default都注释掉，使case的条件不能够完全列举</span><br><span class="c1">&#x2F;&#x2F;3’b111 : out &#x3D; 8’b1000_0000;</span><br><span class="c1">&#x2F;&#x2F;default: out &#x3D; 8’b0000_0001;</span><br><span class="k">endcase</span></p>
<p><span class="k">endmodule</span><br></pre></div></td></tr></tbody></table></p>
<p>根据上面RTL代码综合出的RTL视图如图 14‑4所示，我们可以看到也产生了latch。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Latch005.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Latch005.png" alt="Latch005"></a></p>
<p>图 14‑4 RTL视图（二）</p>
<p><strong>情况三：</strong>组合逻辑中输出变量赋值给自己（一）</p>
<table class="highlighttable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="n">latch_three</span>
<span class="p">(</span>
<span class="k">input</span> <span class="kt">wire</span> <span class="n">in1</span> <span class="p">,</span> <span class="c1">//输入信号in1</span>
<span class="k">input</span> <span class="kt">wire</span> <span class="n">in2</span> <span class="p">,</span> <span class="c1">//输入信号in2</span>
<span class="k">input</span> <span class="kt">wire</span> <span class="n">in3</span> <span class="p">,</span> <span class="c1">//输入信号in3</span>

<p><span class="k">output</span> <span class="kt">reg</span> <span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">out</span> <span class="c1">&#x2F;&#x2F;输出信号out</span><br><span class="p">);</span></p>
<p><span class="c1">&#x2F;&#x2F;out:根据3个输入信号选择输出对应的8bit out信号</span><br><span class="k">always</span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><br><span class="k">if</span><span class="p">({</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">}</span> <span class="o">&#x3D;&#x3D;</span> <span class="mh">3</span><span class="mb">‘b000</span><span class="p">)</span><br><span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0000</span><span class="n">_0001</span><span class="p">;</span><br><span class="k">else</span> <span class="k">if</span><span class="p">({</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">}</span> <span class="o">&#x3D;&#x3D;</span> <span class="mh">3</span><span class="mb">‘b001</span><span class="p">)</span><br><span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0000</span><span class="n">_0010</span><span class="p">;</span><br><span class="n">elseif</span><span class="p">({</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">}</span> <span class="o">&#x3D;&#x3D;</span> <span class="mh">3</span><span class="mb">‘b010</span><span class="p">)</span><br><span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0000</span><span class="n">_0100</span><span class="p">;</span><br><span class="n">elseif</span><span class="p">({</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">}</span> <span class="o">&#x3D;&#x3D;</span> <span class="mh">3</span><span class="mb">‘b011</span><span class="p">)</span><br><span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0000</span><span class="n">_1000</span><span class="p">;</span><br><span class="n">elseif</span><span class="p">({</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">}</span> <span class="o">&#x3D;&#x3D;</span> <span class="mh">3</span><span class="mb">‘b100</span><span class="p">)</span><br><span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0001</span><span class="n">_0000</span><span class="p">;</span><br><span class="n">elseif</span><span class="p">({</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">}</span> <span class="o">&#x3D;&#x3D;</span> <span class="mh">3</span><span class="mb">‘b101</span><span class="p">)</span><br><span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0010</span><span class="n">_0000</span><span class="p">;</span><br><span class="n">elseif</span><span class="p">({</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">}</span> <span class="o">&#x3D;&#x3D;</span> <span class="mh">3</span><span class="mb">‘b110</span><span class="p">)</span><br><span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0100</span><span class="n">_0000</span><span class="p">;</span><br><span class="n">elseif</span><span class="p">({</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">}</span> <span class="o">&#x3D;&#x3D;</span> <span class="mh">3</span><span class="mb">‘b111</span><span class="p">)</span><br><span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b1000</span><span class="n">_0000</span><span class="p">;</span><br><span class="k">else</span><br><span class="n">out</span> <span class="o">&#x3D;</span> <span class="n">out</span><span class="p">;</span><span class="c1">&#x2F;&#x2F;输出变量赋值给自己</span></p>
<p><span class="k">endmodule</span><br></pre></div></td></tr></tbody></table></p>
<p>根据上面RTL代码综合出的RTL视图如图 14‑5所示，我们可以看到产生了Latch。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Latch006.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Latch006.png" alt="Latch006"></a></p>
<p>图 14‑5 RTL视图（三）</p>
<p><strong>情况三：</strong>组合逻辑中输出变量赋值给自己（二）</p>
<table class="highlighttable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="n">latch_three</span>
<span class="p">(</span>
<span class="k">input</span> <span class="kt">wire</span> <span class="n">in1</span> <span class="p">,</span> <span class="c1">//输入信号in1</span>
<span class="k">input</span> <span class="kt">wire</span> <span class="n">in2</span> <span class="p">,</span> <span class="c1">//输入信号in2</span>
<span class="k">input</span> <span class="kt">wire</span> <span class="n">in3</span> <span class="p">,</span> <span class="c1">//输入信号in2</span>

<p><span class="k">output</span> <span class="kt">reg</span> <span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">out</span> <span class="c1">&#x2F;&#x2F;输出信号out</span><br><span class="p">);</span></p>
<p><span class="c1">&#x2F;&#x2F;out:根据3个输入信号选择输出对应的8bit out信号</span><br><span class="k">always</span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><br><span class="k">case</span><span class="p">({</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">})</span><br><span class="mh">3</span><span class="mb">‘b000</span> <span class="o">:</span> <span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0000</span><span class="n">_0001</span><span class="p">;</span><br><span class="mh">3</span><span class="mb">‘b001</span> <span class="o">:</span> <span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0000</span><span class="n">_0010</span><span class="p">;</span><br><span class="mh">3</span><span class="mb">‘b010</span> <span class="o">:</span> <span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0000</span><span class="n">_0100</span><span class="p">;</span><br><span class="mh">3</span><span class="mb">‘b011</span> <span class="o">:</span> <span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0000</span><span class="n">_1000</span><span class="p">;</span><br><span class="mh">3</span><span class="mb">‘b100</span> <span class="o">:</span> <span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0001</span><span class="n">_0000</span><span class="p">;</span><br><span class="mh">3</span><span class="mb">‘b101</span> <span class="o">:</span> <span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0010</span><span class="n">_0000</span><span class="p">;</span><br><span class="mh">3</span><span class="mb">‘b110</span> <span class="o">:</span> <span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0100</span><span class="n">_0000</span><span class="p">;</span><br><span class="mh">3</span><span class="mb">‘b111</span> <span class="o">:</span> <span class="n">out</span> <span class="o">&#x3D;</span> <span class="n">out</span><span class="p">;</span> <span class="c1">&#x2F;&#x2F;输出变量赋值给自己</span><br><span class="k">default</span><span class="o">:</span> <span class="n">out</span> <span class="o">&#x3D;</span> <span class="mh">8</span><span class="mb">‘b0000</span><span class="n">_0001</span><span class="p">;</span><br><span class="k">endcase</span></p>
<p><span class="k">endmodule</span><br></pre></div></td></tr></tbody></table></p>
<p>根据上面RTL代码综合出的RTL视图如图 14‑6所示，我们可以看到也产生了Latch。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Latch007.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Latch007.png" alt="Latch007"></a></p>
<p>图 14‑6 RTL视图（四）</p>
<h2 id="6-5-章末总结¶"><a href="#6-5-章末总结¶" class="headerlink" title="6.5. 章末总结¶"></a>6.5. 章末总结<a href="#id5" title="永久链接至标题">¶</a></h2><p>本章重点讲解了Latch是什么、产生的原因以及如何避免Latch的产生，我们为大家进行了总结，大家一定要记住：在组合逻辑中一定要避免输出信号处于不定的状态，一定要让输出无论在任何条件下都有一个已知的状态，就可以避免Latch的产生。Latch作为一种基本电路单元，会影响到电路的时序性能，应尽量避免使 用，但出现Latch造成设计与意图不符的情况，是由于设计人员代码不规范造成的。但也随着综合器越来越优化使之可以更精准的识别出该代码是否为设计者真正想要的Latch，并给出必要的提示。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/index.html">[野火]FPGA Verilog开发实战指南——基于Altera EP4CE10 征途Mini开发板</a></p>
<p><a target="_blank" rel="noopener" href="https://detail.tmall.com/item.htm?spm=a1z10.5-b-s.w4011-23268010681.61.57491550QDVCO3&id=620698035547&rn=e00cc4fa5edac965f85f43020a263844&abbucket=18"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_static/images/product.png" alt="产品图片"></a></p>
<p>野火征途Mini FPGA开发板，采用Altera EP4CE10F17C8作为主控，包含了FPGA入门必备的硬件，是FPGA入门的性价比之选。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/index.html"></a>»</li>
<li>7. 时序逻辑的开始 — 寄存器</li>
</ul>
<hr>
<h1 id="7-时序逻辑的开始-—-寄存器¶"><a href="#7-时序逻辑的开始-—-寄存器¶" class="headerlink" title="7. 时序逻辑的开始 — 寄存器¶"></a>7. 时序逻辑的开始 — 寄存器<a href="#id1" title="永久链接至标题">¶</a></h1><h2 id="7-1-章节导读¶"><a href="#7-1-章节导读¶" class="headerlink" title="7.1. 章节导读¶"></a>7.1. 章节导读<a href="#id2" title="永久链接至标题">¶</a></h2><p>前面几章我们重点介绍了用Verilog语言实现的几种简单组合逻辑，目的是让大家熟悉语法，学会设计的思想、方法和步骤。从本章开始我们开始进入到时序逻辑的设计，要进行时序逻辑的设计，那寄存器就是必不可少的元素，让我们一起来认识一下什么是寄存器，它能做什么、有什么特性、如何用Verilog语言来描述。</p>
<h2 id="7-2-理论学习¶"><a href="#7-2-理论学习¶" class="headerlink" title="7.2. 理论学习¶"></a>7.2. 理论学习<a href="#id3" title="永久链接至标题">¶</a></h2><p>我们学习过数电知识的也都了解，组合逻辑最大的缺点就是会存在竞争冒险（详细可参考前面推荐的数字电路相关的书，这里不再在进行详细解释）问题，这种竞争冒险问题是非常危险的，常常会引起电路的不稳定性和工作时的不确定性，而我们使用时序逻辑就可以极大的避免这种问题，从而使系统更加稳定。而时序逻辑最基本的单元就是 寄存器，寄存器具有存储功能，一般是由D触发器构成，由时钟脉冲控制，每个D触发器（D Flip Flop ，DFF）能够存储一位二进制码。</p>
<p>D触发器的功能为：在一个脉冲信号（一般为晶振产生的时钟脉冲）上升沿或下降沿的作用下，将信号从输入端D送到输出端Q，如果时钟脉冲的边沿信号不来则输入信号保持原值，且寄存器拥有复位清零功能，其复位又分为同步复位和异步复位。</p>
<p>区分一个设计是组合逻辑电路还是时序逻辑电路主要是看数据工作是不是在时钟沿下进行的，在FPGA的设计中，复杂的电路设计都要用到时序逻辑电路，往往都是以时序逻辑电路为主，组合逻辑为辅的混合逻辑电路。</p>
<h2 id="7-3-实战演练¶"><a href="#7-3-实战演练¶" class="headerlink" title="7.3. 实战演练¶"></a>7.3. 实战演练<a href="#id4" title="永久链接至标题">¶</a></h2><h3 id="7-3-1-实验目标¶"><a href="#7-3-1-实验目标¶" class="headerlink" title="7.3.1. 实验目标¶"></a>7.3.1. 实验目标<a href="#id5" title="永久链接至标题">¶</a></h3><p>前面章节中，我们设计并编写了使用按键控制LED灯的工程，在本章节我们同样使用这个例子，虽然实验效果相同，但本章是使用D触发器来进行控制的，和使用组合逻辑的控制方法有所不同。</p>
<p>当按键未按下时led灯处于熄灭状态；当按键被按下时led灯被点亮。</p>
<h3 id="7-3-2-硬件资源¶"><a href="#7-3-2-硬件资源¶" class="headerlink" title="7.3.2. 硬件资源¶"></a>7.3.2. 硬件资源<a href="#id6" title="永久链接至标题">¶</a></h3><p>与“点亮LED灯”的实验工程相同，我们需要用到开发板上的按键和LED灯，我们要使用按键KEY1点亮LED灯D6，如图 15‑1所示。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/register002.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/register002.png" alt="register002"></a></p>
<p>图 15‑1 硬件资源</p>
<p>由原理图可知，征途Mini开发板的按键未按下时为高电平、按下后为低电平；LED灯则为低电平点亮。如图 15‑2、图 15‑3所示。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/register003.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/register003.png" alt="register003"></a></p>
<p>图 15‑2 按键部分原理图</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/register004.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/register004.png" alt="register004"></a></p>
<p>图 15‑3 LED灯原理图</p>
<h3 id="7-3-3-程序设计¶"><a href="#7-3-3-程序设计¶" class="headerlink" title="7.3.3. 程序设计¶"></a>7.3.3. 程序设计<a href="#id7" title="永久链接至标题">¶</a></h3><h4 id="7-3-3-1-模块框图¶"><a href="#7-3-3-1-模块框图¶" class="headerlink" title="7.3.3.1. 模块框图¶"></a>7.3.3.1. 模块框图<a href="#id8" title="永久链接至标题">¶</a></h4><p>我们先给模块取一个名字叫flip_flop，接下来是分析端口信号：D触发器能够正常工作一定有时钟，每当时钟的“沿（上升沿或下降沿）”来到时我们采集到稳定有效的数据；其次还需要的就是复位信号，用于让触发器的回到初始状态把数据清零；因为是用按键控制led灯的亮灭，所以输入端我们还需要一个按键控制信号；输 出就只有一个控制led灯的信号，这里我们的输入输出信号都是1bit的。根据上面的分析设计出的Visio框图如图 15‑4所示。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/register005.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/register005.png" alt="register005"></a></p>
<p>图 15‑4 模块框图</p>
<p>端口列表与功能总结如表格 15‑1所示。</p>
<p>表格 15‑1 输入输出信号描述</p>
<p>|<br>信号</p>
<p> | </p>
<p>位宽</p>
<p> | </p>
<p>类型</p>
<p> | </p>
<p>功能描述</p>
<p> |<br>| — | — | — | — |<br>| </p>
<p>sys_clk</p>
<p> | </p>
<p>1Bit</p>
<p> | </p>
<p>Input</p>
<p> | </p>
<p>工作时钟，频率50MHz</p>
<p> |<br>| </p>
<p>sys_rst_n</p>
<p> | </p>
<p>1Bit</p>
<p> | </p>
<p>Input</p>
<p> | </p>
<p>复位信号，低电平有效</p>
<p> |<br>| </p>
<p>key_in</p>
<p> | </p>
<p>1Bit</p>
<p> | </p>
<p>Input</p>
<p> | </p>
<p>按键信号输入</p>
<p> |<br>| </p>
<p>led_out</p>
<p> | </p>
<p>1Bit</p>
<p> | </p>
<p>Output</p>
<p> | </p>
<p>输出控制LED灯</p>
<p> |</p>
<h4 id="7-3-3-2-波形图绘制¶"><a href="#7-3-3-2-波形图绘制¶" class="headerlink" title="7.3.3.2. 波形图绘制¶"></a>7.3.3.2. 波形图绘制<a href="#id9" title="永久链接至标题">¶</a></h4><p>D触发器根据复位的不同分为两种，一种是同步复位的D触发器，另一种时异步复位的D触发器，下面就是详细介绍这两种D触发器的异同，以及波形的设计。从本章开始,我们后面设计的工程项目都主要以时序逻辑为主，其中波形的设计尤为关键，希望大家能够认真体会其中的精妙之处。</p>
<p><strong>同步复位的D触发器</strong></p>
<p>同步复位的D触发器中的“同步”是和工作时钟同步的意思，也就是说，当时钟的上升沿（也可以是下降沿，一般习惯上为上升沿触发）来到时检测到按键的复位操作才有效，否则无效。如图 15‑5所示最右边的三根红色的竖线表达的就是这种效果，sys_rst_n被拉低后led_out没有立刻变为0，而是当syc_clk的上升沿到来的时候led_out才复位成功，在复位释放的时候也是相同原因。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/register006.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/register006.png" alt="register006"></a></p>
<p>图 15‑5 同步复位的D触发器波形图</p>
<p><strong>异步复位的D触发器</strong></p>
<p>异步复位的D触发器中的“异步”是和工作时钟不同步的意思，也就是说，寄存器的复位不关心时钟的上升沿来不来，只要有检测到按键被按下，就立刻执行复位操作。如图 15‑6所示最右边的两根红色的竖线表达了这种效果，sys_rst_n被拉低后led_out立刻变为0，而不是等待syc_clk的上升沿到来的时候l ed_out才复位，而在复位释放的时候led_out不会立刻变为key_in的值，因为还要等待时钟上升沿到来到时才能检测到key_in的值，此时才将key_in的值赋值给led_out。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/register007.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/register007.png" alt="register007"></a></p>
<p>图 15‑6 异步复位的D触发器波形图</p>
<p>同步复位的D触发器和异步复位的D触发器的不同点已经在上面已经进行了详细的讲解，主要就是复位有效的条件是“立刻”执行还是等待“沿”再执行的区别。但是他们也有很多相同点，相比于组合逻辑电路来讲，对于电路中产生的毛刺有着极好的屏蔽作用，如上图中间位置的一组红色竖线所示，是我们模拟在干扰情况下产生的毛刺现象 ，因为时序电路只有在沿到来时才检测信号是否有效，所以在两个上升沿之间的毛刺都会被自然的过滤掉，可以大大减少毛刺现象产生的干扰，提高了电路中数据的可靠性。</p>
<p>时序电路还有一个特点，就是“延一拍”的效果。上面两个图最左边的一组红色竖线所表达的就是这个现象。key_in在复位后的第一个时钟的上升沿来到时拉高，我们可以发现此时led_out并没有在同一时刻也跟着拉高，而在之前的组合逻辑中输出是在输入变化的同一时刻立刻变化的，这是什么原因呢？</p>
<p>因为我们所画的波形图都是基于前仿真的，没有加入门延时的信息，所以很多时候数据的变化都是和时钟直接对齐的。当表达时序逻辑时如果时钟和数据是对齐的，则默认当前时钟沿采集到的数据为在该时钟上升沿前一时刻的值；当表达组合逻辑时如果时钟和数据是对齐的，则默认当前时钟沿采集到的数据为在该时钟上升沿同一时刻的值。 而仿真工具在进行RTL代码的仿真时也遵循这个规则，我们也可以理解为仿真寄存器是按照建立时间Tsu（指触发器的时钟信号上升沿到来以前，数据稳定不变的最小时间）最大（一个时钟周期），保持时间Th（指触发器的时钟信号上升沿到来以后，数据稳定不变的最小时间）最小（为0）的理想环境下进行的；而在仿真组合逻辑时 因为没有时钟也就没有建立时间和保持时间的概念，所以数据只要有变化就立刻有效。这里我们在画波形图的时候一定要记住这个“延一拍”的效果，否则我们绘制的波形图就会和最后的仿真结果不符，也可能会导致最后的逻辑混乱。</p>
<h4 id="7-3-3-3-代码编写¶"><a href="#7-3-3-3-代码编写¶" class="headerlink" title="7.3.3.3. 代码编写¶"></a>7.3.3.3. 代码编写<a href="#id10" title="永久链接至标题">¶</a></h4><p><strong>同步复位的D触发器</strong></p>
<table class="highlighttable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="n">flip_flop</span>
<span class="p">(</span>
<span class="k">input</span> <span class="kt">wire</span> <span class="n">sys_clk</span> <span class="p">,</span> <span class="c1">//系统时钟50Mh，后面我们都是设计的时序电路</span>
<span class="c1">//所以一定要有时钟，时序电路中几乎所有的信</span>
<span class="c1">//号都是伴随着时钟的沿（上升沿或下降沿，习</span>
<span class="c1">//惯上用上升沿）进行工作的</span>

<p><span class="k">input</span> <span class="kt">wire</span> <span class="n">sys_rst_n</span><span class="p">,</span> <span class="c1">&#x2F;&#x2F;全局复位，复位信号的主要作用是在系统出现</span><br><span class="c1">&#x2F;&#x2F;问题是能够回到初始状态，或一些信号的初始</span><br><span class="c1">&#x2F;&#x2F;化时需要进行复位</span></p>
<p><span class="k">input</span> <span class="kt">wire</span> <span class="n">key_in</span> <span class="p">,</span> <span class="c1">&#x2F;&#x2F;输入按键</span></p>
<p><span class="k">output</span> <span class="kt">reg</span> <span class="n">led_out</span> <span class="c1">&#x2F;&#x2F;输出控制led灯</span><br><span class="p">);</span></p>
<p><span class="c1">&#x2F;&#x2F;led_out:led灯输出的结果为key_in按键的输入值</span><br><span class="k">always</span><span class="p">@(</span><span class="k">posedge</span> <span class="n">sys_clk</span><span class="p">)</span> <span class="c1">&#x2F;&#x2F;当always块中的敏感列表为检测到sys_clk上升沿时</span><br><span class="c1">&#x2F;&#x2F;执行下面的语句</span></p>
<p><span class="k">if</span><span class="p">(</span><span class="n">sys_rst_n</span> <span class="o">&#x3D;&#x3D;</span> <span class="mh">1</span><span class="mb">‘b0</span><span class="p">)</span> <span class="c1">&#x2F;&#x2F;sys_rst_n为低电平时复位，但是这个复位有个大前</span><br><span class="c1">&#x2F;&#x2F;提，那就是当sys_clk的上升沿到来时，如果检测到</span><br><span class="c1">&#x2F;&#x2F;sys_rst_n为低电平则复位有效</span></p>
<p><span class="n">led_out</span> <span class="o">&lt;&#x3D;</span> <span class="mh">1</span><span class="mb">‘b0</span><span class="p">;</span> <span class="c1">&#x2F;&#x2F;复位的时候一定要给寄存器变量赋一个初值，一般情</span><br><span class="c1">&#x2F;&#x2F;况下赋值为0（特殊情况除外），在描述时序电路时</span><br><span class="c1">&#x2F;&#x2F;赋值符号一定要使用“&lt;&#x3D;”</span><br><span class="k">else</span><br><span class="n">led_out</span> <span class="o">&lt;&#x3D;</span> <span class="n">key_in</span><span class="p">;</span></p>
<p><span class="k">endmodule</span><br></pre></div></td></tr></tbody></table></p>
<p>根据上面RTL代码综合出的RTL视图如图 15‑7所示，由一个选择器和一个寄存器构成。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/register008.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/register008.png" alt="register008"></a></p>
<p>图 15‑7 同步复位的D触发器RTL视图</p>
<p><strong>异步复位的D触发器</strong></p>
<table class="highlighttable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="n">flip_flop</span>
<span class="p">(</span>
<span class="k">input</span> <span class="kt">wire</span> <span class="n">sys_clk</span> <span class="p">,</span> <span class="c1">//系统时钟50Mh</span>
<span class="k">input</span> <span class="kt">wire</span> <span class="n">sys_rst_n</span> <span class="p">,</span> <span class="c1">//全局复位</span>
<span class="k">input</span> <span class="kt">wire</span> <span class="n">key_in</span> <span class="p">,</span> <span class="c1">//输入按键</span>

<p><span class="k">output</span> <span class="kt">reg</span> <span class="n">led_out</span> <span class="c1">&#x2F;&#x2F;输出控制led灯</span><br><span class="p">);</span></p>
<p><span class="c1">&#x2F;&#x2F;led_out:led灯输出的结果为key_in按键的输入值</span><br><span class="c1">&#x2F;&#x2F;当always块中的敏感列表为检测到sys_clk上升沿或sys_rst_n下降沿时执行下面的语句</span><br><span class="k">always</span><span class="p">@(</span><span class="k">posedge</span> <span class="n">sys_clk</span> <span class="k">or</span> <span class="k">negedge</span> <span class="n">sys_rst_n</span><span class="p">)</span><br><span class="k">if</span><span class="p">(</span><span class="n">sys_rst_n</span> <span class="o">&#x3D;&#x3D;</span> <span class="mh">1</span><span class="mb">‘b0</span><span class="p">)</span><span class="c1">&#x2F;&#x2F;sys_rst_n为低电平时复位，且是检测到sys_rst_n的下</span><br><span class="c1">&#x2F;&#x2F;降沿时立刻复位，不需等待sys_clk的上升沿来到后再复位</span><br><span class="n">led_out</span> <span class="o">&lt;&#x3D;</span> <span class="mh">1</span><span class="mb">‘b0</span><span class="p">;</span><br><span class="k">else</span><br><span class="n">led_out</span> <span class="o">&lt;&#x3D;</span> <span class="n">key_in</span><span class="p">;</span></p>
<p><span class="k">endmodule</span><br></pre></div></td></tr></tbody></table></p>
<p>根据上面RTL代码综合出的RTL视图如图 15‑8所示，只有一个寄存器构成。<a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/register009.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/register009.png" alt="register009"></a></p>
<p>图 15‑8 异步复位的D触发器RTL视图（一）</p>
<p>如果复位时的值不是0而改为1，相当于复位时将D触发器置为1，则使用D 触发器上的置位端口，其综合的RTL视图如图 15‑9所示。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/register010.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/register010.png" alt="register010"></a></p>
<p>图 15‑9 异步复位的D触发器RTL视图（二）</p>
<p>通过上面同步复位和异步复位综合出的D触发器的RTL视图对比，我们可以发现，采用同步复位会多出来一个选择器的结构，这里我们可能不禁会有疑问，为什么多了一个选择器？我们设计的RTL逻辑中并没有想表达这个选择器的意思，这显然对我们最初想要表达的的设计是多余的，所以我们在使用Intel（Altera）芯片时 最好使用异步复位（如果是Xilinx的芯片则推荐使用同步复位，Xilinx最新的UltraFast推荐不使用复位，后面会在内部结构和时序分析中解释原因），这样子就可以节约更多的逻辑资源，之所以会有这样的差异是由于FPGA内部结构决定的，后面我们会从FPGA的内部结构中详细解释。</p>
<h4 id="7-3-3-4-仿真验证¶"><a href="#7-3-3-4-仿真验证¶" class="headerlink" title="7.3.3.4. 仿真验证¶"></a>7.3.3.4. 仿真验证<a href="#id11" title="永久链接至标题">¶</a></h4><p>仿真文件编写</p>
<p>仿真文件参考代码如下：</p>
<table class="highlighttable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">\`timescale</span> <span class="mh">1</span><span class="n">ns</span><span class="o">/</span><span class="mh">1</span><span class="n">ns</span>
<span class="k">module</span> <span class="n">tb_flip_flop</span><span class="p">();</span>

<p><span class="c1">&#x2F;&#x2F;reg define</span><br><span class="kt">reg</span> <span class="n">sys_clk</span> <span class="p">;</span><br><span class="kt">reg</span> <span class="n">sys_rst_n</span> <span class="p">;</span><br><span class="kt">reg</span> <span class="n">key_in</span> <span class="p">;</span></p>
<p><span class="c1">&#x2F;&#x2F;wire deifne</span><br><span class="kt">wire</span> <span class="n">led_out</span> <span class="p">;</span></p>
<p><span class="c1">&#x2F;&#x2F;初始化系统时钟、全局复位和输入信号</span><br><span class="k">initial</span> <span class="k">begin</span><br><span class="n">sys_clk</span> <span class="o">&#x3D;</span> <span class="mh">1</span><span class="mb">‘b1</span><span class="p">;</span> <span class="c1">&#x2F;&#x2F;时钟信号的初始化为1，且使用“&#x3D;”赋值，</span><br><span class="c1">&#x2F;&#x2F;其他信号的赋值都是用“&lt;&#x3D;”</span><br><span class="n">sys_rst_n</span> <span class="o">&lt;&#x3D;</span> <span class="mh">1</span><span class="mb">‘b0</span><span class="p">;</span> <span class="c1">&#x2F;&#x2F;因为低电平复位，所以复位信号的初始化为0</span><br><span class="n">key_in</span> <span class="o">&lt;&#x3D;</span> <span class="mh">1</span><span class="mb">‘b0</span><span class="p">;</span> <span class="c1">&#x2F;&#x2F;输入信号按键的初始化，为0和1均可</span><br><span class="p">#</span><span class="mh">20</span><br><span class="n">sys_rst_n</span> <span class="o">&lt;&#x3D;</span> <span class="mh">1</span><span class="mb">‘b1</span><span class="p">;</span> <span class="c1">&#x2F;&#x2F;初始化20ns后，复位释放，因为是低电平复位</span><br><span class="c1">&#x2F;&#x2F;所示释放时，把信号拉高后系统才开始工作</span><br><span class="p">#</span><span class="mh">210</span><br><span class="n">sys_rst_n</span> <span class="o">&lt;&#x3D;</span> <span class="mh">1</span><span class="mb">‘b0</span><span class="p">;</span> <span class="c1">&#x2F;&#x2F;为了观察同步复位和异步复位的区别，在复位释放后</span><br><span class="c1">&#x2F;&#x2F;电路工作210ns后再让复位有效。之所以选择延时210ns</span><br><span class="c1">&#x2F;&#x2F;而不是200ns或220ns，是因为能够使复位信号在时钟下</span><br><span class="c1">&#x2F;&#x2F;降沿时复位，能够清晰的看出同步复位和异步复位的差别</span><br><span class="p">#</span><span class="mh">40</span><br><span class="n">sys_rst_n</span> <span class="o">&lt;&#x3D;</span> <span class="mh">1</span><span class="mb">‘b1</span><span class="p">;</span> <span class="c1">&#x2F;&#x2F;复位40ns后再次让复位释放掉</span><br><span class="k">end</span></p>
<p><span class="c1">&#x2F;&#x2F;sys_clk:模拟系统时钟，每10ns电平翻转一次，周期为20ns，频率为50Mhz</span><br><span class="k">always</span> <span class="p">#</span><span class="mh">10</span> <span class="n">sys_clk</span> <span class="o">&#x3D;</span> <span class="o">~</span><span class="n">sys_clk</span><span class="p">;</span> <span class="c1">&#x2F;&#x2F;使用always产生时钟信号，让时钟每隔10ns反转一</span><br><span class="c1">&#x2F;&#x2F;次，即一个时钟周期为20ns，换算为频率为50Mhz</span></p>
<p><span class="c1">&#x2F;&#x2F;key_in:产生输入随机数，模拟按键的输入情况</span><br><span class="k">always</span> <span class="p">#</span><span class="mh">20</span> <span class="n">key_in</span> <span class="o">&lt;&#x3D;</span> <span class="p">{</span><span class="nb">$random</span><span class="p">}</span> <span class="o">%</span> <span class="mh">2</span><span class="p">;</span> <span class="c1">&#x2F;&#x2F;取模求余数，产生非负随机数0、1，每隔20ns</span><br><span class="c1">&#x2F;&#x2F;产生一次随机数（之所以每20ns产生一次随机</span><br><span class="c1">&#x2F;&#x2F;数而不是之前的每10ns产生一次随机数，是为</span><br><span class="c1">&#x2F;&#x2F;了在时序逻辑中能够保证key_in信号的变化的</span><br><span class="c1">&#x2F;&#x2F;时间小于等于时钟的周期，这样就不会产生类</span><br><span class="c1">&#x2F;&#x2F;似毛刺的变化信号，虽然产生的毛刺在时序电</span><br><span class="c1">&#x2F;&#x2F;路中也能被滤除掉，但是不便于我们观察波形）</span></p>
<p><span class="c1">&#x2F;&#x2F;————————————————————</span><br><span class="k">initial</span> <span class="k">begin</span><br><span class="nb">$timeformat</span><span class="p">(</span><span class="o">-</span><span class="mh">9</span><span class="p">,</span> <span class="mh">0</span><span class="p">,</span> <span class="s">“ns”</span><span class="p">,</span> <span class="mh">6</span><span class="p">);</span><br><span class="nb">$monitor</span><span class="p">(</span><span class="s">“@time %t: key_in&#x3D;%b led_out&#x3D;%b”</span><span class="p">,</span> <span class="nb">$time</span><span class="p">,</span> <span class="n">key_in</span><span class="p">,</span> <span class="n">led_out</span><span class="p">);</span><br><span class="k">end</span><br><span class="c1">&#x2F;&#x2F;————————————————————</span></p>
<p><span class="c1">&#x2F;&#x2F;——————flip_flop_inst——————-</span><br><span class="n">flip_flop</span> <span class="n">flip_flop_inst</span><br><span class="p">(</span><br><span class="p">.</span><span class="n">sys_clk</span> <span class="p">(</span><span class="n">sys_clk</span> <span class="p">),</span> <span class="c1">&#x2F;&#x2F;input sys_clk</span><br><span class="p">.</span><span class="n">sys_rst_n</span> <span class="p">(</span><span class="n">sys_rst_n</span> <span class="p">),</span> <span class="c1">&#x2F;&#x2F;input sys_rst_n</span><br><span class="p">.</span><span class="n">key_in</span> <span class="p">(</span><span class="n">key_in</span> <span class="p">),</span> <span class="c1">&#x2F;&#x2F;input key_in</span></p>
<p><span class="p">.</span><span class="n">led_out</span> <span class="p">(</span><span class="n">led_out</span> <span class="p">)</span> <span class="c1">&#x2F;&#x2F;output led_out</span><br><span class="p">);</span></p>
<p><span class="k">endmodule</span><br></pre></div></td></tr></tbody></table></p>
<p>begin…end是一个串行块在Testbench中被使用时其内部的语句是顺序执行的，在本例中的13-28行代码中，我们多次进行延时，其时间是在之前基础上叠加的，而不是从0时刻开始计算时间。</p>
<p>仿真波形分析</p>
<p>我们在观察时序逻辑时不能再像观察组合逻辑那样子，因为输入和输出会有延一拍的效果，如果输入数据在前一个时钟的上升沿变化，则输出数据不会立刻变化，而是在下一个时钟的上升沿才变化，这样的现象我们简单化运用——当时钟和信号在同一时刻变化时，我们以时钟的上升沿前一时刻采集的输入信号为依据来产生输出信号，这样我 们就可以很好的观察时序逻辑产生的波形了。</p>
<p><strong>同步复位的D触发器</strong></p>
<p>仿真出来的波形如图 15‑10所示，我们让仿真运行了500ns即可得到较好的观察效果。首先复位为高电平的那一刻是和时钟的上升沿对齐的，根据上面的原则，其实此处的上升沿采集到的复位信号为该上升沿前一时刻的值，也就是低电平，所以寄存器处于复位状态，使led_out依然保持为低电平，而在下一个时钟的上升沿 前一时刻时复位信号已经为高电平，复位被释放，且key_in为高电平，所以此时led_out也为高电平，这种分析最后的现象完全契合了延一拍的效果（直观上看到的波形是对齐的，其实我们要取的值是时钟上升沿前一时刻得值），中间我们又加入了一段时间的复位，可以看到同步复位的效果。和最初设计的波形图对比发现是完 全一致的。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/register011.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/register011.png" alt="register011"></a></p>
<p>图 15‑10 同步复位仿真波形图</p>
<p>我们观察“Transcript”界面（如图 15‑11所示）中打印的结果，也发现key_in和led_out的值是延一拍的对应关系，有些时候会因这种延时一拍的关系导致对打印数据的观测不是很直观，特别是我们中间还加了复位的控制，不知道的还以为是出现了错误，使之更难于观察，这也是我们为什么在本节中没有列 出真值表的原因。在时序逻辑电路中真值表并不能很清晰的表达时序的对应关系，反而是用波形图表达的更加清晰，而在以后的设计中，我们并不是不再用“Transcript”界面打印信息，而是不再这样完全把信号进行简单的列举显示，我们会打印一些关键时刻点的打印信息或者是设计一些特殊的打印信息以方便对特殊时刻点信号 的观察。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/register012.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/register012.png" alt="register012"></a></p>
<p>图 15‑11 Transcript界面</p>
<p><strong>异步复位的D触发器</strong></p>
<p>我们使用和同步复位的D触发器一样的时序电路分析波形的方法，如图 15‑12所示，经过仔细的验证发现符合异步复位D触发器的逻辑设计。而我们就不再打印异步复位的D触发器的信息了。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/register013.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/register013.png" alt="register013"></a></p>
<p>图 15‑12 异步复位仿真波形图</p>
<h3 id="7-3-4-上板验证¶"><a href="#7-3-4-上板验证¶" class="headerlink" title="7.3.4. 上板验证¶"></a>7.3.4. 上板验证<a href="#id12" title="永久链接至标题">¶</a></h3><h4 id="7-3-4-1-引脚约束¶"><a href="#7-3-4-1-引脚约束¶" class="headerlink" title="7.3.4.1. 引脚约束¶"></a>7.3.4.1. 引脚约束<a href="#id13" title="永久链接至标题">¶</a></h4><p>仿真验证通过后，准备上板验证，上板验证之前先要进行引脚约束。工程中各输入输出信号与开发板引脚对应关系如表格 15‑2所示。引脚配置如图 15‑13所示。</p>
<p>表格 15‑2 引脚分配表</p>
<table>
<thead>
<tr>
<th><strong>信号名</strong></th>
<th><strong>信号类型</strong></th>
<th><strong>对应引脚</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td>sys_clk</td>
<td>Input</td>
<td>E1</td>
<td>时钟</td>
</tr>
<tr>
<td>sys_rst_n</td>
<td>Input</td>
<td>M15</td>
<td>复位按键</td>
</tr>
<tr>
<td>key_in</td>
<td>Input</td>
<td>M2</td>
<td>按键</td>
</tr>
<tr>
<td>led_out</td>
<td>Output</td>
<td>L7</td>
<td>LED灯</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/register014.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/register014.png" alt="register014"></a></p>
<p>图 15‑13 引脚配置图</p>
<h4 id="7-3-4-2-结果验证¶"><a href="#7-3-4-2-结果验证¶" class="headerlink" title="7.3.4.2. 结果验证¶"></a>7.3.4.2. 结果验证<a href="#id14" title="永久链接至标题">¶</a></h4><p>如图 15‑14所示，开发板连接5V直流电源和USB-Blaster下载器JTAG端口。线路正确连接后，打开开关为板卡上电。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/register015.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/register015.png" alt="register015"></a></p>
<p>图 15‑14 程序下载连线图</p>
<p>如图 15‑15所示，使用“Programmer”为开发板下载程序。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/register016.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/register016.png" alt="register016"></a></p>
<p>图 15‑15 程序下载窗口</p>
<p>下载完成后按下按键KEY1，会发现同时被绑定的led随着按键的按下会被点亮，而按键松开时又熄灭，实现了我们最初预想的设计，如图 15‑16所示。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/register017.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/register017.png" alt="register017"></a></p>
<p>图 15‑16 上板效果图</p>
<h2 id="7-4-章末总结¶"><a href="#7-4-章末总结¶" class="headerlink" title="7.4. 章末总结¶"></a>7.4. 章末总结<a href="#id15" title="永久链接至标题">¶</a></h2><p>本章首次讲解了FPGA中的时序逻辑，这也是我们正式学习、认识FPGA的一个新开始，因为用FPGA设计的大型电路几乎都是以时序逻辑为主的，我们也会在今后更加看到FPGA大显身手的时刻。</p>
<p>本章中我们还对比了同步复位的D触发器和异步复位的D触发器在波形、代码编写、逻辑资源上的不同，并给出了推荐的用法，希望大家能够在以后的设计中加以规范，熟练使用。在代码的设计上要深刻体会组合逻辑和时序逻辑的差别，特别是在用always块描述时，要理解电平触发和沿触发的区别，注意敏感列表的不同。</p>
<p>always块实现时序逻辑时无论是单比特信号还是多比特信号都具有这种延一拍的效果。我们在后面设计时要养成一些“条件反射”，即做到根据波形写代码的时候看到波形中有延一拍的现象时就要想到用always块的时序逻辑来实现；看到always块表达时序逻辑时就要想要波形中会延一拍的效果，我们经常会听到有人说把 数据“打一拍”其实就是这个意思。</p>
<p><strong>新语法总结</strong></p>
<p>重点掌握</p>
<p>1、always语句块描述时序逻辑的用法</p>
<p>2、&lt;&#x3D;（赋值号的一种，阻塞赋值，在可综合的模块中表达时序逻辑的语句时使用）</p>
<p><strong>知识点总结</strong></p>
<p>1、了解什么是D触发器（寄存器）；</p>
<p>2、同步复位的D触发器和异步复位的D触发器的区别；</p>
<p>3、理解组合逻辑电路和时序逻辑电路在波形设计和代码实现上的区别；</p>
<p>4、掌握如何画时序逻辑电路的波形；</p>
<p>5、理解时序电路中会延一拍的现象；</p>
<p>6、学会分析时序电路仿真出的波形；</p>
<p>7、理解begin…end在Testbench中的用法及意义。</p>
<h2 id="7-5-拓展训练¶"><a href="#7-5-拓展训练¶" class="headerlink" title="7.5. 拓展训练¶"></a>7.5. 拓展训练<a href="#id16" title="永久链接至标题">¶</a></h2><p>细心的朋友可能会发现发两个仿真的波形在最开始的一段时间内有所不同，同步复位的D触发器在开始一段时间内是红色的信号，而异步复位的D触发器就没有这种现象，产生这种现象的原因是什么，仿真波形中的红色信号又代表什么意思呢？</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/index.html">[野火]FPGA Verilog开发实战指南——基于Altera EP4CE10 征途Mini开发板</a></p>
<p><a target="_blank" rel="noopener" href="https://detail.tmall.com/item.htm?spm=a1z10.5-b-s.w4011-23268010681.61.57491550QDVCO3&id=620698035547&rn=e00cc4fa5edac965f85f43020a263844&abbucket=18"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_static/images/product.png" alt="产品图片"></a></p>
<p>野火征途Mini FPGA开发板，采用Altera EP4CE10F17C8作为主控，包含了FPGA入门必备的硬件，是FPGA入门的性价比之选。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/index.html"></a>»</li>
<li>9. 按键消抖模块的设计与验证</li>
</ul>
<hr>
<h1 id="9-按键消抖模块的设计与验证¶"><a href="#9-按键消抖模块的设计与验证¶" class="headerlink" title="9. 按键消抖模块的设计与验证¶"></a>9. 按键消抖模块的设计与验证<a href="#id1" title="永久链接至标题">¶</a></h1><h2 id="9-1-章节导读¶"><a href="#9-1-章节导读¶" class="headerlink" title="9.1. 章节导读¶"></a>9.1. 章节导读<a href="#id2" title="永久链接至标题">¶</a></h2><p>按键是最为常见的电子元器件之一，在电子设计中应用广泛。在FPGA的实验工程中，我们可以使用其作为系统复位信号或者控制信号的外部输入；在日常生活中，遥控器、玩具、计算器等等电子产品都使用按键。目前按键种类繁多，常见的有自锁按键、薄膜按键等等。我们开发板上使用的机械按键也是按键的一种，特点是：接触电阻小 ，手感好，按键按下或弹起时有“滴答”清脆声；但由于其构造和原理，在按键闭合及断开的瞬间均伴随有一连串的抖动。</p>
<p>本章节中，我们要根据机械按键的构造与原理，设计并实现按键消抖模块。以开发板上的物理按键作为输入信号，使用设计的按键消抖模块对输入的按键信号进行消抖处理，输出能够正常使用的按键触发信号。</p>
<h2 id="9-2-理论学习¶"><a href="#9-2-理论学习¶" class="headerlink" title="9.2. 理论学习¶"></a>9.2. 理论学习<a href="#id3" title="永久链接至标题">¶</a></h2><p>如图 19‑1所示，我们所使用的按键开关为机械弹性开关，当机械触点断开、闭合时，由于机械触点的弹性作用，一个按键开关在闭合时不会马上稳定地接通，在断开时也不会一下子断开。因而在闭合及断开的瞬间均伴随有一连串的抖动，为了不产生这种现象而做的措施就是按键消抖。按键抖动原理图如图 19‑2所示。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Key002.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Key002.png" alt="Key002"></a></p>
<p>图 19‑1 机械按键外观图</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Key003.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Key003.png" alt="Key003"></a></p>
<p>图 19‑2 机械按键抖动原理图</p>
<p>抖动时间的长短由按键的机械特性决定，一般为5ms~10ms。按键稳定闭合时间的长短则是由操作人员的按键动作决定的，一般为零点几秒至数秒。按键抖动会引起一次按键被误读多次。为确保控制器对按键的一次闭合仅作一次处理，必须去除按键的抖动。在按键闭合稳定时读取按键的状态，并且必须判别到按键释放稳定后再作处理 。</p>
<p>消抖是为了避免在按键按下或是抬起时电平剧烈抖动带来的影响。按键的消抖，可用硬件或软件两种<a target="_blank" rel="noopener" href="https://baike.so.com/doc/5382414-5618769.html">方法</a>。</p>
<h3 id="9-2-1-硬件消抖¶"><a href="#9-2-1-硬件消抖¶" class="headerlink" title="9.2.1. 硬件消抖¶"></a>9.2.1. 硬件消抖<a href="#id4" title="永久链接至标题">¶</a></h3><p>在按键个数较少时可用硬件方法消除键抖动。如图 19‑3所示的RS触发器为常用的硬件去抖。图中两个与非门构成一个RS触发器。当按键未按下时，输出为0；当键按下时，输出为1。此时即使用按键的机械性能，使按键因弹性抖动而产生瞬时断开(抖动跳开B)，只要按键不返回原始状态A，双稳态电路的状态不改变，输出保持 为0，不会产生抖动的波形。也就是说，即使B点的电压波形是抖动的，但经双稳态电路之后，其输出为正规的矩形波。这一点通过分析RS触发器的工作过程很容易得到验证。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Key004.jpeg"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Key004.jpeg" alt="Key004"></a></p>
<p>图 19‑3 硬件消抖原理</p>
<h3 id="9-2-2-软件消抖¶"><a href="#9-2-2-软件消抖¶" class="headerlink" title="9.2.2. 软件消抖¶"></a>9.2.2. 软件消抖<a href="#id5" title="永久链接至标题">¶</a></h3><p>如果按键个数较多，常用软件方法去抖，即检测出按键闭合后执行一个延时程序，根据抖动的时间为5ms~10ms，我们产生一个20ms的延时，让前沿抖动消失后再一次检测键的状态，如果仍保持闭合状态电平，则确认为真正有键按下。</p>
<h2 id="9-3-实战演练¶"><a href="#9-3-实战演练¶" class="headerlink" title="9.3. 实战演练¶"></a>9.3. 实战演练<a href="#id6" title="永久链接至标题">¶</a></h2><p>前面已经分析了按键抖动的机理和消除按键抖动的几种方案，我们知道硬件消抖会使用一些额外的器件占用电路板上的空间，从而在一定程度上增加了PCB布局布线的复杂度，所以我们用软件消抖的方式来实现去抖动的操作，去抖动后的效果是当按键按下后能够准确检测到按键被按下了一次，而不会因机械抖动发生按键重复多次按下的现 象。</p>
<h3 id="9-3-1-实验目标¶"><a href="#9-3-1-实验目标¶" class="headerlink" title="9.3.1. 实验目标¶"></a>9.3.1. 实验目标<a href="#id7" title="永久链接至标题">¶</a></h3><p>利用所学知识，设计并实现一个按键消抖模块，将外部输入的单比特按键信号做消抖处理后输出，输出信号正常可被其他模块调用。</p>
<h3 id="9-3-2-程序设计¶"><a href="#9-3-2-程序设计¶" class="headerlink" title="9.3.2. 程序设计¶"></a>9.3.2. 程序设计<a href="#id8" title="永久链接至标题">¶</a></h3><p>本实验工程只涉及一个模块，就是按键消抖模块。接下来，我们将从模块框图、波形图绘制等各个进行讲解。</p>
<h4 id="9-3-2-1-模块框图¶"><a href="#9-3-2-1-模块框图¶" class="headerlink" title="9.3.2.1. 模块框图¶"></a>9.3.2.1. 模块框图<a href="#id9" title="永久链接至标题">¶</a></h4><p>因为我们要计数过滤掉按键抖动的时间，所以计数器是必不可少的，所以我们设计的模块一定会用到时序电路，所以时钟sys_clk和复位sys_rst_n信号一定先加上，而且是输入信号，另外还有一个输入信号就是按键的输入key_in，我们最终要实现的就是对输入的key_in信号进行去抖动，输出信号为去抖动后的 稳定的按键信号key_flag。根据上面的分析设计出的visio框图如图 19‑4所示。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Key005.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Key005.png" alt="Key005"></a></p>
<p>图 19‑4 按键消抖模块框图</p>
<p>端口列表与功能总结如表格 19‑1所示。</p>
<p>表格 19‑1 端口列表与功能总结</p>
<p>|<br><strong>信号</strong></p>
<p> | </p>
<p><strong>位宽</strong></p>
<p> | </p>
<p><strong>类型</strong></p>
<p> | </p>
<p><strong>功能描述</strong></p>
<p> |<br>| — | — | — | — |<br>| </p>
<p>sys_clk</p>
<p> | </p>
<p>1Bit</p>
<p> | </p>
<p>Input</p>
<p> | </p>
<p>工作时钟，频率50Mhz</p>
<p> |<br>| </p>
<p>sys_rst_n</p>
<p> | </p>
<p>1Bit</p>
<p> | </p>
<p>Input</p>
<p> | </p>
<p>复位信号，低电平有效</p>
<p> |<br>| </p>
<p>key_in</p>
<p> | </p>
<p>1Bit</p>
<p> | </p>
<p>Input</p>
<p> | </p>
<p>按键的输入</p>
<p> |<br>| </p>
<p>key_flag</p>
<p> | </p>
<p>1Bit</p>
<p> | </p>
<p>Output</p>
<p> | </p>
<p>去抖后按键被按下的标志信号</p>
<p> |</p>
<h4 id="9-3-2-2-波形图绘制¶"><a href="#9-3-2-2-波形图绘制¶" class="headerlink" title="9.3.2.2. 波形图绘制¶"></a>9.3.2.2. 波形图绘制<a href="#id10" title="永久链接至标题">¶</a></h4><p>首先我们从实际问题出发，分析抖动的本质，再想办法去消除抖动。我们先把波形图的三个输入信号画好，抖动我们就模拟和真实中的情况一样，即当按键被按下和按键被释放时都会有抖动，也就是有前抖动和后抖动，这两种抖动都会对我们的设计产生一定的影响，会让我们的系统误判为按键被多次按下。我们需要做的就是要准确判断出稳 定的按下的那一次状态。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Key006.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Key006.png" alt="Key006"></a></p>
<p>图 19‑5 按键消抖模块波形图（一）</p>
<p>按键的抖动会产生如图 19‑5所示的毛刺，毛刺中会有低电平的情况，但是因为机械抖动的原因很快又回拉高了，如果我们把其中的每次的低电平和高电平都采集到，那么相当于是按键被按下了好多次，而不是我们想要的一次，所以我们一定要把这段抖动给滤除掉，这段抖动的时间我们通过前面的分析是已知的，抖动的时间是小于10 ms的，而当有20ms的时间内都没有抖动就说明按键已经处于稳定状态了，也就是说我们可以做一个计数器来进行计数，计数20ms的时间，也就是说只要20ms的时间内都没有抖动产生，那结果是什么电平就是什么，我们需要做的是找到最后一次抖动的时间是在什么时候，才能够开启这20ms的计数，否则这20ms内不能够 保证都是我们的安全时间。当然有的同学可能会说我在单片机的设计中都是检测第一次按键为低电平了就开始计数，然后延时一段大于30ms的时间后再检测得到的按键电平就是稳定的按键信号，难道这种方式不可以吗？这种方式虽然也是可以的，但不是最好的，因为这会浪费我们的不必要时间，也就是说虽然抖动的时间理论上不会大于 10ms，但是具体是多少可能每次按键实验的结果都不相同，如果我们每次都按照最大的抖动时间10ms来计算无疑会“多”考虑了一些时间，所以我们采用一种更“节约”时间的方法，我们添加一个名为cnt_20ms用于计数20ms时间的计数器，每当系统检测到按键输入信号为低电平时cnt_20ms计数器就开始计数， 在cnt_20ms计数器计数期间内，如果再次检测到按键为高电平则说明上次检测到的低电平一定是个抖动，那么我们就将这个计数器清零，总结为简单的一句话就是：当系统检测到按键为低电平时cnt_20ms计数器就计数，当检测到按键为高电平时cnt_20ms计数器就清零。讲到这里主要问题我们就已经解决了，然后要 考虑cnt_20ms计数器计数个数和计数满了后该怎么处理以及滤除抖动后的输出信号key_flag什么时候拉高、拉低的问题。</p>
<p>首先是考虑计数器的问题，根据我们使用的50Mhz的晶振来计算，cnt_20ms计数器计数20ms时间所需要计数的个数为999_999，计数器计数满后我们习惯性先清零，如果有问题我们根据分析再进行修改。而key_flag信号则是一个脉冲信号，也就是只有一个时钟周期的高电平，且当cnt_20ms计数器计 数到999_999时才拉高，而这个高电平只能存在一个。按照cnt_20ms计数器计数到999_999时清零来分析，其波形图如图 19‑6所示，按键会因为低电平的时间太久，会存在多个20ms的时间，cnt_20ms计数器计数满清零多次，这样就会有多个计数值为999_999的情况，从而导致key_fla g信号产生多次脉冲，这显然是我们不想要的结果。那我们需要分析是cnt_20ms计数器清零的问题还是key_flag信号拉高时间的问题。经分析key_flag信号即使不是在cnt_20ms计数器计数到999_999时拉高而在其他时间拉高也会出现同样的问题，所以那只能怀疑是cnt_20ms计数器清零的条 件不对了。刚开始的时候cnt_20ms计数器清零已经有一个条件了，那就是当输入信号key_in只要为高电平就将cnt_20ms计数器清零，那这里我们就让cnt_20ms计数器计数满后保持为999_999而不清零，等待输入信号key_in为高电平的时候再清零。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Key007.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Key007.png" alt="Key007"></a></p>
<p>图 19‑6 按键消抖模块波形图（二）</p>
<p>修改cnt_20ms计数器清零后的结果如图 19‑7所示，我们可以发现key_flag信号确实不会产生多个了，而是出现了新的问题，key_flag信号也不是脉冲了，是一个长长的电平信号，这也不是我们想要的结果，其根本原因是cnt_20ms计数器计数到999_999后保持在999_999的时间太久导致的。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Key008.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Key008.png" alt="Key008"></a></p>
<p>图 19‑7 按键消抖模块波形图（三）</p>
<p>针对上面的探索，我们最终灵机一动，发现cnt_20ms计数器计数到999_998的次数只有一个，而且最接近999_999，在既保证去抖动时间的前提下使key_flag信号只产生一个脉冲信号。最终的波形结果如图 19‑8所示。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Key009.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Key009.png" alt="Key009"></a></p>
<p>图 19‑8 按键消抖模块波形图（四）</p>
<h4 id="9-3-2-3-代码编写¶"><a href="#9-3-2-3-代码编写¶" class="headerlink" title="9.3.2.3. 代码编写¶"></a>9.3.2.3. 代码编写<a href="#id11" title="永久链接至标题">¶</a></h4><p>在波形图绘制小节，我们结合相关理论知识，讲解并绘制了按键消抖模块波形图。我们参照波形图，编写模块参考代码。参考代码编写较为简单，且有详细注释，此处不再过多讲解，按键消抖模块参考代码，具体见代码清单 19‑1。</p>
<p>代码清单 19‑1 按键消抖模块参考代码(key_filter.v)</p>
<table class="highlighttable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="n">key_filter</span>
<span class="p">#(</span>
<span class="k">parameter</span> <span class="n">CNT_MAX</span> <span class="o">=</span> <span class="mh">20</span><span class="mi">'d999</span><span class="n">_999</span> <span class="c1">//计数器计数最大值</span>
<span class="p">)</span>
<span class="p">(</span>
<span class="k">input</span> <span class="kt">wire</span> <span class="n">sys_clk</span> <span class="p">,</span> <span class="c1">//系统时钟50Mhz</span>
<span class="k">input</span> <span class="kt">wire</span> <span class="n">sys_rst_n</span> <span class="p">,</span> <span class="c1">//全局复位</span>
<span class="k">input</span> <span class="kt">wire</span> <span class="n">key_in</span> <span class="p">,</span> <span class="c1">//按键输入信号</span>

<p><span class="k">output</span> <span class="kt">reg</span> <span class="n">key_flag</span> <span class="c1">&#x2F;&#x2F;key_flag为1时表示消抖后检测到按键被按下</span><br><span class="c1">&#x2F;&#x2F;key_flag为0时表示没有检测到按键被按下</span><br><span class="p">);</span></p>
<p><span class="c1">&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="c1">&#x2F;&#x2F;* Parameter and Internal Signal /&#x2F;</span><br><span class="c1">&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="c1">&#x2F;&#x2F;reg define</span><br><span class="kt">reg</span> <span class="p">[</span><span class="mh">19</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">cnt_20ms</span> <span class="p">;</span> <span class="c1">&#x2F;&#x2F;计数器</span></p>
<p><span class="c1">&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="c1">&#x2F;&#x2F;* Main Code /&#x2F;</span><br><span class="c1">&#x2F;&#x2F;&#x2F;&#x2F;</span></p>
<p><span class="c1">&#x2F;&#x2F;cnt_20ms:如果时钟的上升沿检测到外部按键输入的值为低电平时，计数器开始计数</span><br><span class="k">always</span><span class="p">@(</span><span class="k">posedge</span> <span class="n">sys_clk</span> <span class="k">or</span> <span class="k">negedge</span> <span class="n">sys_rst_n</span><span class="p">)</span><br><span class="k">if</span><span class="p">(</span><span class="n">sys_rst_n</span> <span class="o">&#x3D;&#x3D;</span> <span class="mh">1</span><span class="mb">‘b0</span><span class="p">)</span><br><span class="n">cnt_20ms</span> <span class="o">&lt;&#x3D;</span> <span class="mh">20</span><span class="mb">‘b0</span><span class="p">;</span><br><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">key_in</span> <span class="o">&#x3D;&#x3D;</span> <span class="mh">1</span><span class="mb">‘b1</span><span class="p">)</span><br><span class="n">cnt_20ms</span> <span class="o">&lt;&#x3D;</span> <span class="mh">20</span><span class="mb">‘b0</span><span class="p">;</span><br><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">cnt_20ms</span> <span class="o">&#x3D;&#x3D;</span> <span class="n">CNT_MAX</span> <span class="o">&amp;&amp;</span> <span class="n">key_in</span> <span class="o">&#x3D;&#x3D;</span> <span class="mh">1</span><span class="mb">‘b0</span><span class="p">)</span><br><span class="n">cnt_20ms</span> <span class="o">&lt;&#x3D;</span> <span class="n">cnt_20ms</span><span class="p">;</span><br><span class="k">else</span><br><span class="n">cnt_20ms</span> <span class="o">&lt;&#x3D;</span> <span class="n">cnt_20ms</span> <span class="o">+</span> <span class="mh">1</span><span class="mb">‘b1</span><span class="p">;</span></p>
<p><span class="c1">&#x2F;&#x2F;key_flag:当计数满20ms后产生按键有效标志位</span><br><span class="c1">&#x2F;&#x2F;且key_flag在999_999时拉高,维持一个时钟的高电平</span><br><span class="k">always</span><span class="p">@(</span><span class="k">posedge</span> <span class="n">sys_clk</span> <span class="k">or</span> <span class="k">negedge</span> <span class="n">sys_rst_n</span><span class="p">)</span><br><span class="k">if</span><span class="p">(</span><span class="n">sys_rst_n</span> <span class="o">&#x3D;&#x3D;</span> <span class="mh">1</span><span class="mb">‘b0</span><span class="p">)</span><br><span class="n">key_flag</span> <span class="o">&lt;&#x3D;</span> <span class="mh">1</span><span class="mb">‘b0</span><span class="p">;</span><br><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">cnt_20ms</span> <span class="o">&#x3D;&#x3D;</span> <span class="n">CNT_MAX</span> <span class="o">-</span> <span class="mh">1</span><span class="mb">‘b1</span><span class="p">)</span><br><span class="n">key_flag</span> <span class="o">&lt;&#x3D;</span> <span class="mh">1</span><span class="mb">‘b1</span><span class="p">;</span><br><span class="k">else</span><br><span class="n">key_flag</span> <span class="o">&lt;&#x3D;</span> <span class="mh">1</span><span class="mb">‘b0</span><span class="p">;</span></p>
<p><span class="k">endmodule</span><br></pre></div></td></tr></tbody></table></p>
<h4 id="9-3-2-4-仿真验证¶"><a href="#9-3-2-4-仿真验证¶" class="headerlink" title="9.3.2.4. 仿真验证¶"></a>9.3.2.4. 仿真验证<a href="#id12" title="永久链接至标题">¶</a></h4><p>仿真文件编写</p>
<p>按键消模块参考代码编写完毕，为验证代码正确性，对模块参考代码进行仿真验证。编写模块仿真代码，具体见代码清单 19‑2。仿真参考代码中有有详细注释，此处不再过多介绍。</p>
<p>代码清单 19‑2 按键消抖模块仿真参考代码(tb_key_filter.v)</p>
<table class="highlighttable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">\`timescale</span> <span class="mh">1</span><span class="n">ns</span><span class="o">/</span><span class="mh">1</span><span class="n">ns</span>
<span class="k">module</span> <span class="n">tb_key_filter</span><span class="p">();</span>

<p><span class="c1">&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="c1">&#x2F;&#x2F;* Parameter and Internal Signal /&#x2F;</span><br><span class="c1">&#x2F;&#x2F;&#x2F;&#x2F;</span></p>
<p><span class="c1">&#x2F;&#x2F;parameter define</span><br><span class="c1">&#x2F;&#x2F;为了缩短仿真时间，我们将参数化的时间值改小</span><br><span class="c1">&#x2F;&#x2F;但位宽依然定义和参数名的值保持一致</span><br><span class="c1">&#x2F;&#x2F;也可以将这些参数值改成和参数名的值一致</span><br><span class="k">parameter</span> <span class="n">CNT_1MS</span> <span class="o">&#x3D;</span> <span class="mh">20</span><span class="mi">‘d19</span> <span class="p">,</span><br><span class="n">CNT_11MS</span> <span class="o">&#x3D;</span> <span class="mh">21</span><span class="mi">‘d69</span> <span class="p">,</span><br><span class="n">CNT_41MS</span> <span class="o">&#x3D;</span> <span class="mh">22</span><span class="mi">‘d149</span> <span class="p">,</span><br><span class="n">CNT_51MS</span> <span class="o">&#x3D;</span> <span class="mh">22</span><span class="mi">‘d199</span> <span class="p">,</span><br><span class="n">CNT_60MS</span> <span class="o">&#x3D;</span> <span class="mh">22</span><span class="mi">‘d249</span> <span class="p">;</span></p>
<p><span class="c1">&#x2F;&#x2F;wire define</span><br><span class="kt">wire</span> <span class="n">key_flag</span> <span class="p">;</span> <span class="c1">&#x2F;&#x2F;消抖后按键信号</span></p>
<p><span class="c1">&#x2F;&#x2F;reg define</span><br><span class="kt">reg</span> <span class="n">sys_clk</span> <span class="p">;</span> <span class="c1">&#x2F;&#x2F;仿真时钟信号</span><br><span class="kt">reg</span> <span class="n">sys_rst_n</span> <span class="p">;</span> <span class="c1">&#x2F;&#x2F;仿真复位信号</span><br><span class="kt">reg</span> <span class="n">key_in</span> <span class="p">;</span> <span class="c1">&#x2F;&#x2F;模拟按键输入</span><br><span class="kt">reg</span> <span class="p">[</span><span class="mh">21</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">tb_cnt</span> <span class="p">;</span> <span class="c1">&#x2F;&#x2F;模拟按键抖动计数器</span></p>
<p><span class="c1">&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="c1">&#x2F;&#x2F;* Main Code /&#x2F;</span><br><span class="c1">&#x2F;&#x2F;&#x2F;&#x2F;</span></p>
<p><span class="c1">&#x2F;&#x2F;初始化输入信号</span><br><span class="k">initial</span> <span class="k">begin</span><br><span class="n">sys_clk</span> <span class="o">&#x3D;</span> <span class="mh">1</span><span class="mb">‘b1</span><span class="p">;</span><br><span class="n">sys_rst_n</span> <span class="o">&lt;&#x3D;</span> <span class="mh">1</span><span class="mb">‘b0</span><span class="p">;</span><br><span class="n">key_in</span> <span class="o">&lt;&#x3D;</span> <span class="mh">1</span><span class="mb">‘b0</span><span class="p">;</span><br><span class="p">#</span><span class="mh">20</span><br><span class="n">sys_rst_n</span> <span class="o">&lt;&#x3D;</span> <span class="mh">1</span><span class="mb">‘b1</span><span class="p">;</span><br><span class="k">end</span></p>
<p><span class="c1">&#x2F;&#x2F;sys_clk:模拟系统时钟，每10ns电平翻转一次，周期为20ns，频率为50Mhz</span><br><span class="k">always</span> <span class="p">#</span><span class="mh">10</span> <span class="n">sys_clk</span> <span class="o">&#x3D;</span> <span class="o">~</span><span class="n">sys_clk</span><span class="p">;</span></p>
<p><span class="c1">&#x2F;&#x2F;tb_cnt:按键过程计数器，通过该计数器的计数时间来模拟按键的抖动过程</span><br><span class="k">always</span><span class="p">@(</span><span class="k">posedge</span> <span class="n">sys_clk</span> <span class="k">or</span> <span class="k">negedge</span> <span class="n">sys_rst_n</span><span class="p">)</span><br><span class="k">if</span><span class="p">(</span><span class="n">sys_rst_n</span> <span class="o">&#x3D;&#x3D;</span> <span class="mh">1</span><span class="mb">‘b0</span><span class="p">)</span><br><span class="n">tb_cnt</span> <span class="o">&lt;&#x3D;</span> <span class="mh">22</span><span class="mb">‘b0</span><span class="p">;</span><br><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">tb_cnt</span> <span class="o">&#x3D;&#x3D;</span> <span class="n">CNT_60MS</span><span class="p">)</span><br><span class="c1">&#x2F;&#x2F;计数器计数到CNT_60MS完成一次按键从按下到释放的整个过程</span><br><span class="n">tb_cnt</span> <span class="o">&lt;&#x3D;</span> <span class="mh">22</span><span class="mb">‘b0</span><span class="p">;</span><br><span class="k">else</span><br><span class="n">tb_cnt</span> <span class="o">&lt;&#x3D;</span> <span class="n">tb_cnt</span> <span class="o">+</span> <span class="mh">1</span><span class="mb">‘b1</span><span class="p">;</span></p>
<p><span class="c1">&#x2F;&#x2F;key_in:产生输入随机数，模拟按键的输入情况</span><br><span class="k">always</span><span class="p">@(</span><span class="k">posedge</span> <span class="n">sys_clk</span> <span class="k">or</span> <span class="k">negedge</span> <span class="n">sys_rst_n</span><span class="p">)</span><br><span class="k">if</span><span class="p">(</span><span class="n">sys_rst_n</span> <span class="o">&#x3D;&#x3D;</span> <span class="mh">1</span><span class="mb">‘b0</span><span class="p">)</span><br><span class="n">key_in</span> <span class="o">&lt;&#x3D;</span> <span class="mh">1</span><span class="mb">‘b1</span><span class="p">;</span> <span class="c1">&#x2F;&#x2F;按键未按下时的状态为为高电平</span><br><span class="k">else</span> <span class="k">if</span><span class="p">((</span><span class="n">tb_cnt</span> <span class="o">&gt;&#x3D;</span> <span class="n">CNT_1MS</span> <span class="o">&amp;&amp;</span> <span class="n">tb_cnt</span> <span class="o">&lt;&#x3D;</span> <span class="n">CNT_11MS</span><span class="p">)</span><br><span class="n">||</span> <span class="p">(</span><span class="n">tb_cnt</span> <span class="o">&gt;&#x3D;</span> <span class="n">CNT_41MS</span> <span class="o">&amp;&amp;</span> <span class="n">tb_cnt</span> <span class="o">&lt;&#x3D;</span> <span class="n">CNT_51MS</span><span class="p">))</span><br><span class="c1">&#x2F;&#x2F;在该计数区间内产生非负随机数0、1来模拟10ms的前抖动和10ms的后抖动</span><br><span class="n">key_in</span> <span class="o">&lt;&#x3D;</span> <span class="p">{</span><span class="nb">$random</span><span class="p">}</span> <span class="o">%</span> <span class="mh">2</span><span class="p">;</span><br><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">tb_cnt</span> <span class="o">&gt;&#x3D;</span> <span class="n">CNT_11MS</span> <span class="o">&amp;&amp;</span> <span class="n">tb_cnt</span> <span class="o">&lt;&#x3D;</span> <span class="n">CNT_41MS</span><span class="p">)</span><br><span class="n">key_in</span> <span class="o">&lt;&#x3D;</span> <span class="mh">1</span><span class="mb">‘b0</span><span class="p">;</span><br><span class="c1">&#x2F;&#x2F;按键经过10ms的前抖动后稳定在低电平，持续时间需大于CNT_MAX</span><br><span class="k">else</span><br><span class="n">key_in</span> <span class="o">&lt;&#x3D;</span> <span class="mh">1</span><span class="mb">‘b1</span><span class="p">;</span></p>
<p><span class="c1">&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="c1">&#x2F;&#x2F;* Instantiation /&#x2F;</span><br><span class="c1">&#x2F;&#x2F;&#x2F;&#x2F;</span></p>
<p><span class="c1">&#x2F;&#x2F;————————key_filter_inst————————</span><br><span class="n">key_filter</span><br><span class="p">#(</span><br><span class="p">.</span><span class="n">CNT_MAX</span> <span class="p">(</span><span class="mh">20</span><span class="mi">‘d24</span> <span class="p">)</span><br><span class="c1">&#x2F;&#x2F;修改的CNT_MAX值一定要小于(CNT_41MS - CNT_11MS)</span><br><span class="c1">&#x2F;&#x2F;否则就会表现为按键一直处于“抖动状态”而没有“稳定状态”</span><br><span class="c1">&#x2F;&#x2F;无法模拟出按键消抖的效果</span><br><span class="p">)</span><br><span class="n">key_filter_inst</span><br><span class="p">(</span><br><span class="p">.</span><span class="n">sys_clk</span> <span class="p">(</span><span class="n">sys_clk</span> <span class="p">),</span> <span class="c1">&#x2F;&#x2F;input sys_clk</span><br><span class="p">.</span><span class="n">sys_rst_n</span> <span class="p">(</span><span class="n">sys_rst_n</span> <span class="p">),</span> <span class="c1">&#x2F;&#x2F;input sys_rst_n</span><br><span class="p">.</span><span class="n">key_in</span> <span class="p">(</span><span class="n">key_in</span> <span class="p">),</span> <span class="c1">&#x2F;&#x2F;input key_in</span></p>
<p><span class="p">.</span><span class="n">key_flag</span> <span class="p">(</span><span class="n">key_flag</span> <span class="p">)</span> <span class="c1">&#x2F;&#x2F;output key_flag</span><br><span class="p">);</span></p>
<p><span class="k">endmodule</span><br></pre></div></td></tr></tbody></table></p>
<p>仿真波形分析</p>
<p>使用ModelSim软件对按键消抖模块进行仿真，仿真方式可选择与Quartus II联合仿真或使用ModelSim单独仿真。</p>
<p>模块仿真波形如下，图 19‑9为按键消抖模块整体仿真波形图；图 19‑10、图 19‑11和图 19‑12为按键消抖模块局部仿真波形图，分别为前抖动部分、稳定部分和后抖动部分的仿真波形。由整体和局部仿真波形可以看出，模块仿真波形和绘制波形图，各信号波形变化一致，模块通过仿真验证。</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Key010.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Key010.png" alt="Key010"></a></p>
<p>图 19‑9 按键消抖模块整体仿真波形图</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Key011.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Key011.png" alt="Key011"></a></p>
<p>图 19‑10 按键消抖模块前抖动仿真波形图</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Key012.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Key012.png" alt="Key012"></a></p>
<p>图 19‑11 按键消抖模块稳定部分仿真波形图</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Key013.png"><img src="https://doc.embedfire.com/fpga/altera/ep4ce10_mini/zh/latest/_images/Key013.png" alt="Key013"></a></p>
<p>图 19‑12 按键消抖模块后抖动仿真波形图</p>
<h2 id="9-4-章末总结¶"><a href="#9-4-章末总结¶" class="headerlink" title="9.4. 章末总结¶"></a>9.4. 章末总结<a href="#id13" title="永久链接至标题">¶</a></h2><p>通过本例我们可以发现在画波形图时不一定可以保证100%正确，根据分析，我们可以适当的调整，这也是设计之前画波形图的意义所在，而不是一抹黑的、漫无目的的调试代码。</p>
<p>其实在项目的设计过程中并不是一帆风顺的，往往会遇到各种各样的问题，通过经过思考与探索尝试使我们最终得出正确的结果。如果总是站在上帝视角去考虑问题，而抛弃分析真理的过程，这对于学习来说将是巨大的损失。</p>
<p>希望学习者能深入体会设计中遇到的问题并掌握设计分析的方法，养成一个善于思考敢于尝试的习惯，学会通过分析绘制波形图来提前预判潜在的设计问题。</p>
<h2 id="9-5-拓展训练¶"><a href="#9-5-拓展训练¶" class="headerlink" title="9.5. 拓展训练¶"></a>9.5. 拓展训练<a href="#id14" title="永久链接至标题">¶</a></h2><p>本例我们实现的是一个按键的消抖操作，如果我们有很多按键都需要消抖的话，理论上需要实例化多次按键消抖模块，那有什么方法可以更方便的实现这种操作吗？大家可以想一想。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://fylhg.github.io/github.fy">二马山石</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://fylhg.github.io/github.fy/2024/05/24/FPGA%20-%20%E7%82%B9%E4%BA%AE%E7%AC%AC%E4%B8%80%E4%B8%AAled/">https://fylhg.github.io/github.fy/2024/05/24/FPGA%20-%20%E7%82%B9%E4%BA%AE%E7%AC%AC%E4%B8%80%E4%B8%AAled/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://fylhg.github.io/github.fy" target="_blank">FY的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/github.fy/tags/fpga/">fpga</a></div><div class="post_share"><div class="social-share" data-image="https://img1.baidu.com/it/u=2942801448,4270513960&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=281" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/github.fy/2024/05/25/Verilog%E8%AF%AD%E6%B3%95/" title="verilog语法"><img class="cover" src="https://picx.zhimg.com/v2-8914ff9e3185a4a0e1ac1f7b037e9cb8_720w.jpg?source=172ae18b" onerror="onerror=null;src='/github.fy/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">verilog语法</div></div></a></div><div class="next-post pull-right"><a href="/github.fy/2024/05/23/FPGA/" title="fpga"><img class="cover" src="https://img1.baidu.com/it/u=4248986468,2019673196&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=479&amp;h=320" onerror="onerror=null;src='/github.fy/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">fpga</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/github.fy/2024/05/23/FPGA/" title="fpga"><img class="cover" src="https://img1.baidu.com/it/u=4248986468,2019673196&fm=253&fmt=auto&app=138&f=JPEG?w=479&h=320" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-23</div><div class="title">fpga</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/github.fy/img/1.jpg" onerror="this.onerror=null;this.src='/github.fy/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">二马山石</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/github.fy/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/github.fy/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/github.fy/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E7%82%B9%E4%BA%AE%E4%BD%A0%E7%9A%84LED%E7%81%AF%C2%B6"><span class="toc-number">1.</span> <span class="toc-text">2. 点亮你的LED灯</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E7%AB%A0%E8%8A%82%E5%AF%BC%E8%AF%BB%C2%B6"><span class="toc-number">1.1.</span> <span class="toc-text">2.1. 章节导读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B%C2%B6"><span class="toc-number">1.2.</span> <span class="toc-text">2.2. 正确的设计流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%B7%A5%E7%A8%8B%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E7%AE%A1%E7%90%86%C2%B6"><span class="toc-number">1.3.</span> <span class="toc-text">2.3. 工程文件夹的管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B%C2%B6"><span class="toc-number">1.4.</span> <span class="toc-text">2.4. 一个完整的设计过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-%E5%8A%9F%E8%83%BD%E7%AE%80%E4%BB%8B%C2%B6"><span class="toc-number">1.4.1.</span> <span class="toc-text">2.4.1. 功能简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-%E7%A1%AC%E4%BB%B6%E8%B5%84%E6%BA%90%C2%B6"><span class="toc-number">1.4.2.</span> <span class="toc-text">2.4.2. 硬件资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-3-%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AAVisio%E6%96%87%E4%BB%B6%E5%8F%8A%E5%85%B6%E9%85%8D%E7%BD%AE%C2%B6"><span class="toc-number">1.4.3.</span> <span class="toc-text">2.4.3. 新建一个Visio文件及其配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-4-%E6%A8%A1%E5%9D%97%E5%92%8C%E7%AB%AF%E5%8F%A3%E4%BF%A1%E5%8F%B7%E5%88%92%E5%88%86%C2%B6"><span class="toc-number">1.4.4.</span> <span class="toc-text">2.4.4. 模块和端口信号划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-5-%E6%B3%A2%E5%BD%A2%E8%AE%BE%E8%AE%A1%C2%B6"><span class="toc-number">1.4.5.</span> <span class="toc-text">2.4.5. 波形设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-6-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%C2%B6"><span class="toc-number">1.4.6.</span> <span class="toc-text">2.4.6. 新建工程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-7-RTL%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BC%96%E5%86%99%C2%B6"><span class="toc-number">1.4.7.</span> <span class="toc-text">2.4.7. RTL代码的编写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-8-%E4%BB%A3%E7%A0%81%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E7%BB%BC%E5%90%88%C2%B6"><span class="toc-number">1.4.8.</span> <span class="toc-text">2.4.8. 代码的分析和综合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-9-RTL%E8%A7%86%E5%9B%BE%E7%9A%84%E6%9F%A5%E7%9C%8B%C2%B6"><span class="toc-number">1.4.9.</span> <span class="toc-text">2.4.9. RTL视图的查看</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-10-Testbench%E7%9A%84%E5%8E%9F%E7%90%86%C2%B6"><span class="toc-number">1.4.10.</span> <span class="toc-text">2.4.10. Testbench的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-11-Testbench%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BC%96%E5%86%99%C2%B6"><span class="toc-number">1.4.11.</span> <span class="toc-text">2.4.11. Testbench代码的编写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-12-%E4%BB%BF%E7%9C%9F%E8%AE%BE%E7%BD%AE%C2%B6"><span class="toc-number">1.4.12.</span> <span class="toc-text">2.4.12. 仿真设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-13-NativeLink%E7%9A%84%E8%AE%BE%E7%BD%AE%C2%B6"><span class="toc-number">1.4.13.</span> <span class="toc-text">2.4.13. NativeLink的设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-14-%E6%89%93%E5%BC%80ModelSim%E8%A7%82%E5%AF%9F%E6%B3%A2%E5%BD%A2%C2%B6"><span class="toc-number">1.4.14.</span> <span class="toc-text">2.4.14. 打开ModelSim观察波形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-15-%E4%BB%BF%E7%9C%9F%E6%B3%A2%E5%BD%A2%E5%88%86%E6%9E%90%C2%B6"><span class="toc-number">1.4.15.</span> <span class="toc-text">2.4.15. 仿真波形分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-16-%E5%BC%95%E8%84%9A%E7%BA%A6%E6%9D%9F%C2%B6"><span class="toc-number">1.4.16.</span> <span class="toc-text">2.4.16. 引脚约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-17-%E9%80%9A%E8%BF%87JTAG%E5%B0%86%E7%BD%91%E8%A1%A8%E4%B8%8B%E8%BD%BD%E5%88%B0%E5%BC%80%E5%8F%91%E6%9D%BF%C2%B6"><span class="toc-number">1.4.17.</span> <span class="toc-text">2.4.17. 通过JTAG将网表下载到开发板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-18-%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%AE%A1%E8%84%9A%E7%9A%84%E9%BB%98%E8%AE%A4%E8%AE%BE%E7%BD%AE%C2%B6"><span class="toc-number">1.4.18.</span> <span class="toc-text">2.4.18. 未使用管脚的默认设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-19-%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9B%BA%E5%8C%96%C2%B6"><span class="toc-number">1.4.19.</span> <span class="toc-text">2.4.19. 程序的固化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E7%AB%A0%E6%9C%AB%E6%80%BB%E7%BB%93%C2%B6"><span class="toc-number">1.5.</span> <span class="toc-text">2.5. 章末总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E6%8B%93%E5%B1%95%E8%AE%AD%E7%BB%83%C2%B6"><span class="toc-number">1.6.</span> <span class="toc-text">2.6. 拓展训练</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E7%AE%80%E5%8D%95%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91-%E2%80%94-%E5%A4%9A%E8%B7%AF%E9%80%89%E6%8B%A9%E5%99%A8%C2%B6"><span class="toc-number">2.</span> <span class="toc-text">3. 简单组合逻辑 — 多路选择器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E7%AB%A0%E8%8A%82%E5%AF%BC%E8%AF%BB%C2%B6"><span class="toc-number">2.1.</span> <span class="toc-text">3.1. 章节导读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0%C2%B6"><span class="toc-number">2.2.</span> <span class="toc-text">3.2. 理论学习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83%C2%B6"><span class="toc-number">2.3.</span> <span class="toc-text">3.3. 实战演练</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E5%AE%9E%E9%AA%8C%E7%9B%AE%E6%A0%87%C2%B6"><span class="toc-number">2.3.1.</span> <span class="toc-text">3.3.1. 实验目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E7%A1%AC%E4%BB%B6%E8%B5%84%E6%BA%90%C2%B6"><span class="toc-number">2.3.2.</span> <span class="toc-text">3.3.2. 硬件资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%C2%B6"><span class="toc-number">2.3.3.</span> <span class="toc-text">3.3.3. 程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-1-%E6%A8%A1%E5%9D%97%E6%A1%86%E5%9B%BE%C2%B6"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">3.3.3.1. 模块框图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-2-%E6%B3%A2%E5%BD%A2%E5%9B%BE%E7%BB%98%E5%88%B6%C2%B6"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">3.3.3.2. 波形图绘制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-3-%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%C2%B6"><span class="toc-number">2.3.3.3.</span> <span class="toc-text">3.3.3.3. 代码编写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-4-%E4%BB%BF%E7%9C%9F%E9%AA%8C%E8%AF%81%C2%B6"><span class="toc-number">2.3.3.4.</span> <span class="toc-text">3.3.3.4. 仿真验证</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-4-%E4%B8%8A%E6%9D%BF%E9%AA%8C%E8%AF%81%C2%B6"><span class="toc-number">2.3.4.</span> <span class="toc-text">3.3.4. 上板验证</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-4-1-%E5%BC%95%E8%84%9A%E7%BA%A6%E6%9D%9F%C2%B6"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">3.3.4.1. 引脚约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-4-2-%E7%BB%93%E6%9E%9C%E9%AA%8C%E8%AF%81%C2%B6"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">3.3.4.2. 结果验证</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E7%AB%A0%E6%9C%AB%E6%80%BB%E7%BB%93%C2%B6"><span class="toc-number">2.4.</span> <span class="toc-text">3.4. 章末总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E6%8B%93%E5%B1%95%E8%AE%AD%E7%BB%83%C2%B6"><span class="toc-number">2.5.</span> <span class="toc-text">3.5. 拓展训练</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E7%AE%80%E5%8D%95%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91-%E2%80%94-%E8%AF%91%E7%A0%81%E5%99%A8%C2%B6"><span class="toc-number">3.</span> <span class="toc-text">4. 简单组合逻辑 — 译码器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E7%AB%A0%E8%8A%82%E5%AF%BC%E8%AF%BB%C2%B6"><span class="toc-number">3.1.</span> <span class="toc-text">4.1. 章节导读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0%C2%B6"><span class="toc-number">3.2.</span> <span class="toc-text">4.2. 理论学习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83%C2%B6"><span class="toc-number">3.3.</span> <span class="toc-text">4.3. 实战演练</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-%E5%AE%9E%E9%AA%8C%E7%9B%AE%E6%A0%87%C2%B6"><span class="toc-number">3.3.1.</span> <span class="toc-text">4.3.1. 实验目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%C2%B6"><span class="toc-number">3.3.2.</span> <span class="toc-text">4.3.2. 程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-1-%E6%A8%A1%E5%9D%97%E6%A1%86%E5%9B%BE%C2%B6"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">4.3.2.1. 模块框图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-2-%E6%B3%A2%E5%BD%A2%E5%9B%BE%E7%BB%98%E5%88%B6%C2%B6"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">4.3.2.2. 波形图绘制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-3-%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%C2%B6"><span class="toc-number">3.3.2.3.</span> <span class="toc-text">4.3.2.3. 代码编写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-4-%E4%BB%BF%E7%9C%9F%E9%AA%8C%E8%AF%81%C2%B6"><span class="toc-number">3.3.2.4.</span> <span class="toc-text">4.3.2.4. 仿真验证</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E7%AB%A0%E6%9C%AB%E6%80%BB%E7%BB%93%C2%B6"><span class="toc-number">3.4.</span> <span class="toc-text">4.4. 章末总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E6%8B%93%E5%B1%95%E8%AE%AD%E7%BB%83%C2%B6"><span class="toc-number">3.5.</span> <span class="toc-text">4.5. 拓展训练</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E7%AE%80%E5%8D%95%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91-%E2%80%94-%E5%8D%8A%E5%8A%A0%E5%99%A8%C2%B6"><span class="toc-number">4.</span> <span class="toc-text">5. 简单组合逻辑 — 半加器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E7%AB%A0%E8%8A%82%E5%AF%BC%E8%AF%BB%C2%B6"><span class="toc-number">4.1.</span> <span class="toc-text">5.1. 章节导读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0%C2%B6"><span class="toc-number">4.2.</span> <span class="toc-text">5.2. 理论学习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83%C2%B6"><span class="toc-number">4.3.</span> <span class="toc-text">5.3. 实战演练</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-%E5%AE%9E%E9%AA%8C%E7%9B%AE%E6%A0%87%C2%B6"><span class="toc-number">4.3.1.</span> <span class="toc-text">5.3.1. 实验目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2-%E7%A1%AC%E4%BB%B6%E8%B5%84%E6%BA%90%C2%B6"><span class="toc-number">4.3.2.</span> <span class="toc-text">5.3.2. 硬件资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-3-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%C2%B6"><span class="toc-number">4.3.3.</span> <span class="toc-text">5.3.3. 程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-3-1-%E6%A8%A1%E5%9D%97%E6%A1%86%E5%9B%BE%C2%B6"><span class="toc-number">4.3.3.1.</span> <span class="toc-text">5.3.3.1. 模块框图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-3-2-%E6%B3%A2%E5%BD%A2%E5%9B%BE%E7%BB%98%E5%88%B6%C2%B6"><span class="toc-number">4.3.3.2.</span> <span class="toc-text">5.3.3.2. 波形图绘制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-3-3-%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%C2%B6"><span class="toc-number">4.3.3.3.</span> <span class="toc-text">5.3.3.3. 代码编写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-3-4-%E4%BB%BF%E7%9C%9F%E9%AA%8C%E8%AF%81%C2%B6"><span class="toc-number">4.3.3.4.</span> <span class="toc-text">5.3.3.4. 仿真验证</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-4-%E4%B8%8A%E6%9D%BF%E9%AA%8C%E8%AF%81%C2%B6"><span class="toc-number">4.3.4.</span> <span class="toc-text">5.3.4. 上板验证</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-4-1-%E5%BC%95%E8%84%9A%E7%BA%A6%E6%9D%9F%C2%B6"><span class="toc-number">4.3.4.1.</span> <span class="toc-text">5.3.4.1. 引脚约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-4-2-%E7%BB%93%E6%9E%9C%E9%AA%8C%E8%AF%81%C2%B6"><span class="toc-number">4.3.4.2.</span> <span class="toc-text">5.3.4.2. 结果验证</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E7%AB%A0%E6%9C%AB%E6%80%BB%E7%BB%93%C2%B6"><span class="toc-number">4.4.</span> <span class="toc-text">5.4. 章末总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E6%8B%93%E5%B1%95%E8%AE%AD%E7%BB%83%C2%B6"><span class="toc-number">4.5.</span> <span class="toc-text">5.5. 拓展训练</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E9%81%BF%E5%85%8DLatch%E7%9A%84%E4%BA%A7%E7%94%9F%C2%B6"><span class="toc-number">5.</span> <span class="toc-text">6. 避免Latch的产生</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E7%AB%A0%E8%8A%82%E5%AF%BC%E8%AF%BB%C2%B6"><span class="toc-number">5.1.</span> <span class="toc-text">6.1. 章节导读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-Latch%E6%98%AF%E4%BB%80%E4%B9%88%C2%B6"><span class="toc-number">5.2.</span> <span class="toc-text">6.2. Latch是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-Latch%E7%9A%84%E5%8D%B1%E5%AE%B3%C2%B6"><span class="toc-number">5.3.</span> <span class="toc-text">6.3. Latch的危害</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E5%87%A0%E7%A7%8D%E4%BA%A7%E7%94%9FLatch%E7%9A%84%E6%83%85%E5%86%B5%C2%B6"><span class="toc-number">5.4.</span> <span class="toc-text">6.4. 几种产生Latch的情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-%E7%AB%A0%E6%9C%AB%E6%80%BB%E7%BB%93%C2%B6"><span class="toc-number">5.5.</span> <span class="toc-text">6.5. 章末总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%9A%84%E5%BC%80%E5%A7%8B-%E2%80%94-%E5%AF%84%E5%AD%98%E5%99%A8%C2%B6"><span class="toc-number">6.</span> <span class="toc-text">7. 时序逻辑的开始 — 寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E7%AB%A0%E8%8A%82%E5%AF%BC%E8%AF%BB%C2%B6"><span class="toc-number">6.1.</span> <span class="toc-text">7.1. 章节导读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0%C2%B6"><span class="toc-number">6.2.</span> <span class="toc-text">7.2. 理论学习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83%C2%B6"><span class="toc-number">6.3.</span> <span class="toc-text">7.3. 实战演练</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-1-%E5%AE%9E%E9%AA%8C%E7%9B%AE%E6%A0%87%C2%B6"><span class="toc-number">6.3.1.</span> <span class="toc-text">7.3.1. 实验目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-2-%E7%A1%AC%E4%BB%B6%E8%B5%84%E6%BA%90%C2%B6"><span class="toc-number">6.3.2.</span> <span class="toc-text">7.3.2. 硬件资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-3-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%C2%B6"><span class="toc-number">6.3.3.</span> <span class="toc-text">7.3.3. 程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-3-1-%E6%A8%A1%E5%9D%97%E6%A1%86%E5%9B%BE%C2%B6"><span class="toc-number">6.3.3.1.</span> <span class="toc-text">7.3.3.1. 模块框图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-3-2-%E6%B3%A2%E5%BD%A2%E5%9B%BE%E7%BB%98%E5%88%B6%C2%B6"><span class="toc-number">6.3.3.2.</span> <span class="toc-text">7.3.3.2. 波形图绘制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-3-3-%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%C2%B6"><span class="toc-number">6.3.3.3.</span> <span class="toc-text">7.3.3.3. 代码编写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-3-4-%E4%BB%BF%E7%9C%9F%E9%AA%8C%E8%AF%81%C2%B6"><span class="toc-number">6.3.3.4.</span> <span class="toc-text">7.3.3.4. 仿真验证</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-4-%E4%B8%8A%E6%9D%BF%E9%AA%8C%E8%AF%81%C2%B6"><span class="toc-number">6.3.4.</span> <span class="toc-text">7.3.4. 上板验证</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-4-1-%E5%BC%95%E8%84%9A%E7%BA%A6%E6%9D%9F%C2%B6"><span class="toc-number">6.3.4.1.</span> <span class="toc-text">7.3.4.1. 引脚约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-4-2-%E7%BB%93%E6%9E%9C%E9%AA%8C%E8%AF%81%C2%B6"><span class="toc-number">6.3.4.2.</span> <span class="toc-text">7.3.4.2. 结果验证</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E7%AB%A0%E6%9C%AB%E6%80%BB%E7%BB%93%C2%B6"><span class="toc-number">6.4.</span> <span class="toc-text">7.4. 章末总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-%E6%8B%93%E5%B1%95%E8%AE%AD%E7%BB%83%C2%B6"><span class="toc-number">6.5.</span> <span class="toc-text">7.5. 拓展训练</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E6%8C%89%E9%94%AE%E6%B6%88%E6%8A%96%E6%A8%A1%E5%9D%97%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E9%AA%8C%E8%AF%81%C2%B6"><span class="toc-number">7.</span> <span class="toc-text">9. 按键消抖模块的设计与验证</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E7%AB%A0%E8%8A%82%E5%AF%BC%E8%AF%BB%C2%B6"><span class="toc-number">7.1.</span> <span class="toc-text">9.1. 章节导读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0%C2%B6"><span class="toc-number">7.2.</span> <span class="toc-text">9.2. 理论学习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-1-%E7%A1%AC%E4%BB%B6%E6%B6%88%E6%8A%96%C2%B6"><span class="toc-number">7.2.1.</span> <span class="toc-text">9.2.1. 硬件消抖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-2-%E8%BD%AF%E4%BB%B6%E6%B6%88%E6%8A%96%C2%B6"><span class="toc-number">7.2.2.</span> <span class="toc-text">9.2.2. 软件消抖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83%C2%B6"><span class="toc-number">7.3.</span> <span class="toc-text">9.3. 实战演练</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-1-%E5%AE%9E%E9%AA%8C%E7%9B%AE%E6%A0%87%C2%B6"><span class="toc-number">7.3.1.</span> <span class="toc-text">9.3.1. 实验目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-2-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%C2%B6"><span class="toc-number">7.3.2.</span> <span class="toc-text">9.3.2. 程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-2-1-%E6%A8%A1%E5%9D%97%E6%A1%86%E5%9B%BE%C2%B6"><span class="toc-number">7.3.2.1.</span> <span class="toc-text">9.3.2.1. 模块框图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-2-2-%E6%B3%A2%E5%BD%A2%E5%9B%BE%E7%BB%98%E5%88%B6%C2%B6"><span class="toc-number">7.3.2.2.</span> <span class="toc-text">9.3.2.2. 波形图绘制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-2-3-%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%C2%B6"><span class="toc-number">7.3.2.3.</span> <span class="toc-text">9.3.2.3. 代码编写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-2-4-%E4%BB%BF%E7%9C%9F%E9%AA%8C%E8%AF%81%C2%B6"><span class="toc-number">7.3.2.4.</span> <span class="toc-text">9.3.2.4. 仿真验证</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-%E7%AB%A0%E6%9C%AB%E6%80%BB%E7%BB%93%C2%B6"><span class="toc-number">7.4.</span> <span class="toc-text">9.4. 章末总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-5-%E6%8B%93%E5%B1%95%E8%AE%AD%E7%BB%83%C2%B6"><span class="toc-number">7.5.</span> <span class="toc-text">9.5. 拓展训练</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/github.fy/2024/08/05/QT%20-%20add/" title="Qt"><img src="https://t8.baidu.com/it/u=4067589254,2956208776&amp;fm=193" onerror="this.onerror=null;this.src='/github.fy/img/404.jpg'" alt="Qt"/></a><div class="content"><a class="title" href="/github.fy/2024/08/05/QT%20-%20add/" title="Qt">Qt</a><time datetime="2024-08-05T05:59:31.581Z" title="发表于 2024-08-05 13:59:31">2024-08-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/github.fy/2024/07/31/%E5%8A%9B%E6%89%A3%E9%A2%98%E7%9B%AE/" title="leetcode"><img src="/github.fy/img/404.jpg" onerror="this.onerror=null;this.src='/github.fy/img/404.jpg'" alt="leetcode"/></a><div class="content"><a class="title" href="/github.fy/2024/07/31/%E5%8A%9B%E6%89%A3%E9%A2%98%E7%9B%AE/" title="leetcode">leetcode</a><time datetime="2024-07-31T08:42:06.141Z" title="发表于 2024-07-31 16:42:06">2024-07-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/github.fy/2024/07/21/QT/" title="Qt"><img src="https://t8.baidu.com/it/u=4067589254,2956208776&amp;fm=193" onerror="this.onerror=null;this.src='/github.fy/img/404.jpg'" alt="Qt"/></a><div class="content"><a class="title" href="/github.fy/2024/07/21/QT/" title="Qt">Qt</a><time datetime="2024-07-21T05:50:00.611Z" title="发表于 2024-07-21 13:50:00">2024-07-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/github.fy/2024/07/12/C++/" title="c++"><img src="https://img2.baidu.com/it/u=1339810107,1799612389&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=512&amp;h=328" onerror="this.onerror=null;this.src='/github.fy/img/404.jpg'" alt="c++"/></a><div class="content"><a class="title" href="/github.fy/2024/07/12/C++/" title="c++">c++</a><time datetime="2024-07-12T07:18:51.931Z" title="发表于 2024-07-12 15:18:51">2024-07-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/github.fy/2024/07/04/esp32%E7%AC%94%E8%AE%B0/" title="esp32"><img src="http://micropython.86x.net/en/latet/_images/esp32.jpg" onerror="this.onerror=null;this.src='/github.fy/img/404.jpg'" alt="esp32"/></a><div class="content"><a class="title" href="/github.fy/2024/07/04/esp32%E7%AC%94%E8%AE%B0/" title="esp32">esp32</a><time datetime="2024-07-04T05:46:02.527Z" title="发表于 2024-07-04 13:46:02">2024-07-04</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://img1.baidu.com/it/u=2942801448,4270513960&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=281')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 二马山石</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/github.fy/js/utils.js?v=4.13.0"></script><script src="/github.fy/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script id="canvas_nest" defer="defer" color="(0,205,205)" opacity="0.7" zIndex="-1" count="99" mobile="true" src="/github.fy/%5Bobject%20Object%5D"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>